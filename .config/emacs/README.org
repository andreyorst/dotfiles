#+title: Emacs configuration with Org Mode
#+author: Andrey Orst
#+email: andreyorst@gmail.com
#+setupfile: ./.org-defaults.org
#+startup: noinlineimages
#+property: header-args :tangle "./init.el" :results silent

[[file:.screenshot.png]]

* About this document
This is my Emacs configuration file written as Org document.  I do all
edits here,  then /compile/ it to  =init.el= file. Emacs is  complex tool,
and  by having  my configuration  in Org  Mode, I  can separate  it to
different sections,  elaborate each  change, and  toggle configuration
parts on and off with ease.

I  try to  maintain my  Emacs  configuration simple,  fast, and  small
keeping as much  of vanilla Emacs behaviors  as I can, but  I'm a sane
person so some  aspects, which are actually insane in  my opinion, are
changed.

This file is self contained configuration  for Emacs 26 and higher, so
it is the only file you need to bootstrap Emacs, and it will configure
itself, although you  need [[https://orgmode.org/][Org Mode]] for this to  work.  Org mode comes
with  all current  versions  of Emacs,  and =org-babel-tangle=  function
should be available. If you've downloaded this file, run this function
on it, and  Emacs will be configured.  This function  exports all code
blocks  accordingly  to  =header-args=  property  at  the  top  of  this
document, and  under some  headings. Calling  this function  with this
file  as  an   argument  will  result  in  creation   of  =init.el=  and
=early-init.el= located  at =user-emacs-directory=. This is  why I'm using
tangle approach, instead of =org-babel-load-file=,  as there's no way to
provide =early-init= this way. After  first tangle, every time this file
is saved  it gets re-tangled automatically,  so there's not much  of a
difference from  loading with babel,  and only  this file needs  to be
edited.

Since I'm  trying to  follow Emacs conventions,  good Emacs  Lisp file
starts with commentary:

#+begin_src emacs-lisp
  ;;; init.el --- Emacs main configuration file -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-
  ;;;
  ;;; Commentary:
  ;;; Emacs config by Andrey Orst.
  ;;; This file was automatically generated by `org-babel-tangle'.
  ;;; Do not change this file.  Main config is located in .config/emacs/README.org
  ;;;
  ;;; Code:
#+end_src

At  this point  configurations  will be  split  in different  sections
grouped by something common to them all.

* Initial Setup
Emacs starts fast, but as amount of packages grows it gets slower. The
init time is important  because I like to close it  when I'm not using
it. I'm not  closing and opening it  for every file, or  like every 15
minutes, but still, the faster it starts - the better for me.

** =early-init.el=
:properties:
:header-args+: :tangle "./early-init.el"
:end:
These settings are going into  different init file: =earli-init.el=.  We
are going to use some speedup tricks from [[https://github.com/hlissner/doom-emacs][doom-emacs]] here.  But before
that, let's add top comment:

#+begin_src emacs-lisp
  ;;; early-init.el --- early configurations -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-
  ;;;
  ;;; Commentary:
  ;;; Emacs confi by Andrey Orst.
  ;;; This file was automatically generated by `org-babel-tangle'.
  ;;; Do not change this file.  Main config is located in .config/emacs/README.org
  ;;;
  ;;; Code:
#+end_src

*** Garbage Collection
The main problem  with Emacs startup is garbage  collection system. It
is invoked so many times on startup that it causes quite big impact on
startup time.   We're talking  /seconds/.  One can  raise limit  when to
trigger garbage collection, but this will end up in unpleasant editing
experience. So I'm  declaring these variables to  store default values
for the GC, to restore them after initialization is finished:

#+begin_src emacs-lisp
  (defvar aorst--gc-cons-threshold gc-cons-threshold)
  (defvar aorst--gc-cons-percentage gc-cons-percentage)
  (defvar aorst--file-name-handler-alist file-name-handler-alist)
#+end_src

Now we can tweak CG. We need to raise threshold to prevent it running:

#+begin_src emacs-lisp
  (setq-default gc-cons-threshold 402653184
                gc-cons-percentage 0.6
                inhibit-compacting-font-caches t
                message-log-max 16384
                file-name-handler-alist nil)
#+end_src

Then we need  a hook that restores initial  values once initialization
done:

#+begin_src emacs-lisp
  (add-hook 'after-init-hook
            (lambda ()
              (setq gc-cons-threshold aorst--gc-cons-threshold
                    gc-cons-percentage aorst--gc-cons-percentage
                    file-name-handler-alist aorst--file-name-handler-alist)))
#+end_src

*** Native Compiled Emacs Lisp
There's a  very interesting project  that I'm currently  using, called
[[http://akrl.sdf.org/gccemacs.html][gccemacs]]. It  provides a way to  compile Emacs Lisp into  native code,
thus making  Emacs much more  robust and  snappy. In order  to compile
everything that Emacs loads asynchronously we can set this variable to
=true=.

#+begin_src emacs-lisp
  (defvar comp-deferred-compilation)
  (setq comp-deferred-compilation t)
#+end_src

This way  I can compile  Emacs from source as  I usually do,  and then
continue using it as normal, and Emacs will do it's native compilation
in background for every loaded package. That's amazing!

*** User Interface
Prevent the glimpse of un-styled  Emacs by disabling these UI elements
early.

#+begin_src emacs-lisp
  (setq initial-frame-alist '((width . 170)
                              (height . 56)
                              (tool-bar-lines . 0)
                              (left-fringe . 0)
                              (right-fringe . 0)
                              (bottom-divider-width . 0)
                              (right-divider-width . 1))
        default-frame-alist initial-frame-alist)
#+end_src

Resizing frame is also expensive so we inhibit it, and latest patch to
Emacs  introduced =x-gtk-resize-child-frames=  variable  that fixes  the
issue  with  child frames  not  being  resized correctly  under  GNOME
Shell, so let's set it to =resize-mode=.

#+begin_src emacs-lisp
  (setq frame-inhibit-implied-resize t
        x-gtk-resize-child-frames 'resize-mode)
#+end_src

*** =straight.el=
Straight is an alternative way  to manage package installations. It is
a purely  functional package  manager. It  installs packages  from Git
repositories listed on ELPA and MELPA, or from Git URL. First, we have
to bootstrap it:

#+begin_src emacs-lisp
  (defvar bootstrap-version)
  (defvar straight-repository-branch)
  (setq straight-repository-branch "develop")
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

Now we can install =use-package= with it:

#+begin_src emacs-lisp
  (straight-use-package 'use-package)
  (defvar straight-use-package-by-default)
  (setq straight-use-package-by-default t)
#+end_src

*** early =package.el= settings
=package.el= initialization is expensive so we disable it at startup:

#+begin_src emacs-lisp
  (setq package-enable-at-startup nil)
#+end_src

*** =(provide 'early-init)=
This concludes the =early-init.el= file.

#+begin_src emacs-lisp
  (provide 'early-init)
  ;;; early-init.el ends here
#+end_src

*** Loading =early-init.el= in Emacs 26 and earlier
:properties:
:header-args+: :tangle "./init.el"
:end:
Before Emacs  27 there were  no such thing  as =eraly-init.el=, so  if I
will use  older Emacs  with this configuration  it will  miss settings
that are done there. This code manually loads this file in such case:

#+begin_src emacs-lisp
  (unless (featurep 'early-init)
    (load (expand-file-name "early-init" user-emacs-directory)))
#+end_src

** COMMENT =package.el=
To obtain plugins we need =package.el= package. Although this is builtin
and convenient,  it's also slow  and messy.  Instead of  using =package=
directly we will use =use-package= to manage package configurations.

Melpa is a  package repository, that I use to  get packages. Since all
packages that  I need can be  obtained from there, I  did not bothered
with different methods of installation.

#+begin_src emacs-lisp
  (defvar package-archives)
  (setq package-archives
        '(("gnu" . "https://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")))
#+end_src

There's recent bug with downloading from elpa. This line fixes it:

#+begin_src emacs-lisp
  (when (version= emacs-version "26.2")
    (defvar gnutls-algorithm-priority)
    (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3"))
  ;; (package-initialize)
#+end_src

Found this trick  [[https://genehack.blog/2020/04/a-bit-of-emacs-advice/][here]], but instead of using Boolean,  I've decided to
track time since last package refresh,  and use customize to store it.
This variable is  going to hold either =nil= or  date-time string.

#+begin_src emacs-lisp
  (defcustom package-last-refresh-date nil
    "Date and time when package lists have been refreshed.

  This variable is then used to check whether
  `package-refresh-contents' call is needed before calling
  `package-install'. Value of this varialbe is updated when
  `package-refresh-contents' is called.

  See `package-refresh-hour-threshold' for amount of time needed to
  trigger refresh."
    :type 'string
    :group 'package)
#+end_src

And we  need a variable that  holds amount of hours  that will trigger
the refresh:

#+begin_src emacs-lisp
  (defcustom package-automatic-refresh-threshold 24
    "Amount of hours since last `package-refresh-contents' call
  needed to trigger automatic refresh before calling `package-install'."
    :type 'number
    :group 'package)
#+end_src

This  advice first  checks if  our date-time  string exists,  and then
checks if there's more than 24 hours passed since last check.

#+begin_src emacs-lisp
  (define-advice package-install (:before (&rest _))
    (let ((seconds-per-hour 3600))
      (when (or (null package-last-refresh-date)
                (> (/ (float-time
                       (time-subtract (date-to-time (format-time-string "%Y-%m-%dT%H:%M"))
                                      (date-to-time package-last-refresh-date)))
                      seconds-per-hour)
                   package-automatic-refresh-threshold))
        (package-refresh-contents))))
#+end_src

Now all packages that  use =package-install= should periodically refresh
package  contents. In  order to  update time  we also  have to  advice
=package-refresh-contents=:

#+begin_src emacs-lisp
  (define-advice package-refresh-contents (:after (&rest _))
    (customize-save-variable 'package-last-refresh-date (format-time-string "%Y-%m-%dT%H:%M")))
#+end_src

This way if  I refresh packages from package menu,  or manually or via
that =package-install= advice  =package-last-refresh-date= will be updated
and persistently saved via =custom=.

Last thing we need to do is to install =use-package=:

#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (defvar use-package-always-ensure)
  (setq use-package-always-ensure t)
#+end_src

** =use-package=
I use =use-package= to install, load  and configure my packages.  I find
this way very consistent and easy to understand, and maintain. At this
point =use-package= should be already  installed by either =package.el= or
=straight.el=, depending on what is enabled above. Only thing left to do
is to require =use-package= itself:

#+begin_src emacs-lisp
  (require 'use-package)
#+end_src

* Defaults
Emacs is  old. I  understand that  back then  it could  be appropriate
decisions,  but as  of today  they are  completely obliterated  by the
passage of time.

** User Credentials
Let's set full name and e-mail address in case I would send e-mail from
Emacs, or some modes can use those automatically, like Org Mode:

#+begin_src emacs-lisp
  (use-package startup
    :no-require t
    :straight nil
    :custom
    (user-mail-address "andreyorst@gmail.com")
    (user-full-name "Andrey Orst"))
#+end_src

** Bell
I'm not  trying to  insult on anyone,  but usage of  the bell  is just
insane. It's  not 1980's, computers  have their own speakers  and rich
displays, why would anyone want  to use builtin speaker?  Why everyone
should know when I'm mistaken? Disable bell.

#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
#+end_src

** Backups
I don't  know who decided  that having backups  all over the  place is
good idea, but I don't think alike.

#+begin_src emacs-lisp
  (use-package files
    :straight nil
    :custom
    (backup-by-copying t)
    (create-lockfiles nil)
    (backup-directory-alist '(("." . "~/.cache/emacs-backups")))
    (auto-save-file-name-transforms '((".*" "~/.cache/emacs-backups/" t))))
#+end_src

** Yes or No
For some  reason in some  situations Emacs asks  for typing =yes=  or =no=
explicitly, instead of accepting =y= or =n=. This can be fixed with this.

#+begin_src emacs-lisp
  (use-package subr
    :no-require t
    :straight nil
    :init
    (fset 'yes-or-no-p 'y-or-n-p))
#+end_src

** Echo Keystrokes
Emacs displays pressed  key after some time but it's  too fast for me,
because I use Emacs on the phone  too, and the keyboard is a bit small
for lightning fast typing.

#+begin_src emacs-lisp
  (add-hook 'after-init-hook (lambda () (setq echo-keystrokes 5)))
#+end_src

** Mouse and Scrolling
I don't want menus on shift clicks:

#+begin_src emacs-lisp
  (global-unset-key (kbd "S-<down-mouse-1>"))
  (global-unset-key (kbd "<mouse-3>"))
  (global-set-key [mouse-3] menu-bar-edit-menu)
  (global-unset-key (kbd "S-<mouse-3>"))
#+end_src

I also  don't like how Emacs  handles scrolling, that it  speeds it up
and automatically scrolls horizontally. Also, changing =mouse-highlight=
to  =nil= value  disables highlighting  of hovered  item when  the point
moves which is kinda convenient when working with =flymake=.

#+begin_src emacs-lisp
  (setq-default mouse-wheel-progressive-speed nil
                auto-window-vscroll nil
                mouse-highlight nil)
#+end_src

** Tab character
Another default  setting that I kinda  dislike. Not that I'm  a fan of
spaces over tabs,  but I find that  there are much more  modes or even
languages that expect spaces, and not  tabs.  For instance, I need tab
characters only when I work with C code and Makefile rules.

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

** Custom File and Disabled Commands
I  don't like  custom,  and  especially would  like  to  stop it  from
interfering to  my configuration  files, so lets  move it  to separate
file.

#+begin_src emacs-lisp
  (use-package cus-edit
    :straight nil
    :custom
    (custom-file (expand-file-name "custom.el" user-emacs-directory))
    :init
    (load custom-file :noerror))
#+end_src

I also don't like that Emacs  has disabled commands, and enabling them
modifies  my =init.el=  that I  don't  modify myself.   Let's put  those
commands to =disabled.el= file instead:

#+begin_src emacs-lisp
  (defvar disabled-commands (expand-file-name "disabled.el" user-emacs-directory)
    "File to store disabled commands, that were enabled permamently.")
  (defadvice en/disable-command (around put-in-custom-file activate)
    "Put declarations in disabled.el."
    (let ((user-init-file disabled-commands))
      ad-do-it))
  (load disabled-commands :noerror)
#+end_src

** History
Another feature I  want is history between sessions. I'm  not sure why
it isn't default.

#+begin_src emacs-lisp
  (savehist-mode 1)
#+end_src

** Keyboard Layout
I use two keyboard layouts: =qwerty=  and =йцукен=, therefore I need a way
to switch between those without loosing  ability to use such chords as
=C-x=  which will  become  a =C-ч=  if  I select  Cyrillic  layout in  the
OS. Luckily for  me, Emacs provides a method to  switch layouts within
Emacs with =C-\=, so all common shortcuts will still work fine.

#+begin_src emacs-lisp
  (use-package mule-cmds
    :no-require t
    :straight nil
    :custom
    (default-input-method 'russian-computer))
#+end_src

I'm  not   using  =russian-jcuken=   here  because  it   represents  the
"typewriter" layout with number-line inverted,  so to access numbers I
need to use Shift key. =russian-computer= doesn't have this problem.

** UTF8
Let's use =UTF8= if we can:

#+begin_src emacs-lisp
  (prefer-coding-system 'utf-8)
  (when (display-graphic-p)
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src

** Default Major Mode
I would  like =*scratch*= buffer  to use  =fundamental= mode, so  it loads
faster.  Since  it's no  longer Emacs  Lisp interaction  buffer, let's
also remove initial message:

#+begin_src emacs-lisp
  (use-package startup
    :no-require t
    :straight nil
    :custom
    (initial-major-mode 'fundamental-mode)
    (initial-scratch-message ""))
#+end_src

** Selection
It is conveinient to delete selection by typing:

#+begin_src emacs-lisp
  (use-package delsel
    :straight nil
    :init
    (delete-selection-mode t))
#+end_src

** Default Bindings and More
Configurations to built in =simple.el= module.

By default Emacs uses =kill-region= command on =C-w= shortcut. I find thisq
counterintuitiveq. GNU Readline uses =C-w=  to kill word backwards. Otherq
software  uses  this  shortcut  to kill  window.   I  prefer  Readline
approach.   Also I've  missed  =o=  and =O=  commands  from Kakoune.  With
=newline-below=  and  =newline-above= it  is  now  possible to  have  same
shortcuts in Emacs.

Emacs has nice  function, =zap-up-to-char= but for some  reason it's not
bound to any key. I find it more usable than =zap-to-char= so let's swap
those here.

Also,  I don't  want  my  files to  contain  trailing whitespaces,  so
=before-save-hook= hook will get rid of those automatically for me.

#+begin_src emacs-lisp
  (use-package simple
    :straight nil
    :bind (("C-w" . aorst/kill-region-or-word)
           ("C-o" . aorst/newline-below)
           ("C-S-o" . aorst/newline-above)
           ("M-z" . zap-up-to-char)
           ("M-S-z" . zap-to-char))
    :hook (before-save . delete-trailing-whitespace)
    :init
    (defun aorst/kill-region-or-word (arg)
      (interactive "*p")
      (if (and transient-mark-mode
               mark-active)
          (kill-region (region-beginning) (region-end))
        (backward-kill-word arg)))
    (defun aorst/newline-below ()
      (interactive)
      (end-of-line)
      (newline-and-indent))
    (defun aorst/newline-above ()
      (interactive)
      (back-to-indentation)
      (newline-and-indent)
      (forward-line -1)
      (indent-according-to-mode)))
#+end_src

* Functions
This  section  describes  functions  I have  defined  for  use  inside
configurations  of various  packages, that  are general  enough to  be
placed in particular package  configuration. For example when function
is shared  between configurations  and some  configuration may  not be
loaded.

I prefix my  functions with =aorst/= and variables with  =aorst--= to make
those easier  to browse  with =ivy=  and to  explicitly define  that the
function is not a part of a particular package.

** =real-buffer-p=
This function decides if buffer  should be considered a "real" buffer,
e.g. a file-visiting buffer, or specific buffers that should behave as
file-visiting while not visiting a particular file, like =*scratch*=

#+begin_src emacs-lisp
  (defun aorst/real-buffer-p (&optional buffer)
    "Determines whether BUFFER is real."
    (let ((buffer-name (buffer-name buffer)))
      (or (and (not (minibufferp))
               (buffer-file-name buffer))
          (string-equal "*scratch*" buffer-name)
          (string-match-p ".~.*~" buffer-name)
          (string-match-p "FILE=/" buffer-name)
          (string-match-p "\*edit-indirect .*\*" buffer-name)
          (string-match-p "\*Org Src .*\*" buffer-name)
          (string-match-p "*eww*" buffer-name))))
#+end_src

** =real-buffer-setup=
If only  certain buffers  could +be so  grossly incandescent+  *have damn
fringes!* With Solaire Mode Emacs becomes way more like true GUI editor
with actual elements of user interface represented by different color,
but  these fringes  drive me  crazy.  That's  why I  wrote a  function
=aorst/real-buffer-setup=, that enables fringes only in buffers that are
affected by Solaire Mode:

#+begin_src emacs-lisp
  (defun aorst/real-buffer-setup (&rest _)
    "Wrapper around `set-window-fringes' function."
    (when window-system
      (let* ((window (selected-window))
             (buffer (window-buffer window)))
        (when (aorst/real-buffer-p buffer)
          (set-window-fringes window 8 8 t)
          (when (bound-and-true-p desktop-save-mode)
            (setq desktop-save-buffer t))))))
#+end_src

** =kill-when-no-processes=
This function  kills buffer which used  to have active process  but it
was killed. Should be used via hook or advice.

#+begin_src emacs-lisp
  (defun aorst/kill-when-no-processes (&rest _)
    "Kill buffer and its window when there's no processes left."
    (when (null (get-buffer-process (current-buffer)))
      (kill-buffer (current-buffer))))
#+end_src

** =escape=
One thing  that bothered  me is  that =C-g= is  universal way  to cancel
things in Emacs, gut you have to  be in exact window to cancel action.
This  function  intelligently tries  to  cancel  regardless of  active
window:

#+begin_src emacs-lisp
  (defun aorst/escape ()
    "Quit in current context.

  When there is an active minibuffer and we are not inside it close
  it.  When we are inside the minibuffer use the regular
  `minibuffer-keyboard-quit' which quits any active region before
  exiting.  When there is no minibuffer `keyboard-quit' unless we
  are defining or executing a macro."
    (interactive)
    (cond ((active-minibuffer-window)
           (if (minibufferp)
               (minibuffer-keyboard-quit)
             (abort-recursive-edit)))
          ((bound-and-true-p iedit-mode)
           (iedit-quit))
          (t
           (unless (or defining-kbd-macro
                       executing-kbd-macro)
             (keyboard-quit))))
    (message this-command))
  (global-set-key [remap keyboard-quit] #'aorst/escape)
#+end_src

** =font-installed-p=
This function checks if font is available on the system.

#+begin_src emacs-lisp
  (defun aorst/font-installed-p (font-name)
    "Check if font with FONT-NAME is available."
    (find-font (font-spec :name font-name)))
#+end_src

** =indent-buffer=
This function  is kinda  a way  to indent a  buffer by  using language
indentation rules provided by current mode. If there's a tool that can
properly format buffer it should be used instead of this function.

#+begin_src emacs-lisp
  (defun aorst/indent-buffer ()
    "Indent whole buffer."
    (interactive)
    (save-excursion
      (save-restriction
        (indent-region (point-min) (point-max)))))

  (global-set-key (kbd "C-c C-M-f") #'aorst/indent-buffer)
#+end_src

* User Interface
Packages that affect user interface.

** Splash Screen
Emacs displays splash screen once started  with no files. I don't need
it, so let's disable it.

#+begin_src emacs-lisp
  (use-package startup
    :no-require t
    :straight nil
    :custom
    (inhibit-splash-screen t))
#+end_src

** Menus and Tooltips
I don't need  all these tooltips, menus and  scrollbars. Emacs enables
all of those by default, so let's disable them as early as possible:

#+begin_src emacs-lisp
  (tooltip-mode -1)
  ; (menu-bar-mode -1)
  (fset 'menu-bar-open nil)

  (when window-system
    (scroll-bar-mode -1)
    (tool-bar-mode -1))
#+end_src

** Cursor Type
Also let's use bar cursor when in window system, which is visible only
in active window:

#+begin_src emacs-lisp
  (when window-system
    (setq-default cursor-type 'bar
                  cursor-in-non-selected-windows nil))
#+end_src

** Font
I'm a  big fan  of [[https://github.com/source-foundry/Hack][Hack]]  font. It  has nice  support of  languages and
styles like *bold*, /italics/ for not only Latin languages. If =Hack= is not
found we try =Source Code Pro= as a fallback option.

#+begin_src emacs-lisp
  (cond ((aorst/font-installed-p "Hack")
         (set-face-attribute 'default nil :font "Hack 10"))
        ((aorst/font-installed-p "Source Code Pro")
         (set-face-attribute 'default nil :font "Source Code Pro 10")))
#+end_src

** Icons
=all-the-icons= package provides nice icons for Emacs via custom fonts.

#+begin_src emacs-lisp
  (use-package all-the-icons
    :config
    (when (and (not (aorst/font-installed-p "all-the-icons"))
               (window-system))
      (all-the-icons-install-fonts t)))
#+end_src

I don't  use this package  directly yet,  but some other  packages do,
like DOOM Modeline or Treemacs.

** Theme
I'm using *doom-themes* package to make my Emacs look modern. This theme
collection  was developed  for [[https://github.com/hlissner/doom-emacs][DOOM  Emacs]],  and I  find these  themes
actually  great on  its own.   This package  contains nice  variant of
Atom-like One theme which I like, but it is also an amazingly well put
package, which defines colors for pretty much everything in Emacs.

#+begin_src emacs-lisp
  (use-package doom-themes
    :custom
    (doom-themes-enable-bold t)
    (doom-themes-enable-italic t)
    :config
    (load-theme 'doom-one t)
    (set-face-attribute 'highlight nil
                        :foreground 'unspecified
                        :distant-foreground 'unspecified
                        :background 'unspecified))
#+end_src

** Fringe
I want fringes  to appear only in certain buffers  where I really need
them, so let's  disable it entirely on startup and  set them with some
hooks later.  But this adds another problem.  Emacs displays =$= sign at
the end of the  window if line is being truncated. Damn,  why it is so
hard  to  make  it  work  how  I want..   And  you  can't  simply  set
=standard-display-table= slot to empty space,  because it isn't ready on
Emacs init.

#+begin_src emacs-lisp
  (when window-system
    (use-package fringe
      :straight nil
      :hook ((buffer-list-update
              window-configuration-change
              change-major-mode) . aorst/real-buffer-setup)
      :init
      (fringe-mode 0)
      (or standard-display-table
          (setq standard-display-table (make-display-table)))
      (set-display-table-slot standard-display-table 0 ?\s)))
#+end_src

** Solaire Mode
This  package helps  distinguish  buffers that  have  file opened  and
buffers that  are for utilities  like file  browser. Also it  has cool
name! =\[T]/=

I really want  Solaire to treat =*scratch*= buffer as  real.  For that I
need to define my  own function that will decide if  buffer is real or
not. Now we can set up  Solaire Mode and assign =aorst/real-buffer-p= to
=solaire-mode-real-buffer-fn=.

#+begin_src emacs-lisp
  (use-package solaire-mode
    :straight (:host github
               :repo "hlissner/emacs-solaire-mode")
    :commands (solaire-global-mode
               solaire-mode-swap-bg
               turn-on-solaire-mode
               solaire-mode-in-minibuffer
               solaire-mode-reset)
    :hook (((after-revert
             change-major-mode
             org-src-mode) . turn-on-solaire-mode)
           (snippet-mode . solaire-mode))
    :custom
    (solaire-mode-real-buffer-fn #'aorst/real-buffer-p)
    :config
    (solaire-mode-swap-bg)
    (with-no-warnings
      (if (boundp 'after-focus-change-function)
          (add-function :after after-focus-change-function #'solaire-mode-reset)
        (add-hook 'focus-in-hook  #'solaire-mode-reset)))
    (defun aorst/create-image-with-background-color (args)
      "Specify background color of Org-mode inline image through modify `ARGS'."
      (let* ((file (car args))
             (type (cadr args))
             (data-p (caddr args))
             (props (cdddr args)))
        ;; get this return result style from `create-image'
        (append (list file type data-p)
                (list :background (face-attribute (or (cadr (assq 'default face-remapping-alist))
                                                      'default)
                                                  :background nil t))
                props)))
    (advice-add 'create-image :filter-args #'aorst/create-image-with-background-color)
    :init (solaire-global-mode +1))
#+end_src

** Modeline
I've tried bunch of different modelines:

- [[https://github.com/TheBB/spaceline][Spaceline]]
  Great modeline, but  I was experiencing slowdowns  in Emacs startup,
  and I like my Emacs to start fast.
- [[https://github.com/dbordak/telephone-line][Telephone Line]]
  Another good modeline, but I was lazy to configure it.
- [[https://github.com/milkypostman/powerline][Powerline]]
  This was first what I tried because I was using something similar in
  Vim. I don't remember why I dropped it.
- [[https://github.com/tarsius/moody][Moody]]
  Really lightweight  configuration for  default modeline,  which I've
  used for quite a some time.

They're all  great, but  I experienced some  troubles with  DOOM Theme
that I use, so  I've decided to try out DOOM  Modeline.  And turns out
it's great!

#+begin_src emacs-lisp
  (use-package doom-modeline
    :custom
    (doom-modeline-bar-width 3)
    (doom-modeline-major-mode-color-icon nil)
    (doom-modeline-buffer-color-icon nil)
    (doom-modeline-buffer-file-name-style 'relative-from-project)
    (doom-modeline-minor-modes t)
    (doom-modeline-height (floor (* (line-pixel-height) 1.8)))
    (find-file-visit-truename t)
    :config
    (let ((fg (face-attribute 'default :foreground))
          (bg (face-attribute 'mode-line :background))
          (fg-inactive (face-attribute 'font-lock-comment-face :foreground))
          (bg-inactive (face-attribute 'mode-line-inactive :background)))
      (dolist (face '(doom-modeline-buffer-modified
                      doom-modeline-buffer-minor-mode
                      doom-modeline-project-parent-dir
                      doom-modeline-project-dir
                      doom-modeline-project-root-dir
                      doom-modeline-highlight
                      doom-modeline-debug
                      doom-modeline-info
                      doom-modeline-warning
                      doom-modeline-urgent
                      doom-modeline-unread-number
                      doom-modeline-buffer-path
                      doom-modeline-bar
                      doom-modeline-bar-inactive
                      doom-modeline-panel
                      doom-modeline-buffer-major-mode
                      doom-modeline-buffer-file
                      doom-modeline-lsp-success
                      doom-modeline-lsp-warning
                      doom-modeline-lsp-error
                      doom-modeline-lsp-running
                      doom-modeline-persp-name
                      doom-modeline-battery-full
                      doom-modeline-battery-error
                      doom-modeline-battery-charging
                      doom-modeline-battery-critical
                      doom-modeline-battery-normal
                      doom-modeline-input-method
                      doom-modeline-input-method-alt
                      doom-modeline-repl-warning
                      doom-modeline-repl-success))
        (set-face-attribute face nil :foreground fg :weight 'normal))
      (set-face-attribute 'doom-modeline-buffer-file nil :weight 'semi-bold)
      (set-face-attribute 'doom-modeline-buffer-major-mode nil :weight 'semi-bold)
      (set-face-attribute 'doom-modeline-panel nil :background bg)
      (set-face-attribute 'doom-modeline-bar nil :background bg)
      (set-face-attribute 'doom-modeline-bar-inactive nil :background bg)
      (set-face-attribute 'mode-line-inactive nil :foreground fg-inactive :background bg-inactive))
    (doom-modeline-mode 1))
#+end_src

I  don't  find displaying  position  in  modeline really  great  idea,
because I need to move my eyes too much on big screen just to see what
line number  I'm currently  on. Also, let's  make modeline  little bit
bigger.  And remove that bevel thing.

#+begin_src emacs-lisp
  (setq-default column-number-mode t
                line-number-mode t
                size-indication-mode nil
                mode-line-position nil
                mode-line-percent-position nil
                mode-line-in-non-selected-windows nil)
  (unless (bound-and-true-p doom-modeline-mode)
    (set-face-attribute 'mode-line nil
                        :box (list :line-width 8
                                   :color (face-attribute 'mode-line :background))))
#+end_src

** Frame
Emacs uses  white titlebar, but  since I'm  using dark color  scheme I
want title bar  to be dark as  well. It is quite  difficult to achieve
this in GNOME  Shell, but I found  this code [[https://nicolas.petton.fr/blog/emacs-dark-window-decoration.html][on the internet]].  So if I
use =window-system=  I want this  function to run  during initialization
process, and when new frame is created.

#+begin_src emacs-lisp
  (when window-system
    (use-package frame
      :straight nil
      :custom
      (window-divider-default-right-width 1)
      :config
      (window-divider-mode 1)
      (set-face-attribute 'window-divider nil
                          :foreground (face-attribute
                                       'mode-line-inactive :background))))
#+end_src

** Title
Emacs uses weird method of naming a window, I'd like to see a file I'm
currently working  on in the task  bar in case my  Emacs was minimized
for some reason.

#+begin_src emacs-lisp
  (setq-default frame-title-format '("%b — Emacs"))
#+end_src

** Treemacs
To make Emacs look more like  a traditional modern text editor we need
a file explorer.  Emacs has  builtin package for this, named =speedbar=,
but It uses external frame and has  so many features that I don't know
if I really need. With this package, and its supplement packages I can
have a consistent  filetree inside my Emacs frame. Which  is good. But
there's more:  DOOM Themes support  this package as well,  which means
that Treemacs will look just as great as DOOM themed Emacs!

#+begin_src emacs-lisp
  (when window-system
    (use-package treemacs
      :commands (treemacs-follow-mode
                 treemacs-filewatch-mode
                 treemacs-fringe-indicator-mode
                 treemacs-load-theme)
      :bind (("<f7>" . treemacs)
             ("<f8>" . treemacs-select-window)
             :map treemacs-mode-map
             ([C-tab] . aorst/treemacs-expand-all-projects))
      :hook ((after-init . aorst/treemacs-after-init-setup)
             (treemacs-mode . aorst/after-treemacs-setup)
             (treemacs-switch-workspace . aorst/treemacs-expand-all-projects)
             (treemacs-switch-workspace . treemacs-set-fallback-workspace)
             (treemacs-mode . aorst/treemacs-setup-title))
      :custom
      (treemacs-width 34)
      (treemacs-is-never-other-window t)
      (treemacs-space-between-root-nodes nil)
      (treemacs-indentation 2)
      :config
      (use-package treemacs-magit)
      (treemacs-follow-mode t)
      (treemacs-filewatch-mode t)
      (treemacs-fringe-indicator-mode nil)
      (set-face-attribute 'treemacs-root-face nil
                          :foreground (face-attribute 'default :foreground)
                          :height 1.0
                          :weight 'normal)
      (defun aorst/treemacs-ignore (file _)
        (or (s-ends-with? ".elc" file)
            (s-ends-with? ".o" file)
            (s-ends-with? ".a" file)
            (string= file ".svn")))
      (add-to-list 'treemacs-ignored-file-predicates #'aorst/treemacs-ignore)
      (treemacs-create-theme "Atom"
        :config
        (progn
          (treemacs-create-icon
           :icon (format " %s\t"
                         (all-the-icons-octicon
                          "repo"
                          :v-adjust -0.1
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (root))
          (treemacs-create-icon
           :icon (format "%s\t%s\t"
                         (all-the-icons-octicon
                          "chevron-down"
                          :height 0.75
                          :v-adjust 0.1
                          :face '(:inherit font-lock-doc-face :slant normal))
                         (all-the-icons-octicon
                          "file-directory"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (dir-open))
          (treemacs-create-icon
           :icon (format "%s\t%s\t"
                         (all-the-icons-octicon
                          "chevron-right"
                          :height 0.75
                          :v-adjust 0.1
                          :face '(:inherit font-lock-doc-face :slant normal))
                         (all-the-icons-octicon
                          "file-directory"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (dir-closed))
          (treemacs-create-icon
           :icon (format "%s\t%s\t"
                         (all-the-icons-octicon
                          "chevron-down"
                          :height 0.75
                          :v-adjust 0.1
                          :face '(:inherit font-lock-doc-face :slant normal))
                         (all-the-icons-octicon
                          "package"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (tag-open))
          (treemacs-create-icon
           :icon (format "%s\t%s\t"
                         (all-the-icons-octicon
                          "chevron-right"
                          :height 0.75
                          :v-adjust 0.1
                          :face '(:inherit font-lock-doc-face :slant normal))
                         (all-the-icons-octicon
                          "package"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (tag-closed))
          (treemacs-create-icon
           :icon (format "%s\t"
                         (all-the-icons-octicon
                          "tag"
                          :height 0.9
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (tag-leaf))
          (treemacs-create-icon
           :icon (format "%s\t"
                         (all-the-icons-octicon
                          "flame"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (error))
          (treemacs-create-icon
           :icon (format "%s\t"
                         (all-the-icons-octicon
                          "stop"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (warning))
          (treemacs-create-icon
           :icon (format "%s\t"
                         (all-the-icons-octicon
                          "info"
                          :height 0.75
                          :v-adjust 0.1
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (info))
          (treemacs-create-icon
           :icon (format "  %s\t"
                         (all-the-icons-octicon
                          "file-media"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("png" "jpg" "jpeg" "gif" "ico" "tif" "tiff" "svg" "bmp"
                        "psd" "ai" "eps" "indd" "mov" "avi" "mp4" "webm" "mkv"
                        "wav" "mp3" "ogg" "midi"))
          (treemacs-create-icon
           :icon (format "  %s\t"
                         (all-the-icons-octicon
                          "file-code"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("yml" "yaml" "sh" "zsh" "fish" "c" "h" "cpp" "cxx" "hpp"
                        "tpp" "cc" "hh" "hs" "lhs" "cabal" "py" "pyc" "rs" "el"
                        "elc" "clj" "cljs" "cljc" "ts" "tsx" "vue" "css" "html"
                        "htm" "dart" "java" "kt" "scala" "sbt" "go" "js" "jsx"
                        "hy" "json" "jl" "ex" "exs" "eex" "ml" "mli" "pp" "dockerfile"
                        "vagrantfile" "j2" "jinja2" "tex" "racket" "rkt" "rktl" "rktd"
                        "scrbl" "scribble" "plt" "makefile" "elm" "xml" "xsl" "rb"
                        "scss" "lua" "lisp" "scm" "sql" "toml" "nim" "pl" "pm" "perl"
                        "vimrc" "tridactylrc" "vimperatorrc" "ideavimrc" "vrapperrc"
                        "cask" "r" "re" "rei" "bashrc" "zshrc" "inputrc" "editorconfig"
                        "gitconfig"))
          (treemacs-create-icon
           :icon (format "  %s\t"
                         (all-the-icons-octicon
                          "book"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("lrf" "lrx" "cbr" "cbz" "cb7" "cbt" "cba" "chm" "djvu"
                        "doc" "docx" "pdb" "pdb" "fb2" "xeb" "ceb" "inf" "azw"
                        "azw3" "kf8" "kfx" "lit" "prc" "mobi" "pkg" "opf" "txt"
                        "pdb" "ps" "rtf" "pdg" "xml" "tr2" "tr3" "oxps" "xps"))
          (treemacs-create-icon
           :icon (format "  %s\t" (all-the-icons-octicon
                                   "file-text"
                                   :v-adjust 0
                                   :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("md" "markdown" "rst" "log" "org" "txt"
                        "CONTRIBUTE" "LICENSE" "README" "CHANGELOG"))
          (treemacs-create-icon
           :icon (format "  %s\t" (all-the-icons-octicon
                                   "file-binary"
                                   :v-adjust 0
                                   :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("exe" "dll" "obj" "so" "o" "out"))
          (treemacs-create-icon
           :icon (format "  %s\t" (all-the-icons-octicon
                                   "file-pdf"
                                   :v-adjust 0
                                   :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("pdf"))
          (treemacs-create-icon
           :icon (format "  %s\t" (all-the-icons-octicon
                                   "file-zip"
                                   :v-adjust 0
                                   :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("zip" "7z" "tar" "gz" "rar" "tgz"))
          (treemacs-create-icon
           :icon (format "  %s\t" (all-the-icons-octicon
                                   "file-text"
                                   :v-adjust 0
                                   :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (fallback))))
      :init
      (defun aorst/treemacs-expand-all-projects (&optional _)
        "Expand all projects."
        (interactive)
        (save-excursion
          (treemacs--forget-last-highlight)
          (dolist (project (treemacs-workspace->projects (treemacs-current-workspace)))
            (-when-let (pos (treemacs-project->position project))
              (when (eq 'root-node-closed (treemacs-button-get pos :state))
                (goto-char pos)
                (treemacs--expand-root-node pos)))))
        (treemacs--maybe-recenter 'on-distance))
      (defun aorst/treemacs-variable-pitch-labels (&rest _)
        (dolist (face '(treemacs-file-face
                        treemacs-root-face
                        treemacs-tags-face
                        treemacs-directory-face
                        treemacs-directory-collapsed-face
                        treemacs-term-node-face
                        treemacs-help-title-face
                        treemacs-help-column-face
                        treemacs-git-added-face
                        treemacs-git-ignored-face
                        treemacs-git-renamed-face
                        treemacs-git-conflict-face
                        treemacs-git-modified-face
                        treemacs-git-unmodified-face
                        treemacs-git-untracked-face
                        treemacs-root-unreadable-face
                        treemacs-root-remote-face
                        treemacs-root-remote-unreadable-face
                        treemacs-root-remote-disconnected-face
                        treemacs-fringe-indicator-face
                        treemacs-on-failure-pulse-face
                        treemacs-on-success-pulse-face))
          (let ((faces (face-attribute face :inherit nil)))
            (set-face-attribute
             face nil :inherit
             `(variable-pitch ,@(delq 'unspecified (if (listp faces) faces (list faces))))))))
      (defun aorst/treemacs-after-init-setup ()
        "Set treemacs theme, open treemacs, and expand all projects."
        (treemacs-load-theme "Atom")
        (setq treemacs-collapse-dirs 0)
        (treemacs)
        (aorst/treemacs-expand-all-projects)
        (windmove-right))
      (defun aorst/after-treemacs-setup ()
        "Set treemacs buffer common settings."
        (setq tab-width 1
              mode-line-format nil
              line-spacing 5)
        (setq-local scroll-step 1)
        (setq-local scroll-conservatively 10000)
        (set-window-fringes nil 0 0 t)
        (aorst/treemacs-variable-pitch-labels))
      (defun aorst/treemacs-setup-fringes ()
        "Set treemacs buffer fringes."
        (set-window-fringes nil 0 0 t)
        (aorst/treemacs-variable-pitch-labels))
      (advice-add #'treemacs-select-window :after #'aorst/treemacs-setup-fringes)
      (defun aorst/treemacs-setup-title ()
        (let ((bg (face-attribute 'default :background))
              (fg (face-attribute 'default :foreground)))
          (face-remap-add-relative 'header-line
                                   :background bg :foreground fg
                                   :box `(:line-width ,(/ (line-pixel-height) 2) :color ,bg)))
        (setq header-line-format
              '((:eval
                 (let* ((text (treemacs-workspace->name (treemacs-current-workspace)))
                        (extra-align (+ (/ (length text) 2) 1))
                        (width (- (/ (window-width) 2) extra-align)))
                   (concat (make-string width ?\s) text))))))))
#+end_src

** Minions
This  package  implements   a  menu  that  lists   all  enabled  minor
modes. Emacs mode  line can become pretty long, so  this can be handy,
and perhaps I don't need to use =:diminish= everywhere anymore.

#+begin_src emacs-lisp
  (use-package minions
    :commands minions-mode
    :init (minions-mode 1))
#+end_src

** Uniquify
This package makes files with  identical names more distinguishable by
adding directory name in the buffer name.

#+begin_src emacs-lisp
  (use-package uniquify
    :straight nil
    :custom (uniquify-buffer-name-style 'forward))
#+end_src

** Tabline
Starting  with Emacs  27  native tab  support is  present.  I want  to
customize tab appearance to match my theme.

#+begin_src emacs-lisp
  (when (and window-system
             (not (version< emacs-version "27")))
    (use-package tab-line
      :straight nil
      :hook (after-init . global-tab-line-mode)
      :config
      (defun tab-line-close-tab (&optional e)
        "Close the selected tab.

  If tab is presented in another window, close the tab by using
  `bury-buffer` function.  If tab is unique to all existing
  windows, kill the buffer with `kill-buffer` function.  Lastly, if
  no tabs left in the window, it is deleted with `delete-window`
  function."
        (interactive "e")
        (let* ((posnp (event-start e))
               (window (posn-window posnp))
               (buffer (get-pos-property 1 'tab (car (posn-string posnp)))))
          (with-selected-window window
            (let ((tab-list (tab-line-tabs-window-buffers))
                  (buffer-list (flatten-list
                                (seq-reduce (lambda (list window)
                                              (select-window window t)
                                              (cons (tab-line-tabs-window-buffers) list))
                                            (window-list) nil))))
              (select-window window)
              (if (> (seq-count (lambda (b) (eq b buffer)) buffer-list) 1)
                  (progn
                    (if (eq buffer (current-buffer))
                        (bury-buffer)
                      (set-window-prev-buffers window (assq-delete-all buffer (window-prev-buffers)))
                      (set-window-next-buffers window (delq buffer (window-next-buffers))))
                    (unless (cdr tab-list)
                      (ignore-errors (delete-window window))))
                (and (kill-buffer buffer)
                     (unless (cdr tab-list)
                       (ignore-errors (delete-window window)))))))))

      (defcustom tab-line-tab-min-width 10
        "Minimum width of a tab in characters."
        :type 'integer
        :group 'tab-line)

      (defcustom tab-line-tab-max-width 30
        "Maximum width of a tab in characters."
        :type 'integer
        :group 'tab-line)

      (defun aorst/tab-line-name-buffer (buffer &rest _buffers)
        "Create name for tab with padding and truncation.

  If buffer name is shorter than `tab-line-tab-max-width' it gets
  centered with spaces, otherwise it is truncated, to preserve
  equal width for all tabs.  This function also tries to fit as
  many tabs in window as possible, so if there are no room for tabs
  with maximum width, it calculates new width for each tab and
  truncates text if needed.  Minimal width can be set with
  `tab-line-tab-min-width' variable."
        (with-current-buffer buffer
          (let* ((window-width (window-width (get-buffer-window)))
                 (close-button-size (if tab-line-close-button-show
                                        (length (substring-no-properties tab-line-close-button))
                                      0))
                 (tab-amount (length (tab-line-tabs-window-buffers)))
                 (window-max-tab-width (/ window-width tab-amount))
                 (tab-width (- (cond ((>= window-max-tab-width tab-line-tab-max-width)
                                      tab-line-tab-max-width)
                                     ((< window-max-tab-width tab-line-tab-min-width)
                                      tab-line-tab-min-width)
                                     (t window-max-tab-width))
                               close-button-size))
                 (buffer-name (string-trim (buffer-name)))
                 (name-width (length buffer-name)))
            (if (>= name-width (- tab-width 3))
                (concat  " " (truncate-string-to-width buffer-name (- tab-width 3)) "… ")
              (let* ((padding (make-string (/ (- tab-width name-width) 2) ?\s))
                     (buffer-name (concat padding buffer-name))
                     (name-width (length buffer-name)))
                (concat buffer-name (make-string (- tab-width name-width) ?\s)))))))

      (setq tab-line-close-button-show t
            tab-line-new-button-show nil
            tab-line-separator ""
            tab-line-tab-name-function #'aorst/tab-line-name-buffer
            tab-line-right-button (propertize (if (char-displayable-p ?▶) " ▶ " " > ")
                                              'keymap tab-line-right-map
                                              'mouse-face 'tab-line-highlight
                                              'help-echo "Click to scroll right")
            tab-line-left-button (propertize (if (char-displayable-p ?◀) " ◀ " " < ")
                                             'keymap tab-line-left-map
                                             'mouse-face 'tab-line-highlight
                                             'help-echo "Click to scroll left")
            tab-line-close-button (propertize (if (char-displayable-p ?×) "× " "x ")
                                              'keymap tab-line-tab-close-map
                                              'mouse-face 'tab-line-close-highlight
                                              'help-echo "Click to close tab"))

      (let ((bg (if (facep 'solaire-default-face)
                    (face-attribute 'solaire-default-face :background)
                  (face-attribute 'default :background)))
            (fg (face-attribute 'default :foreground))
            (base (face-attribute 'mode-line :background))
            (box-width (/ (line-pixel-height) 2)))
        (when (and (color-defined-p bg)
                   (color-defined-p fg)
                   (color-defined-p base)
                   (numberp box-width))
          (set-face-attribute 'tab-line nil
                              :background base
                              :foreground fg
                              :height 1.0
                              :inherit nil
                              :box (list :line-width -1 :color base))
          (set-face-attribute 'tab-line-tab nil
                              :foreground fg
                              :background bg
                              :weight 'normal
                              :inherit nil
                              :box (list :line-width box-width :color bg))
          (set-face-attribute 'tab-line-tab-inactive nil
                              :foreground fg
                              :background base
                              :weight 'normal
                              :inherit nil
                              :box (list :line-width box-width :color base))
          (set-face-attribute 'tab-line-tab-current nil
                              :foreground fg
                              :background bg
                              :weight 'normal
                              :inherit nil
                              :box (list :line-width box-width :color bg))))
      (setq tab-line-exclude-modes '())
      (dolist (mode '(ediff-mode
                      process-menu-mode
                      term-mode
                      vterm-mode))
        (add-to-list 'tab-line-exclude-modes mode))

      (defun aorst/tab-line-drop-caches ()
        "Drops `tab-line' cache in every window."
        (dolist (window (window-list))
          (set-window-parameter window 'tab-line-cache nil)))

      (add-hook 'window-configuration-change-hook #'aorst/tab-line-drop-caches)))
#+end_src

** Line Numbers
=display-line-numbers= provides  line numbers  on the  left side  of the
window, which  doesn't lag.  I don't  like that  it changes  width, so
let's make it grow only, and calculate maximum width on file open:

#+begin_src emacs-lisp
  (use-package display-line-numbers
    :straight nil
    :custom
    (display-line-numbers-grow-only t)
    (display-line-numbers-width-start t))
#+end_src

* Languages
This section contains various  language specific settings and external
packages that provide language support.

** Org
Org  Mode is  a great  mode for  taking notes,  managing to-do  lists,
writing books, literate programming, and  many other things. I primary
use it for taking notes on different programming languages, and manage
my Emacs configuration with it.

#+begin_src emacs-lisp
  (use-package org
    :straight (:type built-in)
    :defines default-justification
    :hook ((org-mode . flyspell-mode)
           (org-mode . auto-fill-mode)
           (after-save . aorst/org-tangle-on-config-save)
           (org-babel-after-execute . aorst/org-update-inline-images)
           (org-mode . aorst/org-init-setup)
           (ediff-prepare-buffer . outline-show-all)
           ((org-capture-mode org-src-mode) . aorst/discard-history))
    :bind (("C-c a" . org-agenda)
           :map org-mode-map
           ("C-c l" . org-store-link))
    :custom
    (org-startup-with-inline-images nil)
    (org-tags-column -100)
    (org-startup-folded 'content)
    (org-hide-emphasis-markers t)
    (org-adapt-indentation nil)
    (org-hide-leading-stars t)
    (org-highlight-latex-and-related '(latex))
    (revert-without-query '(".*\.pdf"))
    (org-preview-latex-default-process 'dvisvgm)
    (org-src-fontify-natively t)
    (org-preview-latex-image-directory ".ltximg/")
    (org-latex-listings 'minted)
    (org-latex-pdf-process '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")
                            ("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")
                            ("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
    (org-confirm-babel-evaluate nil)
    (org-imenu-depth 8)
    (org-log-done t)
    (org-agenda-files '("~/Tasks"))
    :config
    (when (executable-find "gsettings")
      (let ((font-scaling (string-to-number
                           (shell-command-to-string "gsettings get org.gnome.desktop.interface text-scaling-factor"))))
        (setq org-format-latex-options
              (plist-put org-format-latex-options :scale font-scaling))))
    (use-package ox-latex
      :straight nil)
    (use-package ox-hugo
      :after ox)
    (when (not (version<= org-version "9.1.9"))
      (use-package org-tempo
        :straight nil))
    (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-+]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
    (defun aorst/org-tangle-on-config-save ()
      "Tangle source code blocks when configuration file is saved."
      (when (string= buffer-file-name (file-truename (concat user-emacs-directory "README.org")))
        (org-babel-tangle)))
    (defun aorst/org-update-inline-images ()
      "Update inline images in Org-mode."
      (interactive)
      (when org-inline-image-overlays
        (org-redisplay-inline-images)))
    (defun aorst/org-init-setup ()
      "Set buffer local values."
      (setq default-justification 'full))
    (defun aorst/discard-history ()
      "Discard undo history of org src and capture blocks."
      (setq buffer-undo-list nil)
      (set-buffer-modified-p nil))
    (defvar minted-cache-dir
      (file-name-as-directory
       (expand-file-name ".minted/\\jobname"
                         temporary-file-directory)))
    (add-to-list 'org-latex-packages-alist
                 `(,(concat "cachedir=" minted-cache-dir)
                   "minted" nil))
    (add-to-list 'org-latex-logfiles-extensions "tex")
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((gnuplot . t)
       (scheme . t)))
    (add-to-list 'org-latex-classes
                 '("article"
                   "\\documentclass{article}"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
    (defun aorst/org-update-latex-preview-background-color (&rest _)
      (setq-default
       org-format-latex-options
       (plist-put org-format-latex-options
                  :background
                  (face-attribute (or (cadr (assq 'default face-remapping-alist))
                                      'default)
                                  :background nil t))))
    (add-hook 'solaire-mode-hook #'aorst/org-update-latex-preview-background-color))
#+end_src

** Prog Mode
This isn't really a configuration of  Prog Mode itself, but some hooks
that change how  programming related modes behave. One  feature that I
think is really important, especially  when working with lisp code, is
ability  to see  matching bracket  when cursor  stands near  the other
bracket. So I enable it for every programming language.

#+begin_src emacs-lisp
  (use-package prog-mode
    :straight nil
    :hook ((prog-mode . show-paren-mode)
           (prog-mode . display-line-numbers-mode)))
#+end_src

** CC
These settings are for editing C source files.

#+begin_src emacs-lisp
  (use-package cc-mode
    :straight nil
    :config (defun aorst/cc-mode-setup ()
              (c-set-offset 'case-label '+)
              (setq c-basic-offset 4
                    c-default-style "linux"
                    indent-tabs-mode t
                    comment-start "//"
                    comment-end ""
                    tab-width 4))
    :hook ((c-mode-common . aorst/cc-mode-setup)
           (c-mode-common . electric-pair-local-mode)))
#+end_src

** Markdown
Sometimes I need to edit Markdown documents, so this package is handy.
For markdown  mode I would like  to have automatic spell  checking and
filling. Basically  the same setup  as for Org  Mode.  And one  of the
features of Org mode is ability to edit source code blocks in separate
window  with  appropriate  major  mode.  This  can  be  achieved  with
=edit-indirect= package.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :config
    (defvar markdown-command "multimarkdown")
    (defun aorst/markdown-setup ()
      "Set buffer local variables."
      (setq fill-column 80
            default-justification 'left))
    :hook ((markdown-mode . flyspell-mode)
           (markdown-mode . auto-fill-mode)
           (markdown-mode . aorst/markdown-setup)))
#+end_src

** Rust
I'd like to  have Rust syntax highlighting and  some basic facilities,
since I'm  planning to write my  exercises in org mode.   Since I make
notes in Org-mode, and  I started to use it for Rust  too, I need some
settings for Rust mode.

#+begin_src emacs-lisp
  (use-package rust-mode
    :commands (rust-format-buffer)
    :hook (rust-mode . electric-pair-local-mode)
    :bind (:map rust-mode-map
           ("C-c C-M-f" . rust-format-buffer)))
#+end_src

This also means  that I could use something  to automatically complete
Rust  language facilities.   Rust ecosystem  provides two  options for
that:  [[https://github.com/racer-rust/emacs-racer][Racer]], and  [[https://github.com/rust-lang/rls][RLS]].   I'm planning  to use  Racer  when RLS  isn't
possible to use, like in Org Mode.

#+begin_src emacs-lisp
  (use-package racer
    :if (executable-find "racer")
    :hook (racer-mode . eldoc-mode)
    :init (defun org-babel-edit-prep:rust (&optional _babel-info)
            "Run racer mode for Org Babel."
            (racer-mode 1)))
#+end_src

There's also a package for [[https://github.com/kwrooijen/cargo.el][Cargo]] integration:

#+begin_src emacs-lisp
  (use-package cargo
    :if (executable-find "cargo")
    :hook ((rust-mode toml-mode) . cargo-minor-mode))
#+end_src

** TOML
=toml-mode= helps  with highlighting of  TOML files, which Rust  uses to
configure project.

#+begin_src emacs-lisp
  (use-package toml-mode
    :bind (:map toml-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)))
#+end_src

** Geiser
Since I mostly use Emacs for studying LISP, and I'm reading SICP which
uses Scheme as main LISP flavor for explanations and exercises, I need
a tool  to run Scheme,  and Geiser seems  like the most  viable option
here, since it also provides completion for it.

#+begin_src emacs-lisp
  (use-package geiser
    :hook (scheme-mode . geiser-mode)
    :custom
    (geiser-active-implementations '(guile))
    (geiser-default-implementation 'guile))
#+end_src

** Racket
Racket is nice LISP/Scheme language that I might to get into.

#+begin_src emacs-lisp
  (use-package racket-mode
    :hook (racket-repl-mode . electric-pair-local-mode)
    :bind (:map racket-mode-map
           ("C-c C-d" . racket-run-with-debugging)
           ("C-c C-M-f" . aorst/indent-buffer)
           (")" . self-insert-command)
           ("]" . self-insert-command)
           ("}" . self-insert-command))
    :config
    (set-face-attribute 'racket-debug-break-face nil :background (face-attribute 'error :foreground) :foreground (face-attribute 'default :background))
    (set-face-attribute 'racket-debug-result-face nil :foreground (face-attribute 'font-lock-comment-face :foreground) :box nil)
    (set-face-attribute 'racket-debug-locals-face nil :foreground (face-attribute 'font-lock-comment-face :foreground) :box nil)
    (set-face-attribute 'racket-selfeval-face nil :foreground (face-attribute 'default :foreground)))
#+end_src

** Cmake
A mode for editing cmake files.

#+begin_src emacs-lisp
  (use-package cmake-mode
    :bind (:map cmake-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)))
#+end_src

** Emacs Lisp
I write some  Emacs Lisp and experience is already  quite good, I just
want to enable some helper modes here.

#+begin_src emacs-lisp
  (use-package elisp-mode
    :straight nil
    :commands (aorst/emacs-lisp-indent-function)
    :hook ((emacs-lisp-mode . eldoc-mode)
           (emacs-lisp-mode . (lambda ()
                                (setq-local lisp-indent-function
                                            #'aorst/emacs-lisp-indent-function))))
    :bind (:map emacs-lisp-mode-map
           ("C-c C-M-f" . aorst/indent-buffer))
    :config
    (defun aorst/emacs-lisp-indent-function (indent-point state)
      "A replacement for `lisp-indent-function'.
  Indents plists more sensibly. Adapted from DOOM Emacs:
  https://github.com/hlissner/doom-emacs/commit/a634e2c8125ed692bb76b2105625fe902b637998"
      (let ((normal-indent (current-column))
            (orig-point (point)))
        (goto-char (1+ (elt state 1)))
        (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
        (cond ((and (elt state 2)
                    (or (not (looking-at-p "\\sw\\|\\s_"))
                        (eq (char-after) ?:)))
               (unless (> (save-excursion (forward-line 1) (point))
                          calculate-lisp-indent-last-sexp)
                 (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t))
               (backward-prefix-chars)
               (current-column))
              ((and (save-excursion
                      (goto-char indent-point)
                      (skip-syntax-forward " ")
                      (not (eq (char-after) ?:)))
                    (save-excursion
                      (goto-char orig-point)
                      (eq (char-after) ?:)))
               (save-excursion
                 (goto-char (+ 2 (elt state 1)))
                 (current-column)))
              ((let* ((function (buffer-substring (point) (progn (forward-sexp 1) (point))))
                      (method (or (function-get (intern-soft function) 'lisp-indent-function)
                                  (get (intern-soft function) 'lisp-indent-hook))))
                 (cond ((or (eq method 'defun)
                            (and (null method)
                                 (> (length function) 3)
                                 (string-match-p "\\`def" function)))
                        (lisp-indent-defform state indent-point))
                       ((integerp method)
                        (lisp-indent-specform method state
                                              indent-point normal-indent))
                       (method
                        (funcall method indent-point state)))))))))
#+end_src

** Yaml
Support for =.yaml= files.

#+begin_src emacs-lisp
  (use-package yaml-mode)
#+end_src

** Shell Script
Some configurations for shell script modes.

#+begin_src emacs-lisp
  (use-package sh-script
    :straight nil
    :bind (:map sh-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)))
#+end_src

** Perl
Perl related configurations.

#+begin_src emacs-lisp
  (use-package perl-mode
    :straight nil
    :hook ((perl-mode . electric-pair-local-mode)
           (perl-mode . flycheck-mode))
    :bind (:map perl-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)))
#+end_src

** Clojure
Clojure is a Lisp dialect for Java Virtual Machine. It is one of
the few  modern and refreshing  languages, that bring  both innovation
and reliability.

#+begin_src emacs-lisp
  (use-package clojure-mode
    :hook (((clojure-mode clojurescript-mode) . flycheck-mode))
    :bind (:map clojure-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)
           ("C-x C-M-;" . aorst/clojure-toggle-ignore-form))
    :config
    (defun aorst/clojure-toggle-ignore-form ()
      "Add or remove #_ literal before the current form."
      (interactive)
      (save-excursion
        (condition-case nil
            (progn
              (backward-up-list)
              (if (looking-back "#_")
                  (delete-char -2)
                (insert "#_")))
          (scan-error
           (progn
             (forward-sexp)
             (if (looking-back "#_")
                 (delete-char -2)
               (backward-sexp)
               (insert "#_"))))))))
#+end_src

*** CIDER
Emacs  also has  a great  package called  Cider, which  is an  IDE for
Clojure and ClojureScript.

#+begin_src emacs-lisp
  (use-package cider
    :hook (((cider-repl-mode cider-mode) . cider-company-enable-fuzzy-completion)
           ((cider-repl-mode cider-mode) . eldoc-mode)
           (cider-disconnected . (lambda () (ignore-errors (delete-window)))))
    :custom-face
    (cider-error-highlight-face ((t (:inherit flymake-error))))
    (cider-fringe-face ((t (:inherit flymake-warning))))
    (cider-fragile-button-face ((t (:box (:line-width -1
                                          :color nil
                                          :style nil)
                                    :inherit (font-lock-warning-face)))))
    (cider-deprecated-face ((t (:inherit smerge-upper))))
    (cider-instrumented-face ((t (:box (:line-width -1
                                        :color "#ff6c6b"
                                        :style nil)))))
    (cider-fringe-good-face ((t (:inherit cider-repl-stdout-face))))
    :custom
    (cider-repl-display-help-banner nil)
    (cider-repl-tab-command #'company-complete-common-or-cycle)
    (nrepl-hide-special-buffers t))
#+end_src

*** flycheck-clj-kondo
[[https://github.com/borkdude/clj-kondo][clj-kondo]]   is   a   static    analyzer   for   Clojure(Script),   and
=flycheck-clj-kondo= is  a backend  for =flycheck=,  that makes  these two
things understand each other.

#+begin_src emacs-lisp
  (use-package flycheck-clj-kondo
    :if (executable-find "clj-kondo")
    :straight (:host github
               :repo "borkdude/flycheck-clj-kondo"))
#+end_src

*** clj-refactor
=clj-refactor= provides  refactoring support  for Clojure  projects.  It
complements the refactoring functionality from =clojure-mode= and CIDER.

#+begin_src emacs-lisp
  (use-package clj-refactor
    :hook ((clojure-mode . clj-refactor-mode)
           (clojure-mode . yas-minor-mode))
    :config (cljr-add-keybindings-with-prefix "C-c C-r"))
#+end_src

** Fennel
Fennel  is  a programming  language  a  lisp  dialect, that  is  being
compiled  to Lua,  which means  that it  can run  anywhere, where  Lua
can.   It   supports  compile-time   macro   system,   and  full   Lua
compatibility.

#+begin_src emacs-lisp
  (use-package fennel-mode
    :bind (:map fennel-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)))
#+end_src

** Lua
I'm not  into Lua language  myself, but in  order to view  what [[*Fennel][Fennel]]
produces I need support for Lua.

#+begin_src emacs-lisp
  (use-package lua-mode
    :bind (:map lua-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)))
#+end_src

** CSS

#+begin_src emacs-lisp
  (use-package css-mode
    :straight nil
    :custom
    (css-indent-offset 2))
#+end_src

* Tools
Additional  packages  that  change  how Emacs  works,  providing  more
comfortable user experience.

** Help
I want help  window to be selected automatically, so  I could close it
with =q= after I've finished reading.

#+begin_src emacs-lisp
  (use-package help
    :straight nil
    :custom (help-window-select t))
#+end_src

** Doc View
Default resolution is too low:

#+begin_src emacs-lisp
  (use-package doc-view
    :straight nil
    :custom (doc-view-resolution 192))
#+end_src

** vterm
This  package provides  a bridge  to =libvterm=  to display  terminal as
Emacs buffer. It works much better than =ansi-term=, though may be buggy
and requires compilation.

#+begin_src emacs-lisp
  (setq use-package-hook-name-suffix "-functions")
  (when (bound-and-true-p module-file-suffix)
    (use-package vterm
      :bind (("C-`" . aorst/vterm-toggle)
             ("C-t" . aorst/vterm-focus))
      :hook (vterm-exit . aorst/kill-vterm)
      :config
      (defun aorst/vterm-toggle (&optional arg)
        "Toggle `vterm' window on and off with the same command."
        (interactive "P")
        (let* ((directory (if default-directory
                              default-directory
                            (expand-file-name "~/")))
               (bufname "*vterm*")
               (window (get-buffer-window bufname)))
          (if window
              (ignore-errors (delete-window window))
            (if (window-dedicated-p)
                (let ((windows (seq-drop-while #'window-dedicated-p (window-list))))
                  (when (not (null windows))
                    (select-window (car windows)))))
            (let* ((win-side (if (symbolp arg)
                                 (cons (split-window-below) 'bot)
                               (cons (split-window-right) 'right)))
                   (window (car win-side))
                   (side (cdr win-side)))
              (select-window window)
              (cond ((get-buffer bufname)
                     (switch-to-buffer bufname))
                    (t (let ((default-directory directory))
                         (vterm bufname))))
              (when (bound-and-true-p global-tab-line-mode)
                (setq tab-line-format nil))
              (set-window-dedicated-p window t)
              (set-window-parameter window 'no-delete-other-windows t)
              (set-window-parameter window 'window-side side)
              (set-window-parameter window 'no-other-window t)))))
      (defun aorst/vterm-focus (&optional arg)
        "Focus `vterm' or open one if there's none."
        (interactive "P")
        (let ((window (get-buffer-window "*vterm*")))
          (if window
              (select-window window)
            (aorst/vterm-toggle arg))))
      (defun aorst/kill-vterm (buf &optional event)
        "Kill the `*vterm*' buffer after shell exits."
        (when buf (kill-buffer buf)))))
  (setq use-package-hook-name-suffix "-hook")
#+end_src

** EditorConfig
=.editorconfig=  file  provides a  nice  way  to synchronize  my  editor
configurations between projects and different editors.

#+begin_src emacs-lisp
  (use-package editorconfig
    :commands editorconfig-mode
    :config (editorconfig-mode 1))
#+end_src

** Flycheck
Some languages have better support with =flycheck=.

#+begin_src emacs-lisp
  (use-package flycheck
    :bind (:map flycheck-mode-map
           ("C-c ! C-h" . hydrant/flycheck/body))
    :custom
    (flycheck-indication-mode 'right-fringe)
    :config
    (when (fboundp 'define-fringe-bitmap)
      (define-fringe-bitmap 'flycheck-double-exclamation-mark
        (vector #b00000000
                #b00000000
                #b00000000
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b00000000
                #b01100110
                #b01100110
                #b00000000
                #b00000000
                #b00000000))
      (define-fringe-bitmap 'flycheck-exclamation-mark
        (vector #b00000000
                #b00000000
                #b00000000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00000000
                #b00011000
                #b00011000
                #b00000000
                #b00000000
                #b00000000))
      (define-fringe-bitmap 'flycheck-question-mark
        (vector #b00000000
                #b00000000
                #b00000000
                #b00111100
                #b01111110
                #b01100110
                #b01100110
                #b00000110
                #b00001100
                #b00011000
                #b00011000
                #b00000000
                #b00011000
                #b00011000
                #b00000000
                #b00000000
                #b00000000))
      (flycheck-define-error-level 'error
        :severity 100
        :compilation-level 2
        :overlay-category 'flycheck-error-overlay
        :fringe-bitmap 'flycheck-double-exclamation-mark
        :fringe-face 'flycheck-fringe-error
        :error-list-face 'flycheck-error-list-error)
      (flycheck-define-error-level 'warning
        :severity 100
        :compilation-level 1
        :overlay-category 'flycheck-warning-overlay
        :fringe-bitmap 'flycheck-exclamation-mark
        :fringe-face 'flycheck-fringe-warning
        :error-list-face 'flycheck-error-list-warning)
      (flycheck-define-error-level 'info
        :severity 100
        :compilation-level 0
        :overlay-category 'flycheck-info-overlay
        :fringe-bitmap 'flycheck-question-mark
        :fringe-face 'flycheck-fringe-info
        :error-list-face 'flycheck-error-list-info))
    (when (fboundp 'defhydra)
      (defhydra hydrant/flycheck (:color blue :hint nil)
        "
   ^Flycheck^          ^Errors^            ^Checker^
  ─^────────^──────────^──────^────────────^───────^─────
   _q_: quit           _<_: previous       _?_: describe
   _M_: manual         _>_: next           _d_: disable
   _v_: verify setup   _f_: check          _m_: mode
   ^ ^                 _l_: list           _s_: select"
        ("q" ignore :exit t)
        ("M" flycheck-manual)
        ("v" flycheck-verify-setup)
        ("<" flycheck-previous-error :color pink)
        (">" flycheck-next-error :color pink)
        ("f" flycheck-buffer)
        ("l" flycheck-list-errors)
        ("?" flycheck-describe-checker)
        ("d" flycheck-disable-checker)
        ("m" flycheck-mode)
        ("s" flycheck-select-checker))))
#+end_src

=flycheck-cask= is a package for using [[https://github.com/cask/cask][Cask]] files with Flycheck.

#+begin_src emacs-lisp
  (use-package flycheck-cask
    :hook (flycheck-mode . flycheck-cask-setup))
#+end_src

** Hydra
This is something like ability to create mappings that sit in it's own
mode, like different user modes in Kakoune. It allows me to press some
shortcut  and be  locked  in a  mode-like state  where  keys that  are
related  to  this  prefix  shortcut  are behaving  in  terms  of  this
shortcut.

This  package will  be used  in many  other package  configurations to
provide sane keybindings.

#+begin_src emacs-lisp
  (use-package hydra)
#+end_src

** Parinfer
Parinfer implementation  written in Rust  language.  Not as  strict as
Emacs Lisp  implementation, because it  does not force  any formatting
rules, and theoretically should be faster, but in very early stages of
development.

#+begin_src emacs-lisp
  (when (bound-and-true-p module-file-suffix)
    (use-package parinfer-rust-mode
      :straight (:host github
                 :repo "justinbarclay/parinfer-rust-mode"
                 :branch "amalgamate-undo")
      :hook ((clojure-mode
              emacs-lisp-mode
              common-lisp-mode
              scheme-mode
              lisp-mode
              racket-mode
              fennel-mode) . parinfer-rust-mode)
      :config
      (add-to-list 'parinfer-rust-treat-command-as '(aorst/indent-buffer . "indent"))
      :init
      (setq parinfer-rust-auto-download t)))
#+end_src

However, there's a problem. Parinfer Rust requires module support, and
not every Emacs  was compiled with =--with-modules=  flag. To workaround
this I'll be using Emacs Lisp  version of Parinfer when module support
is not available:

#+begin_src emacs-lisp
  (unless (bound-and-true-p module-file-suffix)
    (use-package paredit)
    (use-package selected)
    (use-package parinfer-smart
      :straight (:host github
                 :repo "DogLooksGood/parinfer-mode"
                 :branch "smart")
      :hook ((clojure-mode
              emacs-lisp-mode
              common-lisp-mode
              scheme-mode
              lisp-mode
              racket-mode
              fennel-mode) . parinfer-mode)))
#+end_src

** Flx
Flex matching for Emacs.

#+begin_src emacs-lisp
  (use-package flx)
#+end_src

** Ivy and Counsel
Ivy  is a  narrowing  framework  like Helm,  but  much  lighter in  my
experience.  It  integrates with  Counsel that handles  minibuffer, so
let's install it too.

#+begin_src emacs-lisp
  (use-package ivy
    :commands ivy-mode
    :hook ((minibuffer-setup-hook . aorst/minibuffer-defer-garbage-collection)
           (minibuffer-exit-hook . aorst/minibuffer-restore-garbage-collection))
    :bind (("C-x b" . ivy-switch-buffer)
           ("C-x C-b" . ivy-switch-buffer))
    :custom
    (ivy-re-builders-alist '((t . ivy--regex-fuzzy)))
    (ivy-count-format "")
    (ivy-ignore-buffers '("\\` " "\\`\\*"))
    (ivy-display-style nil)
    (ivy-minibuffer-faces nil)
    (ivy-minibuffer-faces '(default default default default))
    (ivy-use-virtual-buffers t)
    (enable-recursive-minibuffers t)
    :init
    (defun aorst/minibuffer-defer-garbage-collection ()
      "Defer garbage collection for minibuffer"
      (setq gc-cons-threshold most-positive-fixnum))
    (defun aorst/minibuffer-restore-garbage-collection ()
      "Resotre garbage collection settings."
      (run-at-time
       1 nil (lambda () (setq gc-cons-threshold aorst--gc-cons-threshold))))
    (ivy-mode 1))
#+end_src

I'm using  [[https://github.com/sharkdp/fd][fd]] as a  great replacement for GNU  Find. It's fast  and it
takes  =.gitignore= into  account.  Counsel  has nice  =counsel-file-fump=
command that uses =find-program= variable, so  we can advice it in order
for it to use  =fd=. The same thing is for =rg=,  but counsel actually has
it's own variable for it, so we do no need to runtime-patch it.

#+begin_src emacs-lisp
  (use-package counsel
    :commands (counsel-M-x
               counsel-find-file
               counsel-file-jump
               counsel-recentf
               counsel-rg
               counsel-describe-function
               counsel-describe-variable
               counsel-find-library)
    :bind (("M-x" . counsel-M-x)
           ("C-x C-f" . counsel-find-file)
           ("C-x f" . counsel-file-jump)
           ("C-x C-r" . counsel-recentf)
           ("C-x d" . counsel-dired)
           ("C-h f" . counsel-describe-function)
           ("C-h C-f" . counsel-describe-face)
           ("C-h v" . counsel-describe-variable)
           ("C-h l" . counsel-find-library))
    :config
    (when (executable-find "fd")
      (define-advice counsel-file-jump (:around (foo &optional initial-input initial-directory))
        (let ((find-program "fd")
              (counsel-file-jump-args (split-string "-L --type f --hidden")))
          (funcall foo))))
    (when (executable-find "rg")
      (setq counsel-rg-base-command
            "rg -S --no-heading --hidden --line-number --color never %s .")))
#+end_src

** Ivy Posframe
This package displays =ivy= in separate frame on top of Emacs.

#+begin_src emacs-lisp
  (use-package ivy-posframe
    :after ivy
    :custom
    (ivy-posframe-display-functions-alist '((t . aorst/posframe-position)))
    (ivy-posframe-height-alist '((t . 16)))
    (ivy-posframe-parameters '((internal-border-width . 6)))
    (ivy-posframe-width 78)
    :config
    (defvar aorst--ivy-posframe-top-padding 42
      "additional padding between top of the frame and posframe.")
    (defun aorst/posframe-position (str)
      (ivy-posframe--display str #'aorst/posframe-under-tabs-center))
    (defun aorst/posframe-under-tabs-center (info)
      "Function that sets center position for ivy posframe."
      (cons (/ (- (plist-get info :parent-frame-width)
                  (plist-get info :posframe-width))
               2)
            0))
    (set-face-attribute 'ivy-posframe nil :background (face-attribute 'mode-line :background))
    (ivy-posframe-mode +1))
#+end_src

** Company
Complete anything framework. Nothing much to say. Does it's job.

#+begin_src emacs-lisp
  (use-package company
    :bind (:map company-active-map
           ("TAB" . company-complete-common-or-cycle)
           ("<tab>" . company-complete-common-or-cycle)
           ("<S-Tab>" . company-select-previous)
           ("<backtab>" . company-select-previous)
           ("C-n" . company-select-next)
           ("C-p" . company-select-previous))
    :hook (after-init . global-company-mode)
    :custom
    (company-require-match 'never)
    (company-minimum-prefix-length 2)
    (company-tooltip-align-annotations t)
    (company-frontends '(company-pseudo-tooltip-unless-just-one-frontend
                         company-preview-frontend
                         company-echo-metadata-frontend))
    (company-backends '(company-capf company-files))
    (company-tooltip-minimum-width 30)
    (company-tooltip-maximum-width 60))
#+end_src

This package also optionally requires these extra dependencies:

- =company-posframe= - provides posframe frontend for company.

#+begin_src emacs-lisp
  (use-package company-posframe
    :after company
    :custom
    (company-posframe-quickhelp-show-header nil)
    (company-posframe-show-indicator nil)
    (company-posframe-show-metadata nil)
    (company-posframe-quickhelp-show-params
     (list :poshandler #'company-posframe-quickhelp-right-poshandler
           :internal-border-width 1
           :timeout 60
           :internal-border-color (face-attribute 'mode-line-inactive :background)
           :no-properties nil
           :poshandler nil))
    :config
    (company-posframe-mode))
#+end_src

** Undo Tree
This is more familiar  undo mode. It adds =C-/= mapping  to undo and =C-?=
mapping to  redo. I also  map convenient  =C-z= and =C-S-z=  maps, because
sometimes when  someone else sits at  my PC (for pair  programming for
example), and forgets that this is Emacs, and hits =C-z= thus minimizing
the frame, and being frustrated.

#+begin_src emacs-lisp
  (use-package undo-tree
    :commands global-undo-tree-mode
    :bind (("C-z" . undo-tree-undo)
           ("C-S-z" . undo-tree-redo))
    :init (global-undo-tree-mode 1))
#+end_src

** Yasnippet
Another very handy package, that helps insert templates of code. Now I
really need to write some snippets to use. Also has nice collection as
a separate package

#+begin_src emacs-lisp
  (use-package yasnippet
    :commands yas-reload-all
    :hook ((rust-mode
            c-mode-common
            racket-mode) . yas-minor-mode)
    :config
    (add-to-list 'yas-key-syntaxes 'yas-shortest-key-until-whitespace)
    (yas-reload-all))
#+end_src

** Magit
Emacs interface to Git.  I've heard that it has many nice features, so
I want to try it out.

#+begin_src emacs-lisp
  (use-package magit
    :hook ((git-commit-mode . flyspell-mode))
    :bind (("<f12>" . magit-status))
    :custom (magit-ediff-dwim-show-on-hunks t))
#+end_src

** Ediff
This is a built  in mode for diffing files in  Emacs. Previously I was
using  [[https://github.com/justbur/emacs-vdiff][Vdiff]] but  I have  to say  that I've  used it  so rarely,  so I
decided to avoid extra dependency and configure Ediff.

#+begin_src emacs-lisp
  (use-package ediff
    :straight nil
    :hook ((ediff-before-setup . aorst/store-pre-ediff-winconfig)
           (ediff-quit . aorst/restore-pre-ediff-winconfig)
           (ediff-keymap-setup . aorst/ediff-setup-keys))
    :config
    (advice-add 'ediff-window-display-p :override #'ignore)
    :custom
    (ediff-split-window-function 'split-window-horizontally)
    :init
    (defvar aorst--ediff-last-windows nil
      "Stores window configuration before `ediff' was invoked.")
    (defun aorst/store-pre-ediff-winconfig ()
      (setq aorst--ediff-last-windows (current-window-configuration)))
    (defun aorst/restore-pre-ediff-winconfig ()
      (set-window-configuration aorst--ediff-last-windows))
    (defun aorst/ediff-copy-both-to-C ()
      (interactive)
      (ediff-copy-diff ediff-current-difference nil 'C nil
                       (concat
                        (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
                        (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))
    (defun aorst/ediff-setup-keys ()
      (define-key ediff-mode-map "d" #'aorst/ediff-copy-both-to-C)))
#+end_src

** Multiple Cursors
This  package provides  multiple cursors  functionality to  Emacs.  It
isn't much like Kakoune's multiple selections, but anything will do. I
guess I'll figure out best mappings over time.

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :commands (mc/cycle-backward
               mc/cycle-forward)
    :bind (("S-<mouse-1>" . mc/add-cursor-on-click)
           ("C-c m" . hydrant/mc/body)
           :map mc/keymap
           ("<return>" . nil))
    :requires hydra
    :config
    (when (fboundp 'defhydra)
      (defhydra hydrant/mc (:hint nil :color pink)
        "
   ^Select^                 ^Discard^                      ^Edit^               ^Navigate^
  ─^──────^─────────────────^───────^──────────────────────^────^───────────────^────────^─────────
   _M-s_: split lines       _M-SPC_:  discard current      _&_: align           _(_: cycle backward
   _s_:   select regexp     _b_:      discard blank lines  _#_: insert numbers  _)_: cycle forward
   _n_:   select next       _d_:      remove duplicated    ^ ^                  ^ ^
   _p_:   select previous   _q_ or _g_: exit hydrant       ^ ^                  ^ ^
   _C_:   select next line  _G_:      exit mc mode"
        ("M-s" mc/edit-ends-of-lines)
        ("s" mc/mark-all-in-region-regexp)
        ("n" mc/mark-next-like-this-word)
        ("p" mc/mark-previous-like-this-word)
        ("&" mc/vertical-align-with-space)
        ("(" mc/cycle-backward)
        (")" mc/cycle-forward)
        ("M-SPC" mc/remove-current-cursor)
        ("b" mc/remove-cursors-on-blank-lines)
        ("d" mc/remove-duplicated-cursors)
        ("C" mc/mark-next-lines)
        ("#" mc/insert-numbers)
        ("q" mc/remove-duplicated-cursors :exit t)
        ("g" mc/remove-duplicated-cursors :exit t)
        ("G" mc/keyboard-quit :exit t))))

  (use-package mc-extras)
#+end_src

** Expand Region
Expand  or   reduce  region  selection  semantically.   Supports  most
languages that I work with inside Emacs.

#+begin_src emacs-lisp
  (use-package expand-region
    :bind (("C-c e" . hydrant/er/body))
    :requires hydra
    :config
    (when (fboundp 'defhydra)
      (defhydra hydrant/er (:color pink :hint nil)
        "
   ^Expand/Discard^                ^Mark^
  ─^──────────────^────────────────^────^─────────────────
   _e_ or _+_: expand region         _(_:      inside pairs
   _r_ or _-_: reduce region         _)_:      around pairs
   _g_:      exit hydrant          _q_ or _'_: inside quotes
   _G_:      discard region, exit  _Q_ or _\"_: around quotes
   ^ ^    ^ ^                        _p_:      paragraph"
        ("e" er/expand-region)
        ("+" er/expand-region)
        ("r" er/contract-region)
        ("-" er/contract-region)
        ("p" er/mark-paragraph)
        ("(" er/mark-inside-pairs)
        (")" er/mark-outside-pairs)
        ("q" er/mark-inside-quotes)
        ("'" er/mark-inside-quotes)
        ("Q" er/mark-outside-quotes)
        ("\"" er/mark-outside-quotes)
        ("g" ignore :exit t)
        ("G" #'(lambda () (interactive) (deactivate-mark)) :exit t))))
#+end_src

** Iedit Mode
Another package  for multiple editing  purposes, that is  kinda faster
than multiple cursors,  but can edit only fixed width  regions of text
and  has less  abilities regarding  to commands.  Still pretty  usable
though, as multiple cursor some times looses cursors for some reason.

#+begin_src emacs-lisp
  (use-package iedit
    :bind (("M-n" . aorst/iedit-current-or-expand)
           ("C-c i" . aorst/iedit-hydrant))
    :custom
    (iedit-toggle-key-default nil)
    :init
    (defun aorst/iedit-to-mc-hydrant ()
      "Calls `iedit-to-mc-mode' and opens hydra for multiple cursors."
      (interactive)
      (iedit-switch-to-mc-mode)
      (hydrant/mc/body))
    (defun aorst/iedit-current-or-expand (&optional arg)
      "Select only currnent occurrence with `iedit-mode'.  Expand to
    next occurrence if `iedit-mode' is already active."
      (interactive "P")
      (if (bound-and-true-p iedit-mode)
          (if (symbolp arg)
              (iedit-expand-down-to-occurrence)
            (iedit-expand-up-to-occurrence))
        (iedit-mode 1)))
    (when (fboundp 'defhydra)
      (defhydra hydrant/iedit (:hint nil :color pink)
        "
   ^Select^                  ^Discard^                   ^Edit^               ^Navigate^
  ─^──────^──────────────────^───────^───────────────────^────^───────────────^────────^─────────────
   _n_: next occurrence      _M-SPC_:  toggle selection  _u_: uppercase       _(_: previous selection
   _p_: previous occurrence  _q_ or _g_: exit hydrant      _d_: downcase        _)_: next selection
   ^ ^                       _G_:      exit iedit-mode   _#_: insert numbers
   ^ ^                       _m_:      switch to mc"
        ("n" iedit-expand-down-to-occurrence)
        ("m" aorst/iedit-to-mc-hydrant :exit t)
        ("p" iedit-expand-up-to-occurrence)
        ("u" iedit-upcase-occurrences)
        ("d" iedit-downcase-occurrences)
        ("#" iedit-number-occurrences)
        ("(" iedit-prev-occurrence)
        (")" iedit-next-occurrence)
        ("M-SPC" iedit-toggle-selection)
        ("q" ignore :exit t)
        ("g" ignore :exit t)
        ("G" #'(lambda () (interactive) (iedit-mode -1)) :exit t))
      (defun aorst/iedit-hydrant ()
        "toggle iedit mode for item under point, and open `hydrant/iedit'."
        (interactive)
        (ignore-errors
          (iedit-mode 1)
          (hydrant/iedit/body)))))
#+end_src

** LSP Mode
Another LSP client for Emacs.

#+begin_src emacs-lisp
  (use-package lsp-mode
    :hook ((rust-mode c-mode c++-mode) . lsp)
    :custom
    (lsp-enable-links nil)
    (lsp-keymap-prefix "C-c l")
    (lsp-rust-clippy-preference "on")
    (lsp-prefer-capf t)
    (lsp-enable-symbol-highlighting nil)
    (lsp-rust-server 'rust-analyzer)
    (lsp-session-file (expand-file-name "lsp-session" user-emacs-directory)))
#+end_src

#+begin_src emacs-lisp
  (use-package lsp-ui
    :after lsp-mode
    :commands lsp-ui-mode
    :bind (:map lsp-ui-mode-map
           ("M-." . lsp-ui-peek-find-definitions)
           ("M-/" . lsp-ui-peek-find-references))
    :custom
    (lsp-ui-doc-border (face-attribute 'mode-line-inactive :background))
    (lsp-ui-sideline-enable nil)
    (lsp-ui-imenu-enable nil)
    (lsp-ui-doc-delay 1 "higher than eldoc delay")
    :config
    (when (fboundp 'aorst/escape)
      (define-advice lsp-ui-doc--make-request (:around (foo))
        (unless (eq this-command 'aorst/escape)
          (funcall foo))))
    (lsp-ui-mode))
#+end_src

** Project
I  do  not  want  to  use projectile,  since  Emacs  already  features
=project.el= and many  packages use it.  Although I've  needed to create
my own  function that searches for  correct project root. So  first we
need a list  of project root markers, that will  hold file names which
we will look up recursively. we need a function that will test current
directory for  several conditions,  like does it  have any  of project
markers, is it root directory, and  if everything fails, it will go up
one directory and repeat.

#+begin_src emacs-lisp
  (use-package project
    :straight nil
    :bind (("C-c p f" . project-find-file)
           ("C-c p r" . project-find-regexp))
    :config
    (defvar project-root-markers '("Cargo.toml" "compile_commands.json" "compile_flags.txt")
      "Files or directories that indicate the root of a project.")
    (defun aorst/project-find-root (path)
      "Recursive search in PATH for root markers."
      (let* ((this-dir (file-name-as-directory (file-truename path)))
             (parent-dir (expand-file-name (concat this-dir "../")))
             (system-root-dir (expand-file-name "/")))
        (cond
         ((aorst/project-root-p this-dir) (cons 'transient this-dir))
         ((equal system-root-dir this-dir) nil)
         (t (aorst/project-find-root parent-dir)))))
    (defun aorst/project-root-p (path)
      "Check if current PATH has any of project root markers."
      (let ((results (mapcar (lambda (marker)
                               (file-exists-p (concat path marker)))
                             project-root-markers)))
        (eval `(or ,@ results))))
    (add-to-list 'project-find-functions #'aorst/project-find-root))
#+end_src

** Clang Format
A package to format C code with Clang Format.

#+begin_src emacs-lisp
  (use-package clang-format
    :after cc-mode
    :bind (:map c-mode-base-map
           ("C-c C-M-f" . clang-format-buffer)))
#+end_src

** Server
I'm using  =server-start= command not because  I do not want  to load my
Emacs every time, but because I  want to have single instance of Emacs
running at a time, so all files that I open from GUI will be opened in
existing Emacs. If no Emacs exist, it should start one, start a server
and open a file.

#+begin_src emacs-lisp
  (use-package server
    :straight nil
    :config
    (unless (server-running-p)
      (server-start)))
#+end_src

To fully achieve this behavior one needs a =.desktop= file to exist that
will decide which kind of Emacs to call: =emacs= or =emacsclient=:

#+begin_src conf-xdefaults :tangle ~/.local/share/applications/emacs.desktop :mkdirp yes :results silent
  [Desktop Entry]
  Name=Emacs
  GenericName=Text Editor
  Comment=Edit text
  MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
  Exec=sh -c "[ $# -gt 0 ] && emacsclient -a emacs -n \"\$@\" || command emacs" dummy %F
  Icon=emacs
  Type=Application
  Terminal=false
  Categories=Development;TextEditor;Utility;
  StartupWMClass=Emacs
#+end_src

This code above automatically creates user local =emacs.desktop= file in
=~/.local/share/applications= that will:

- call =emacs= if no arguments provided, or
- call =emacsclient  -a emacs= with  arguments. =emacsclient= will  try to
  connect to  a server,  and if  there's none, it  will fire  up =emacs=
  which will create server, and opening new files will be done in this
  instance of =emacs=.

** COMMENT Eldoc Box
This nice  package displays eldoc in  child frame that can  hover near
the cursor. It is really good for modes that support eldoc and removes
distraction  that happen  every  time when  your  buffer size  changes
because eldoc message appeared at the bottom. This package is affected
by [[https://gitlab.gnome.org/GNOME/mutter/issues/840][this bug]] in Gnome Shell.

#+begin_src emacs-lisp
  (use-package eldoc-box
    :hook ((eldoc-mode . aorst/eldoc-box-enable)
           (eldoc-box-buffer . aorst/eldoc-box-buffer-setup))
    :custom
    (x-wait-for-event-timeout 0)
    (eldoc-idle-delay 0.5)
    (eldoc-box-max-pixel-width 640)
    (eldoc-box-max-pixel-height 480)
    :config
    (set-face-attribute 'eldoc-box-border nil :background (face-attribute 'mode-line-inactive :background))
    :init
    (defun aorst/eldoc-box-enable ()
      "Helper function that enables `eldoc-box-hover-at-point-mode' for real buffers only."
      (interactive)
      (when (aorst/real-buffer-p)
        (eldoc-box-hover-at-point-mode)))
    (defun aorst/eldoc-box-buffer-setup ()
      (unless word-wrap (toggle-word-wrap))))
#+end_src

** Hideshow
This built  in mode provides code  folding. I use =transient=  to create
little interactive menu for easy interaction.

#+begin_src emacs-lisp
  (use-package hideshow
    :straight nil
    :after transient
    :hook (prog-mode . hs-minor-mode)
    :bind (:map prog-mode-map
           ("<f6>" . aorst/hideshow-menu))
    :config
    (define-transient-command aorst/hideshow-menu ()
      "Hideshow commands."
      [:description
       "Hide"
       ("ha" "all" hs-hide-all)
       ("hb" "block" hs-hide-block)]
      [:description
       "Show"
       ("sa" "all" hs-show-all)
       ("sb" "block" hs-show-block)]
      (interactive)
      (when (bound-and-true-p hs-minor-mode)
        (transient-setup 'aorst/hideshow-menu nil nil))))
#+end_src

** Desktop
This is  really nice feature  that allows me  to save my  workspace on
disk and  do not restore  all buffers and  windows every time  I start
Emacs. It adds some time to the startup though.

#+begin_src emacs-lisp
  (when window-system
    (use-package desktop
      :straight nil
      :hook ((after-init . aorst/desktop-restore)
             (desktop-after-read . aorst/desktop-remove))
      :custom
      (desktop-path `(,user-emacs-directory))
      (desktop-dirname user-emacs-directory)
      (desktop-base-file-name "desktop")
      (desktop-base-lock-name "desktop.lock")
      (desktop-save t)
      (desktop-load-locked-desktop t)
      :init
      (defun aorst/desktop-remove ()
        "Remove current desktop, but save `desktop-dirname'."
        (let ((desktop desktop-dirname))
          (desktop-remove)
          (setq desktop-dirname desktop)))
      (defun aorst/saved-desktop-p ()
        "Check if desktop exists."
        (file-exists-p (concat desktop-dirname "/" desktop-base-file-name)))
      (defun aorst/desktop-restore ()
        "Restore a saved emacs session."
        (interactive)
        (desktop-save-mode t)
        (if (aorst/saved-desktop-p)
            (desktop-read)
          (message "No desktop found.")))))
#+end_src

I wonder if  it could store unsaved buffers so  all my changes persist
through sessions.

** COMMENT God Mode
God mode is more  like a mode in a sense of a  mode from modal editor,
such as Vim, or Kakoune. It  makes all shortcuts you press be prefixed
by =Ctrl= key by default. Not sure if I'm going to use it much, though.

#+begin_src emacs-lisp
  (use-package god-mode
    :hook ((god-mode-enabled
            god-mode-disabled) . aorst/god-mode-change-cursor-shape)
    :bind (("<escape>" . god-local-mode)
           :map god-local-mode-map
           ("i" . god-local-mode)
           ("<backspace>" . ignore)
           ("<escape>" . ignore)
           ("<return>" . ignore)
           ("j" . ignore)
           ("m" . ignore))
    :config
    (advice-add 'aorst/newline-below :after #'(lambda () (god-local-mode -1)))
    (advice-add 'aorst/newline-above :after #'(lambda () (god-local-mode -1)))
    (dolist (mode '(treemacs-mode
                    vterm-mode
                    cider-repl-mode
                    racket-repl-mode
                    geiser-repl-mode))
      (add-to-list 'god-exempt-major-modes mode))
    :init
    (defun aorst/god-mode-change-cursor-shape ()
      (when window-system
        (setq cursor-type (if god-local-mode 'box 'bar))))
    (god-mode))
#+end_src

This package provides more comfortable usage for =isearch= in God mode:

#+begin_src emacs-lisp
  (use-package god-mode-isearch
    :straight nil
    :bind (:map isearch-mode-map
           ("<escape>" . god-mode-isearch-activate)
           :map god-mode-isearch-map
           ("<escape>" . god-mode-isearch-disable)))
#+end_src

** Edit Indirect
This  package  makes it  possible  to  edit  Markdown code  blocks  in
separate buffers.

#+begin_src emacs-lisp
  (use-package edit-indirect
    :hook ((edit-indirect-after-creation . aorst/real-buffer-setup)
           (edit-indirect-after-creation . aorst/edit-indirect-header-line-setup))
    :bind (:map edit-indirect-mode-map
           ("C-c C-c" . edit-indirect-commit)
           ("C-c C-k" . edit-indirect-abort)
           ("C-c '" . nil))
    :init
    (defun aorst/edit-indirect-header-line-setup ()
      (setq-local
       header-line-format
       (substitute-command-keys
        "\\<edit-indirect-mode-map>Edit, then exit with `\\[edit-indirect-commit]' or abort with `\\[edit-indirect-abort]'"))))
#+end_src

** Separedit
This package  provides a way to  edit comments in sources  as separate
buffers with another major mode, like Markdown.

#+begin_src emacs-lisp
  (use-package separedit
    :hook (separedit-buffer-creation . aorst/separedit-header-line-setup)
    :bind (:map prog-mode-map
           ("C-c '" . separedit)
           :map edit-indirect-mode-map
           ("C-c '" . separedit))
    :custom
    (separedit-default-mode 'markdown-mode)
    :init
    (defun aorst/separedit-header-line-setup ()
      (setq-local
       header-line-format
       (substitute-command-keys
        "Edit, then exit with `\\[separedit-commit]' or abort with `\\[edit-indirect-abort]'"))))
#+end_src

** Recent files
Settings to =recentf= mode.

#+begin_src emacs-lisp
  (use-package recentf
    :straight nil
    :config
    (add-to-list 'recentf-exclude "\\.gpg\\"))
#+end_src

* Postscript
This Emacs Configuration features  various cool E-Lisp hacks somewhere
that I've  found over the  Internet, and I  try to keep  references to
original places, so reader could refer to those, because I alter these
pieces of code for my personal needs and thus it may not be compatible
with  other people  tastes,  and  because I  want  to credit  original
author.

If you  find any issue with  my config feel  free to [[https://github.com/andreyorst/dotfiles/issues/new][file an  issue]] or
contact me via email: [[mailto:andreyorst@gmail.com][andreyorst@gmail.com]].

And as a final step of a proper init file:

#+begin_src emacs-lisp
  (provide 'init)
  ;;; init.el ends here
#+end_src

Thanks for reading!
