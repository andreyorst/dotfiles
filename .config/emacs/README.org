#+title: Emacs configuration with Org Mode
#+author: Andrey Listopadov
#+email: andreyorst@gmail.com
#+setupfile: ./.org-defaults.org
#+startup: noinlineimages
#+property: header-args :results silent

* About this document
This is a GNU Emacs configuration file, written as an Org document.
It is meant to be placed in the =user-emacs-directory=, and compiled with =org-babel-tangle=.
As a result =init.el= and =early-init.el= files are created, located in the same directory as this file, as well as some other files across the system.
You can review such files by searching for =:tangle= in this file.
Both =init.el= and =early-init.el= are default to the read only mode, thus only this file needs to be edited, and is automatically tangled on save.

* =early-init.el=
:properties:
:header-args+: :tangle "./early-init.el"
:end:
Emacs 27 introduced new initialization file called =earli-init.el=, which is executed before =init.el=.
It is meant to configure package initialization and early graphical interface tweaks, before actually drawing a window.

#+begin_src emacs-lisp
  ;;; early-init.el --- Early initialization -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-

  ;; Author: Andrey Listopadov
  ;; Keywords: literate programming, Emacs configuration
  ;; Homepage: https://gitlab.com/andreyorst/dotfiles/-/tree/master/.config/emacs

  ;;; Commentary:
  ;; Emacs config.
  ;; This file was automatically generated by `org-babel-tangle'.
  ;; Do not change this file.  Main config is located in README.org at `user-emacs-directory'

  ;;; Code:
#+end_src

** Emacs 28 Obsolete workaround
Emacs 28 made some changes to obsolete-related functions, making the third argument =when= mandatory.
This broke a lot of packages, so for now, a workaround is to define an =around= advice:

#+begin_src emacs-lisp
  (defun aorst/wrap-obsolete (orig-fn &rest args)
    "Append extra argument to ARGS before calling ORIG-FN function."
    (if (cddr args)
        (apply orig-fn args)
      (apply orig-fn `(,@args "0"))))

  (advice-add 'make-obsolete :around #'aorst/wrap-obsolete)
  (advice-add 'make-obsolete-variable :around #'aorst/wrap-obsolete)
  (advice-add 'define-obsolete-variable-alias :around #'aorst/wrap-obsolete)
  (advice-add 'define-obsolete-function-alias :around #'aorst/wrap-obsolete)
#+end_src

** Garbage Collection and Performance
One of the main reasons why Emacs startup time is big is that the garbage collection is invoked a lot, causing the increase of the startup time.
This can be migrated by setting high GC threshold and restoring it back in =after-init-hook=.

#+begin_src emacs-lisp
  (defvar aorst--gc-cons-threshold gc-cons-threshold)
  (defvar aorst--gc-cons-percentage gc-cons-percentage)
  (defvar aorst--file-name-handler-alist file-name-handler-alist)

  (setq-default gc-cons-threshold 402653184
                gc-cons-percentage 0.6
                file-name-handler-alist nil)

  (defun aorst/restore-defaults-after-init ()
    "Restore default values after initialization."
    (setq-default gc-cons-threshold aorst--gc-cons-threshold
                  gc-cons-percentage aorst--gc-cons-percentage
                  file-name-handler-alist aorst--file-name-handler-alist))

  (add-hook 'after-init-hook #'aorst/restore-defaults-after-init)

  (setq read-process-output-max (* 1024 1024 4) ; 4mb
        inhibit-compacting-font-caches t
        message-log-max 16384)
#+end_src

** Native Compiled Emacs Lisp
Emacs 28 can compile Emacs Lisp to native code.
These settings enable background asynchronous compilation, and dynamic reloading of compiled modules.

#+begin_src emacs-lisp
  (when (featurep 'native-compile)
    (setq native-comp-deferred-compilation t)
    (setq native-comp-async-report-warnings-errors nil))
#+end_src

** User Interface
This code sets default size of the frame and prevents the glimpse of unstyled Emacs by disabling some UI elements early.
Resizing frame is also expensive, and setting =x-gtk-resize-child-frames= variable to =resize-mode= is a workaround for the [[https://gitlab.gnome.org/GNOME/mutter/-/issues/840][issue]] with child frames not being resized correctly under Mutter.

#+begin_src emacs-lisp
  (setq-default initial-frame-alist '((width . 170)
                                      (height . 56)
                                      (tool-bar-lines . 0)
                                      (bottom-divider-width . 0)
                                      (right-divider-width . 1))
                default-frame-alist initial-frame-alist
                frame-inhibit-implied-resize t
                x-gtk-resize-child-frames 'resize-mode
                fringe-indicator-alist (assq-delete-all 'truncation fringe-indicator-alist))
#+end_src

** =straight.el=
Straight is an alternative way to manage package installations.
It can install packages from Git repositories listed on ELPA, MELPA, and directly from Git URLs.

#+begin_src emacs-lisp
  (defvar straight-process-buffer)
  (setq-default straight-process-buffer " *straight-process*")

  (defvar straight-repository-branch)
  (setq straight-repository-branch "develop")

  (defvar straight-build-dir)
  (setq straight-build-dir (format "build-%s" emacs-version))

  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory)))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (defvar straight-check-for-modifications)
  (setq-default straight-check-for-modifications '(check-on-save))
#+end_src

** early =package.el= settings
=package.el= initialization is expensive, thus should be disabled before loading main init file:

#+begin_src emacs-lisp
  (setq package-enable-at-startup nil)
#+end_src

** =(provide 'early-init)=
This concludes the =early-init.el= file.

#+begin_src emacs-lisp
  (provide 'early-init)
  ;;; early-init.el ends here
#+end_src

* =init.el=
:properties:
:header-args+: :tangle "./init.el"
:end:
Main GNU Emacs init file.

#+begin_src emacs-lisp
  ;;; init.el --- Emacs main configuration file -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-

  ;; Author: Andrey Listopadov
  ;; Keywords: literate programming, Emacs configuration
  ;; Homepage: https://gitlab.com/andreyorst/dotfiles/-/tree/master/.config/emacs

  ;;; Commentary:
  ;; Emacs config.
  ;; This file was automatically generated by `org-babel-tangle'.
  ;; Do not change this file.  Main config is located in README.org at `user-emacs-directory'

  ;;; Code:
#+end_src

** Loading =early-init.el= in Emacs 26 and earlier
When using pre Emacs 27 =eraly-init.el= must be loaded manually before anything from =init.el=.

#+begin_src emacs-lisp
  (unless (featurep 'early-init)
    (load (expand-file-name "early-init" user-emacs-directory)))
#+end_src

** Defaults
Section with configurations that need to be done early enough or hard to categorize.

*** =use-package=
A macro for managing installed packages, and encapsulating their configurations.

#+begin_src emacs-lisp
  (straight-use-package 'use-package)
  (defvar straight-use-package-by-default)
  (setq straight-use-package-by-default t)
  (require 'use-package)
#+end_src

*** Custom File and Disabled Commands
Emacs customization system writes to =init.el= by default which is not great when using tangle approach.
To preserve custom modifications it is moved to separate file.

#+begin_src emacs-lisp
  (use-package cus-edit
    :straight nil
    :custom (custom-file (expand-file-name "custom.el" user-emacs-directory))
    :init (load custom-file :noerror))
#+end_src

Same thing with disabled commands.

#+begin_src emacs-lisp
  (defvar aorst--disabled-commands (expand-file-name "disabled.el" user-emacs-directory)
    "File to store disabled commands, that were enabled permamently.")

  (define-advice enable-command (:around (foo command) aorst:put-in-custom-file)
    (let ((user-init-file aorst--disabled-commands))
      (funcall foo command)))

  (load aorst--disabled-commands :noerror)
#+end_src

*** Personal custom group
Group for custom, which provides a way of persisting options without needing to use concrete values in this config directly.
Can be used for creating machine local configurations.

#+begin_src emacs-lisp
  (defgroup local-config nil
    "Customization group for local settings."
    :prefix "local-config-")
#+end_src

*** User Credentials
Some modes can use full name and e-mail address automatically.

#+begin_src emacs-lisp
  (use-package startup
    :straight nil
    :no-require t
    :custom
    (user-mail-address "andreyorst@gmail.com")
    (user-full-name "Andrey Listopadov"))
#+end_src

*** Bell
No bell.

#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
#+end_src

*** Backups
Backup files and auto-save files are kept within =.cache= directory located at =user-emacs-direcotry=.

#+begin_src emacs-lisp
  (use-package files
    :straight nil
    :custom
    (backup-by-copying t)
    (create-lockfiles nil)
    (backup-directory-alist
     `(("." . ,(expand-file-name ".cache/backups" user-emacs-directory))))
    (auto-save-file-name-transforms
     `((".*" ,(expand-file-name ".cache/auto-save/" user-emacs-directory) t)))
    (auto-save-no-message t)
    (auto-save-interval 100)
    :config
    (let ((auto-save-dir (expand-file-name ".cache/auto-save/" user-emacs-directory)))
      (unless (file-exists-p auto-save-dir)
        (make-directory auto-save-dir t))))
#+end_src

*** Yes or No
Prompt for =y= or =n= instead of =yes= or =no=.

#+begin_src emacs-lisp
  (use-package subr
    :straight nil
    :no-require t
    :init
    (fset 'yes-or-no-p 'y-or-n-p))
#+end_src

*** Mouse and Scrolling
Disabling menu popup on shift clicks, scroll acceleration, hover highlighting, and enabling mouse support in terminal.
Also advising =scroll-left= to prevent over-scrolling past the visible part of the text (prevents further scrolling when longest line end is /visible/).

#+begin_src emacs-lisp
  (use-package mwheel
    :straight nil
    :demand
    :bind (("S-<down-mouse-1>" . nil)
           ("S-<mouse-3>" . nil)
           ("<mouse-4>" . mwheel-scroll)
           ("<mouse-5>" . mwheel-scroll))
    :custom
    (mouse-wheel-flip-direction t)
    (mouse-wheel-tilt-scroll t)
    (mouse-wheel-progressive-speed nil)
    :config
    (global-set-key (kbd "<mouse-3>") menu-bar-edit-menu)
    (defun aorst/truncated-lines-p ()
      "Non-nil if any line is longer than `window-width' + `window-hscroll'.
  Returns t if any line exceeds right border of the window.  Used
  for stopping scroll from going beyond longest line.  Based on
  `so-long-detected-long-line-p'."
      (save-excursion
        (goto-char (point-min))
        (let* ((window-width
                ;; this computes a more accurate width rather than `window-width', and respects
                ;; `text-scale-mode' font width.
                (/ (window-body-width nil t) (window-font-width)))
               (hscroll-offset
                ;; `window-hscroll' returns columns that are not affected by `text-scale-mode'.
                ;; Because of that we have to recompute correct `window-hscroll' by multiplying
                ;; it with a non-scaled value, and divide with scaled width value, and round it
                ;; to upper boundary.  Since there's no way to get unscaled value, we have to
                ;; get width of a face that is not scaled by `text-scale-mode', such as
                ;; `window-divider' face.
                (ceiling (/ (* (window-hscroll) (window-font-width nil 'window-divider))
                            (float (window-font-width)))))
               (line-number-width
                ;; compensate line numbers width
                (if (bound-and-true-p display-line-numbers-mode)
                    (- display-line-numbers-width)
                  0))
               ;; subtracting 4 for extra space in case some calculations were imprecise
               (threshold (+ window-width hscroll-offset line-number-width -4)))
          (catch 'excessive
            (while (not (eobp))
              (setq start (point))
              (save-restriction
                (narrow-to-region start (min (+ start 1 threshold)
                                             (point-max)))
                (forward-line 1))
              (unless (or (bolp)
                          (and (eobp) (<= (- (point) start)
                                          threshold)))
                (throw 'excessive t)))))))
    (define-advice scroll-left (:around (foo &optional arg set-minimum) aorst:scroll-left)
      (when (and (aorst/truncated-lines-p)
                 (not (memq major-mode '(vterm-mode term-mode))))
        (funcall foo arg set-minimum)))
    (setq-default auto-window-vscroll nil
                  mouse-highlight nil
                  hscroll-step 1
                  hscroll-margin 1
                  scroll-margin 1
                  scroll-step 1
                  scroll-conservatively 101
                  scroll-up-aggressively 0.01
                  scroll-down-aggressively 0.01
                  scroll-preserve-screen-position nil)
    (unless (display-graphic-p)
      (xterm-mouse-mode t)))
#+end_src

*** Tab character
Tab character is rarely a mandatory, and only a small selection of tools require it (e.g. Makefile).

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

*** History
Preserve history between sessions.

#+begin_src emacs-lisp
  (use-package savehist
    :straight nil
    :config (savehist-mode 1))
#+end_src

*** Keyboard Layout
This configures two keyboard layouts: =qwerty= and =Ð¹Ñ†ÑƒÐºÐµÐ½=, which can be toggled inside Emacs with =C-\= to keep chords like =C-x= work independently of the active layout.

#+begin_src emacs-lisp
  (use-package mule-cmds
    :straight nil
    :no-require t
    :custom
    (default-input-method 'russian-computer))
#+end_src

*** UTF8
=UTF8= should be preferred.

#+begin_src emacs-lisp
  (prefer-coding-system 'utf-8)
  (when (display-graphic-p)
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src

*** Default Major Mode
Lisp interaction mode adds a bit of startup time, and is rarely needed.

#+begin_src emacs-lisp
  (use-package startup
    :straight nil
    :no-require t
    :custom
    (initial-major-mode 'fundamental-mode)
    (initial-scratch-message ""))
#+end_src

*** Selection
Delete selection by typing.

#+begin_src emacs-lisp
  (use-package delsel
    :straight nil
    :init
    (delete-selection-mode t))
#+end_src

*** Default Bindings
Configurations for inbuilt =simple.el= module.

#+begin_src emacs-lisp
  (use-package simple
    :straight nil
    :bind (("C-w" . aorst/kill-region-or-word)
           ("C-x C-l" . aorst/downcase-region-or-word)
           ("C-x C-u" . aorst/upcase-region-or-word)
           ("C-x C-x" . aorst/exchange-point-and-mark)
           ("C-o" . aorst/newline-below)
           ("C-S-o" . aorst/newline-above)
           ("M-z" . zap-up-to-char)
           ("C-x k" . kill-this-buffer)
           ("M-S-z" . zap-to-char)
           ("<kp-begin>" . ignore)
           ("<kp-5>" . ignore)
           ("<f2>" . ignore)
           ("C-h C-f" . describe-face))
    :hook ((before-save . delete-trailing-whitespace)
           (overwrite-mode . aorst/overwrite-set-cursor-shape))
    :custom
    (yank-excluded-properties t "Disable all text properties when yanking.")
    (blink-matching-delay 0)
    (blink-matching-paren t)
    :init
    (defun aorst/kill-region-or-word (arg)
      (interactive "*p")
      (if (and transient-mark-mode
               mark-active)
          (kill-region (region-beginning) (region-end))
        (backward-kill-word arg)))
    (defun aorst/downcase-region-or-word (arg)
      (interactive "*p")
      (if (and transient-mark-mode
               mark-active)
          (downcase-region (region-beginning) (region-end))
        (downcase-word arg)))
    (defun aorst/upcase-region-or-word (arg)
      (interactive "*p")
      (if (and transient-mark-mode
               mark-active)
          (upcase-region (region-beginning) (region-end))
        (upcase-word arg)))
    (defun aorst/exchange-point-and-mark (arg)
      (interactive "*p")
      (when (and transient-mark-mode
                 mark-active)
        (exchange-point-and-mark)))
    (defun aorst/newline-below ()
      (interactive)
      (end-of-line)
      (newline-and-indent))
    (defun aorst/newline-above ()
      (interactive)
      (back-to-indentation)
      (newline-and-indent)
      (forward-line -1)
      (indent-according-to-mode))
    (defun aorst/overwrite-set-cursor-shape ()
      (when (display-graphic-p)
        (setq cursor-type (if overwrite-mode 'box 'bar)))))
#+end_src

*** Line truncation
Disables line wrapping.

#+begin_src emacs-lisp
  (setq-default truncate-lines t)
  (setq-default bidi-paragraph-direction 'left-to-right)

  (when (version<= "27.1" emacs-version)
    (setq bidi-inhibit-bpa t))
#+end_src

*** Minibuffer
Disabling clicks in minibuffer, to prevent opening =*Messages*= buffer.
Additionally, enabling =flex= matching in completion engine, and tweaking faces.

#+begin_src emacs-lisp
  (use-package minibuffer
    :straight nil
    :bind (:map minibuffer-inactive-mode-map
           ("<mouse-1>" . ignore))
    :custom (completion-styles '(basic partial-completion flex))
    :custom-face (completions-first-difference ((t (:inherit unspecified)))))
#+end_src

*** Form feed
Render =^L= as continuous comment or dashed line.

#+begin_src emacs-lisp
  (defun aorst/formfeed-line ()
    "Display the formfeed ^L char as comment or as continuous line."
    (unless buffer-display-table
      (setq buffer-display-table (make-display-table)))
    (aset buffer-display-table ?\^L
          (vconcat (make-list (or fill-column 70)
                              (make-glyph-code
                               (string-to-char (or comment-start "-"))
                               'shadow)))))

  (dolist (mode-hook '(help-mode-hook
                       org-mode-hook
                       outline-mode-hook
                       prog-mode-hook))
    (add-hook mode-hook #'aorst/formfeed-line))
#+end_src

*** Window
Binding for =bury-buffer= command.

#+begin_src emacs-lisp
  (use-package window
    :straight nil
    :bind ("C-c b" . bury-buffer))
#+end_src

*** Comint
Prevent automatic recentering when using inferior buffers.

#+begin_src emacs-lisp
  (use-package comint
    :straight nil
    :custom (comint-scroll-show-maximum-output nil))
#+end_src

** Functions
This section describes additional functions for internal use in configurations of various packages, that are general enough.
All functions and variables are prefixed with =aorst/= and =aorst--= respectively to prevent conflicts.

*** =real-buffer-p=
This function decides if buffer should be considered a "real" buffer.
Real buffer concept is introduced [[*Solaire Mode][Solaire Mode]] but is actually useful in several other places.

#+begin_src emacs-lisp
  (defun aorst/real-buffer-p (&optional buffer)
    "Determines whether BUFFER is real."
    (not (or (string-match-p
              (regexp-opt '("*Treemacs"
                            "*vterm*"
                            " *Minibuf"
                            " *Echo Area"
                            "*Process List*"
                            "*Ediff"
                            " *LV*"
                            "*Ilist*"))
              (buffer-name buffer))
             (minibufferp))))
#+end_src

*** =escape=
Changes =C-g= to quit current action regardless of active window.

#+begin_src emacs-lisp
  (defun aorst/escape ()
    "Quit in current context.

  When there is an active minibuffer and we are not inside it close
  it.  When we are inside the minibuffer use the regular
  `minibuffer-keyboard-quit' which quits any active region before
  exiting.  When there is no minibuffer `keyboard-quit' unless we
  are defining or executing a macro."
    (interactive)
    (cond ((active-minibuffer-window)
           (if (minibufferp)
               (minibuffer-keyboard-quit)
             (abort-recursive-edit)))
          ((bound-and-true-p iedit-mode)
           (iedit-quit))
          (t
           (unless (or defining-kbd-macro
                       executing-kbd-macro)
             (if (and (bound-and-true-p aorst--god-mode)
                      (not (bound-and-true-p god-local-mode))
                      (not (and transient-mark-mode
                                mark-active)))
                 (god-local-mode)
               (keyboard-quit))))))

  (global-set-key [remap keyboard-quit] #'aorst/escape)
#+end_src

*** =font-installed-p=
Checks if font is available on the system.

#+begin_src emacs-lisp
  (defun aorst/font-installed-p (font-name)
    "Check if font with FONT-NAME is available."
    (find-font (font-spec :name font-name)))
#+end_src

*** =indent-buffer=
Indent a buffer by using language indentation rules provided by current mode.
If there's a tool that can properly format buffer it should be used instead of this function.

#+begin_src emacs-lisp
  (defun aorst/indent-buffer ()
    "Indent whole buffer."
    (interactive)
    (save-excursion
      (save-restriction
        (indent-region (point-min) (point-max)))))

  (global-set-key (kbd "C-c C-M-f") #'aorst/indent-buffer)
#+end_src

*** =split-paragraph-into-lines=
Format paragraph by following one sentence per line style of editing.

#+begin_src emacs-lisp
  (defun aorst/split-pararagraph-into-lines ()
    "Split current paragraph into lines with one sentence each."
    (interactive)
    (save-excursion
      (let ((fill-column (point-max)))
        (fill-paragraph))
      (let ((auto-fill-p auto-fill-function)
            (end (progn (end-of-line) (backward-sentence) (point))))
        (back-to-indentation)
        (unless (= (point) end)
          (auto-fill-mode -1)
          (while (< (point) end)
            (forward-sentence)
            (delete-horizontal-space)
            (newline-and-indent))
          (deactivate-mark)
          (when auto-fill-p
            (auto-fill-mode t))
          (when (looking-at "^$")
            (backward-delete-char 1))))))
#+end_src

*** =dark-mode-p=
Shorter predicate for dark mode check:

#+begin_src emacs-lisp
  (defun aorst/dark-mode-p ()
    "Check if frame is dark or not."
    (if window-system
        (thread-last "gsettings get org.gnome.desktop.interface gtk-theme"
          (shell-command-to-string)
          (string-trim-right)
          (string-suffix-p "-dark'"))
        (eq 'dark (frame-parameter nil 'background-mode))))
#+end_src

*** =create-accent-face=
Creates a slight variation of a face, by blending =ref-face= background color with foreground color.
It is used to create refine faces for diffs.
Depends on DOOM's =doom-blend= function, and if it is not available, it fallbacks to =inverse-video= method, which is used by default for refine face anyways.

#+begin_src emacs-lisp
  (defun aorst/create-accent-face (face ref-face)
    "Set FACE background to accent color by blending REF-FACE foreground and background.
  Depends on `doom-blend'."
    (let ((fg (face-attribute ref-face :foreground))
          (bg (face-attribute ref-face :background)))
      (if (and (stringp fg)
               (stringp bg)
               (fboundp #'doom-blend))
          (set-face-attribute face nil
                              :foreground fg
                              :distant-foreground fg
                              :weight 'bold
                              :background (if (aorst/dark-mode-p)
                                              (doom-blend bg fg 0.8)
                                            (doom-blend bg fg 0.9))
                              :inherit nil
                              :extend t
                              :inverse-video nil)
        (set-face-attribute face nil
                            :foreground nil
                            :distant-foreground nil
                            :background nil
                            :weight 'bold
                            :inherit ref-face
                            :extend t
                            :inverse-video t))))
#+end_src

*** =doto=
Creates an object, and puts as a first argument to subsequent forms.

#+begin_src emacs-lisp
  (defmacro doto (x &rest forms)
    "Evaluates x then calls all of the functions with the value of
  x supplied at the front of the given arguments.  The forms are
  evaluated in order.  Returns x."
    (declare (indent defun))
    (let ((gx (gensym)))
      `(let ((,gx ,x))
         ,@(mapcar (lambda (f)
                     (if (listp f)
                         `(,(car f) ,gx ,@(cdr f))
                       `(,f ,gx)))
                   forms)
         ,gx)))
#+end_src

*** =minibuffer-efer-garbage-collection=
When minibuffer pops up, the garbage collection is deferred for more optimal filtering performance.

#+begin_src emacs-lisp
  (defun aorst/minibuffer-defer-garbage-collection ()
    "Defer garbage collection for minibuffer"
    (setq gc-cons-threshold most-positive-fixnum))

  (defun aorst/minibuffer-restore-garbage-collection ()
    "Resotre garbage collection settings."
    (run-at-time
     1 nil (lambda () (setq gc-cons-threshold aorst--gc-cons-threshold))))
#+end_src

** User Interface
Packages that affect user interface.

*** Splash Screen
Disable splash screen.

#+begin_src emacs-lisp
  (use-package startup
    :straight nil
    :no-require t
    :custom
    (inhibit-splash-screen t))
#+end_src

*** Menu bar
Menu bar is organized in trees and is handy when working with new packages.
However in terminal Emacs it is completely useless.

#+begin_src emacs-lisp
  (use-package menu-bar
    :straight nil
    :unless (display-graphic-p)
    :config
    (menu-bar-mode -1))
#+end_src

*** Line height
When =text-scale-mode= is active it's hard to tell what line height actually is.
This variable helps calculating that reliably.

#+begin_src emacs-lisp
  (defvar aorst--line-pixel-height (line-pixel-height)
    "Line height in pixels.
  Used in various places to avoid getting wrong line height when
  `text-scale-mode' is active.")
#+end_src

*** Menus, Tooltips, Scroll bars
Tooltips should be handled with Emacs, not with GTK.
Scrollbars and toolbar are disabled.

#+begin_src emacs-lisp
  (when window-system
    (setq-default x-gtk-use-system-tooltips nil)
    (setq-default tooltip-x-offset 0)
    (setq-default tooltip-y-offset aorst--line-pixel-height)
    (setq-default tooltip-frame-parameters
                  `((name . "tooltip")
                    (internal-border-width . ,(/ aorst--line-pixel-height 2))
                    (border-width . 1)
                    (no-special-glyphs . t)))
    (scroll-bar-mode -1)
    (tool-bar-mode -1))
#+end_src

*** Cursor Type
When using graphical Emacs, a more traditional bar cursor is used, and shown only in the active window.

#+begin_src emacs-lisp
  (when window-system
    (setq-default cursor-type 'bar
                  cursor-in-non-selected-windows nil))
#+end_src

*** Font
[[https://www.jetbrains.com/lp/mono/][JetBrains Mono]] font has nice support for ligatures, and overall looks great, supporting a lot of languages and styles like *bold*, /italics/ for not only Latin languages.
If neither =JetBrainsMono= is not found =Source Code Pro= is used as a fallback.

#+begin_src emacs-lisp
  (cond ((aorst/font-installed-p "JetBrainsMono")
         (set-face-attribute 'default nil :font "JetBrainsMono 10"))
        ((aorst/font-installed-p "Source Code Pro")
         (set-face-attribute 'default nil :font "Source Code Pro 10")))
#+end_src

For variable pitched fonts DejaVu font is used if available.

#+begin_src emacs-lisp
  (when (aorst/font-installed-p "DejaVu Sans")
    (set-face-attribute 'variable-pitch nil :font "DejaVu Sans 10"))
#+end_src

**** Ligatures
With the inclusion of [[https://github.com/harfbuzz/harfbuzz][HarfBuzz]] support into Emacs 27, it is now possible to use =auto-composition-mode= to add ligatures.
Needed ligatures can be specified by defining regular expressions:

#+begin_src emacs-lisp
  (when (aorst/font-installed-p "JetBrainsMono")
    (dolist (char/ligature-re
             `((?-  ,(rx (or (or "-->" "-<<" "->>" "-|" "-~" "-<" "->") (+ "-"))))
               (?/  ,(rx (or (or "/==" "/=" "/>" "/**" "/*") (+ "/"))))
               (?*  ,(rx (or (or "*>" "*/") (+ "*"))))
               (?<  ,(rx (or (or "<<=" "<<-" "<|||" "<==>" "<!--" "<=>" "<||" "<|>" "<-<"
                                 "<==" "<=<" "<-|" "<~>" "<=|" "<~~" "<$>" "<+>" "</>" "<*>"
                                 "<->" "<=" "<|" "<:" "<>"  "<$" "<-" "<~" "<+" "</" "<*")
                             (+ "<"))))
               (?:  ,(rx (or (or ":?>" "::=" ":>" ":<" ":?" ":=") (+ ":"))))
               (?=  ,(rx (or (or "=>>" "==>" "=/=" "=!=" "=>" "=:=") (+ "="))))
               (?!  ,(rx (or (or "!==" "!=") (+ "!"))))
               (?>  ,(rx (or (or ">>-" ">>=" ">=>" ">]" ">:" ">-" ">=") (+ ">"))))
               (?&  ,(rx (+ "&")))
               (?|  ,(rx (or (or "|->" "|||>" "||>" "|=>" "||-" "||=" "|-" "|>" "|]" "|}" "|=")
                             (+ "|"))))
               (?.  ,(rx (or (or ".?" ".=" ".-" "..<") (+ "."))))
               (?+  ,(rx (or "+>" (+ "+"))))
               (?\[ ,(rx (or "[<" "[|")))
               (?\{ ,(rx "{|"))
               (?\? ,(rx (or (or "?." "?=" "?:") (+ "?"))))
               (?#  ,(rx (or (or "#_(" "#[" "#{" "#=" "#!" "#:" "#_" "#?" "#(") (+ "#"))))
               (?\; ,(rx (+ ";")))
               (?_  ,(rx (or "_|_" "__")))
               (?~  ,(rx (or "~~>" "~~" "~>" "~-" "~@")))
               (?$  ,(rx "$>"))
               (?^  ,(rx "^="))
               (?\] ,(rx "]#"))))
      (apply (lambda (char ligature-re)
               (set-char-table-range composition-function-table char
                                     `([,ligature-re 0 font-shape-gstring])))
             char/ligature-re)))
#+end_src

Ligatures are selectively enabled in the following modes:

#+begin_src emacs-lisp
  (use-package composite
    :straight nil
    :hook ((prog-mode
            cider-repl-mode
            inferior-lisp-mode)
           . auto-composition-mode)
    :init (global-auto-composition-mode -1))
#+end_src

*** Icons
=all-the-icons= package provides icons for Emacs via custom fonts.

#+begin_src emacs-lisp
  (use-package all-the-icons
    :config
    (when (and (not (aorst/font-installed-p "all-the-icons"))
               (window-system))
      (all-the-icons-install-fonts t)))
#+end_src

*** Solaire Mode
This package helps distinguishing buffers that have a file opened, and buffers that are for utilities like file the filetree.
It uses  =aorst/real-buffer-p= as =solaire-mode-real-buffer-fn=.

#+begin_src emacs-lisp
  (use-package solaire-mode
    :commands (solaire-global-mode)
    :custom
    (solaire-mode-real-buffer-fn #'aorst/real-buffer-p)
    :init
    (solaire-global-mode 1))
#+end_src

*** Theme
=doom-themes= package is a theme collection, originally developed for [[https://github.com/hlissner/doom-emacs][DOOM Emacs]].
Provided themes define colors for pretty much every popular Emacs package, which helps make Emacs look very consistent.

#+begin_src emacs-lisp
  (defcustom aorst--dark-theme 'doom-spacegrey
    "Dark theme to use."
    :tag "Dark theme"
    :type 'symbol
    :group 'local-config)

  (defcustom aorst--light-theme 'doom-one-light
    "Light theme to use."
    :tag "Light theme"
    :type 'symbol
    :group 'local-config)

  (use-package doom-themes
    :custom
    (doom-themes-enable-bold t)
    (doom-themes-enable-italic t)
    :custom-face
    (fringe    ((t (:background nil))))
    (highlight ((t (:foreground unspecified
                    :distant-foreground unspecified
                    :background unspecified))))
    (org-block ((t (:extend t :background unspecified :inherit hl-line))))
    (org-block-begin-line ((t (:slant unspecified
                               :weight normal
                               :background unspecified
                               :inherit org-block
                               :extend t))))
    (org-block-end-line   ((t (:background unspecified
                               :inherit org-block-begin-line
                               :extend t))))
    (secondary-selection  ((t (:foreground unspecified
                               :background unspecified
                               :inherit region
                               :extend t))))
    (org-level-2 ((t (:inherit outline-3))))
    (org-level-3 ((t (:inherit outline-4))))
    (org-level-4 ((t (:inherit outline-2))))
    (org-level-5 ((t (:inherit outline-1))))
    (org-level-6 ((t (:inherit outline-3))))
    (org-level-7 ((t (:inherit outline-4))))
    (org-level-8 ((t (:inherit outline-2))))
    (org-drawer ((t (:foreground nil :inherit shadow))))
    (font-lock-comment-face ((t (:background unspecified))))
    :config
    (if (aorst/dark-mode-p)
        (load-theme aorst--dark-theme t)
      (load-theme aorst--light-theme t)))
#+end_src

The following code specifies hooks that will run via advice, which in turn runs after =load-theme= function.
It is useful to update some faces that are out of scope of current theme or dynamically changed by me, therefore have to be recalculated.

#+begin_src emacs-lisp
  (defvar aorst--theme-change-hook nil
    "Hook run after a color theme is loaded using `load-theme'.")

  (define-advice load-theme (:after (&rest _) aorst:setup-theme)
    (run-hooks 'aorst--theme-change-hook))

  (define-advice disable-theme (:after (&rest _) aorst:setup-theme)
    (run-hooks 'aorst--theme-change-hook))

  (setq-default custom-safe-themes t)
#+end_src

*** Mode-line
Mode-line is displayed at the bottom of each buffer, and shows necessary information about buffer state.
There are several packages that can make the mode-line appear differently, but most will reuse mode-line settings.

#+begin_src emacs-lisp
  (setq-default column-number-mode t
                line-number-mode t
                size-indication-mode nil
                mode-line-position nil
                mode-line-percent-position nil
                mode-line-in-non-selected-windows nil)

  (dolist (face '(mode-line mode-line-inactive))
    (set-face-attribute face nil
                        :box nil))
#+end_src

**** Mode-line segments
Most of these segments are based on [[https://github.com/seagle0128/doom-modeline][DOOM Modeline]].

***** Buffer name
Buffer name module for mode-line.
Returns buffer name or empty string if buffer is special and starts from space.

#+begin_src emacs-lisp
  (defvar-local aorst--mode-line-buffer-name "")
  (defvar-local aorst--modeline-project-cache nil)

  (defun aorst/mode-line-update-buffer-name (&rest _)
    (setq aorst--mode-line-buffer-name
          (if-let ((name (buffer-file-name)))
              (concat
               "  "
               (if-let ((project (or aorst--modeline-project-cache (project-current))))
                   (progn (setq-local aorst--modeline-project-cache project)
                          (string-trim-left (abbreviate-file-name name)
                                            (car (project-roots project))))
                 (abbreviate-file-name name)))
            "")))

  (add-hook 'find-file-hook #'aorst/mode-line-update-buffer-name)
  (add-hook 'after-change-major-mode-hook #'aorst/mode-line-update-buffer-name)
  (add-hook 'clone-indirect-buffer-hook #'aorst/mode-line-update-buffer-name)
  (advice-add #'not-modified :after #'aorst/mode-line-update-buffer-name)
  (advice-add #'rename-buffer :after #'aorst/mode-line-update-buffer-name)
  (advice-add #'set-visited-file-name :after #'aorst/mode-line-update-buffer-name)
  (advice-add #'pop-to-buffer :after #'aorst/mode-line-update-buffer-name)
  (advice-add #'undo :after #'aorst/mode-line-update-buffer-name)
  (advice-add #'undo-tree-undo-1 :after #'aorst/mode-line-update-buffer-name)
  (advice-add #'undo-tree-redo-1 :after #'aorst/mode-line-update-buffer-name)
  (advice-add #'fill-paragraph :after #'aorst/mode-line-update-buffer-name)
  (advice-add #'popup-create :after #'aorst/mode-line-update-buffer-name)
  (advice-add #'popup-delete :after #'aorst/mode-line-update-buffer-name)
  (advice-add #'org-edit-src-save :after #'aorst/mode-line-update-buffer-name)
  (advice-add #'symbol-overlay-rename :after #'aorst/mode-line-update-buffer-name)
#+end_src

***** Buffer state
Modified state module for mode-line.

#+begin_src emacs-lisp
  (defsubst aorst/mode-line-buffer-state ()
    (concat (if (and buffer-file-name (buffer-modified-p))
                (concat "  " (propertize (if (char-displayable-p ?ðŸ’¾) "ðŸ’¾" "[*]"
                                             'help-echo (concat (buffer-name) " has unsaved changes"))))
              "")
            (if (or (buffer-narrowed-p)
                    (and (bound-and-true-p fancy-narrow-mode)
                         (fancy-narrow-active-p))
                    (bound-and-true-p dired-narrow-mode))
                (concat "  " (propertize (if (char-displayable-p ?â†•) "â†•" "[><]"
                                             'help-echo (concat (buffer-name) " is narrowed"))))
              "")
            (if (and buffer-read-only
                     (not (memq major-mode '(vterm-mode
                                             treemacs-mode
                                             xref--xref-buffer-mode
                                             magit-status-mode))))
                (concat "  " (propertize
                              (if (char-displayable-p ?ðŸ”’) "ðŸ”’" "[RO]")
                              'help-echo "Make file writable"
                              'local-map (doto (make-sparse-keymap)
                                           (define-key [mode-line mouse-1] 'mode-line-toggle-read-only))))
              "")))
#+end_src

***** Buffer encoding
Buffer encoding module for mode-line.

#+begin_src emacs-lisp
  (defsubst aorst/mode-line-buffer-encoding ()
    (concat
     "  "
     (propertize
      (let ((sys (coding-system-plist buffer-file-coding-system)))
        (if (memq (plist-get sys :category)
                  '(coding-category-undecided coding-category-utf-8))
            "UTF-8"
          (upcase (symbol-name (plist-get sys :name)))))
      'help-echo 'mode-line-mule-info-help-echo
      'local-map mode-line-coding-system-map)))
#+end_src

***** Line and column
Line-column module for mode-line.

#+begin_src emacs-lisp
  (defsubst aorst/mode-line-line-column ()
    (concat
     "  "
     (propertize
      "%C:%l"
      'help-echo "goto line"
      'local-map (doto (make-sparse-keymap)
                   (define-key [mode-line mouse-1] #'goto-line)))))
#+end_src

***** Line encoding
Line encoding module for mode-line.

#+begin_src emacs-lisp
  (defsubst aorst/mode-line-line-encoding ()
    (if-let ((eol (pcase (coding-system-eol-type buffer-file-coding-system)
                    (0 "LF")
                    (1 "CRLF")
                    (2 "CR")
                    (_ nil))))
        (concat
         "  "
         (propertize
          eol
          'help-echo (format "Line ending style: %s"
                             (pcase eol
                               ("LF" "Unix style LF")
                               ("CRLF" "DOS style CRLF")
                               ("CR" "Mac style CR")
                               (_ "Undecided")))
          'local-map (doto (make-sparse-keymap)
                       (define-key [mode-line mouse-1] 'mode-line-change-eol))))
      ""))
#+end_src

***** Input method
Input method module for mode-line.

#+begin_src emacs-lisp
  (defsubst aorst/mode-line-input-method ()
    (if current-input-method
        (concat
         "  "
         (propertize
          current-input-method-title
          'help-echo (concat
                      "Current input method: "
                      current-input-method
                      "\nmouse-2: Disable input method\nmouse-3: Describe current input method")
          'local-map mode-line-input-method-map))
      ""))
#+end_src

***** Indentation mode
Indentation info module for mode-line.

#+begin_src emacs-lisp
  (defvar-local aorst--mode-line--current-major-mode nil)

  (defvar-local aorst--mode-line--indent-var nil
    "Holds variable that is used for setting indent offset in current major mode.
   Used for both checking if we need to do meaningful work in
   `aorst/mode-line-indent-mode', and for getting updated value.")

  (defvar-local aorst--mode-line--indent-var-value nil
    "Holds indent offset value, that was gathered before.
   Used to check if we need to preform meaningful work in
   `aorst/mode-line-indent-mode'.")

  (defvar-local aorst--mode-line--indent-mode-string "")

  (defun aorst/mode-line-indent-mode ()
    "Compute mode-line string with current indent mode.
   Does heavy work only if major-mode has changed since last call,
   or if current indent offset has changed since last call, or if
   there's no previous result of this function stored."
    (unless (and (eq major-mode aorst--mode-line--current-major-mode)
                 (eq aorst--mode-line--indent-var-value
                     (symbol-value aorst--mode-line--indent-var))
                 aorst--mode-line--indent-mode-string)
      (setq-local aorst--mode-line--current-major-mode major-mode)
      (setq-local aorst--mode-line--indent-var (aorst/mode-line--get-indent-var))
      (setq-local aorst--mode-line--indent-var-value (symbol-value aorst--mode-line--indent-var))
      (let ((indent-mode-str (concat (when (and (not indent-tabs-mode)
                                                aorst--mode-line--indent-var-value)
                                       (format "%d " aorst--mode-line--indent-var-value))
                                     (if indent-tabs-mode "Tabs" "Spaces"))))
        (setq-local aorst--mode-line--indent-mode-string
                    (concat
                     "  "
                     (propertize
                      indent-mode-str
                      'help-echo (concat "Indent mode: "
                                         indent-mode-str
                                         (when aorst--mode-line--indent-var
                                           (format "\nindent var: %S" aorst--mode-line--indent-var))
                                         "\nmouse-1: toggle indent-"
                                         (if indent-tabs-mode "spaces" "tabs")
                                         "-mode")
                      'local-map (doto (make-sparse-keymap)
                                   (define-key [mode-line mouse-1] 'aorst/toggle-indent-mode)))))))
    aorst--mode-line--indent-mode-string)

  (defun aorst/mode-line--get-indent-var ()
    "Get variable that holds indent offset for current major mode.
   Uses `editorconfig-indentation-alist' variable as a source for
   all relationshipts between major modes and their respective
   offset variables."
    (when (boundp 'editorconfig-indentation-alist)
      (car (assoc-default
            major-mode
            editorconfig-indentation-alist
            (lambda (car key)
              (provided-mode-derived-p key car))))))

  (defun aorst/toggle-indent-mode ()
    "Toggle `indent-tabs-mode' on and off."
    (interactive)
    (setq-local indent-tabs-mode (not indent-tabs-mode)))
#+end_src

***** Structural edition mode
Support for various structural editing modes in mode-line.

#+begin_src emacs-lisp
  (defvar-local aorst--mode-line-structural "")

  (defun aorst/mode-line-structural (&rest _)
    (setq aorst--mode-line-structural
          (if-let ((structural
                    (cond ((bound-and-true-p parinfer-rust-mode)
                           (propertize (concat "Parinfer" (pcase parinfer-rust--mode
                                                            ("smart" "/s")
                                                            ("indent" "/i")
                                                            ("paren" "/p")
                                                            (_ "")))
                                       'help-echo (concat "Parinfer " parinfer-rust--mode
                                                          " mode is enabled for current buffer\nmouse-1: toggle Parinfer mode")
                                       'local-map (doto (make-sparse-keymap)
                                                    (define-key [mode-line mouse-1] #'parinfer-rust-toggle-paren-mode))))
                          ((bound-and-true-p paredit-mode)
                           (propertize "Paredit" 'help-echo "Paredit mode is enabled for current buffer"))
                          ((bound-and-true-p smartparens-strict-mode)
                           (propertize "SP/s" 'help-echo "Smartparens mode is enabled for current buffer"))
                          ((bound-and-true-p smartparens-mode)
                           (propertize "SP" 'help-echo "Smartparens mode is enabled for current buffer"))
                          ((bound-and-true-p lispy-mode)
                           (propertize "Lispy" 'help-echo "Lispy mode is enabled for current buffer"))
                          ((bound-and-true-p electric-pair-mode)
                           (propertize "EPM" 'help-echo "Electric Pair mode is enabled for current buffer")))))
              (concat "  " structural)
            "")))

  (add-hook 'parinfer-rust-mode-hook #'aorst/mode-line-structural)
  (add-variable-watcher 'parinfer-rust--mode #'aorst/mode-line-structural)
  (add-hook 'paredit-mode-hook #'aorst/mode-line-structural)
  (add-hook 'smartparens-mode-hook #'aorst/mode-line-structural)
  (add-hook 'smartparens-strict-mode-hook #'aorst/mode-line-structural)
  (add-hook 'lispy-mode-hook #'aorst/mode-line-structural)
  (add-hook 'electric-pair-mode-hook #'aorst/mode-line-structural)
#+end_src

***** Major mode
Major mode module for mode-line

#+begin_src emacs-lisp
  (defsubst aorst/mode-line-mode-name ()
    (concat
     "  "
     (propertize
      (format-mode-line mode-name)
      'help-echo (format "Major mode: %s" (format-mode-line mode-name)))))
#+end_src

***** Git
Branch name module for mode-line.

#+begin_src emacs-lisp
  (defsubst aorst/mode-line-git-branch ()
    (if (and vc-mode buffer-file-name)
        (let* ((str (when vc-display-status
                      (substring
                       vc-mode
                       (+ (if (eq (vc-backend buffer-file-name) 'Hg) 2 3)
                          2)))))
          (when str
            (concat (if (char-displayable-p ?î‚ ) "  î‚  " "  @") str)))
      ""))
#+end_src

***** LSP
Mode line segment for Language server protocol.

#+begin_src emacs-lisp
  (defvar-local aorst--mode-line-lsp "")

  (defun aorst/mode-line-update-lsp (&rest _)
    (setq aorst--mode-line-lsp
          (concat "  "
                  (if-let ((workspaces (lsp-workspaces)))
                      (propertize "LSP" 'help-echo "LSP Connected")
                    (propertize "LSP" 'help-echo "LSP Disconnected")))))

  (add-hook 'lsp-before-initialize-hook #'aorst/mode-line-update-lsp)
  (add-hook 'lsp-after-initialize-hook #'aorst/mode-line-update-lsp)
  (add-hook 'lsp-after-uninitialized-functions #'aorst/mode-line-update-lsp)
  (add-hook 'lsp-before-open-hook #'aorst/mode-line-update-lsp)
  (add-hook 'lsp-after-open-hook #'aorst/mode-line-update-lsp)
#+end_src

***** Flycheck
Mode line segment for Flycheck.

#+begin_src emacs-lisp
  (defvar-local aorst--mode-line-flycheck "")

  (defun aorst/mode-line-update-flycheck (&rest _)
    (setq aorst--mode-line-flycheck
          (if (bound-and-true-p flycheck-mode)
              (concat
               "  "
               (pcase flycheck-last-status-change
                 (`not-checked (propertize "-/-" 'help-echo "Flycheck: not checked"))
                 (`no-checker (propertize "-" 'help-echo "Flycheck: no checker"))
                 (`running (propertize "*/*" 'help-echo "Flycheck: checking"))
                 (`errored (propertize "!" 'help-echo "Flycheck: error"))
                 (`finished
                  (let-alist (flycheck-count-errors flycheck-current-errors)
                    (propertize (format "%s/%s" (or .error 0) (or .warning 0))
                                'help-echo (if (or .error .warning)
                                               (concat "Flycheck: "
                                                       (when .error (format "%d errors%s" .error (if .warning ", " "")))
                                                       (when .warning (format "%d warnings" .warning))
                                                       "\nmouse-1: list errors")
                                             "Flycheck: no errors or warnings")
                                'local-map 'flycheck-error-list-mode-line-map)))
                 (`interrupted (propertize "x" 'help-echo "Flycheck: interrupted"))
                 (`suspicious (propertize "?" 'help-echo "Flycheck: suspicious"))))
            "")))

  (add-hook 'flycheck-status-changed-functions #'aorst/mode-line-update-flycheck)
  (add-hook 'flycheck-mode-hook #'aorst/mode-line-update-flycheck)
#+end_src

***** Flymake
Mode line segment for Flymake.

#+begin_src emacs-lisp
  (defvar-local aorst--mode-line-flymake "")

  (defun aorst/flymake-mode-line-update (&rest _)
    (when (bound-and-true-p flymake-mode)
      (let* ((known (hash-table-keys flymake--backend-state))
             (running (flymake-running-backends))
             (disabled (flymake-disabled-backends))
             (reported (flymake-reporting-backends))
             (all-disabled (and disabled (null running)))
             (some-waiting (cl-set-difference running reported)))
        (setq aorst--mode-line-flymake
              (concat
               "  "
               (cond (some-waiting (propertize "*/*" 'help-echo "Flymake: running"))
                     ((null known) (propertize "?"   'help-echo "Flymake: no info"))
                     (all-disabled (propertize "-"   'help-echo "Flymake: disabled"))
                     (t (let ((.error 0) (.warning 0))
                          (progn
                            (cl-loop with warning-level = (warning-numeric-level :warning)
                                     with note-level = (warning-numeric-level :debug)
                                     for state being the hash-values of flymake--backend-state
                                     do (cl-loop with diags = (flymake--backend-state-diags state)
                                                 for diag in diags do
                                                 (let ((severity (flymake--lookup-type-property
                                                                  (flymake--diag-type diag) 'severity
                                                                  (warning-numeric-level :error))))
                                                   (cond ((> severity warning-level) (cl-incf .error))
                                                         ((> severity note-level)    (cl-incf .warning))))))
                            (propertize (format "%s/%s" (or .error 0) (or .warning 0))
                                        'help-echo (if (or .error .warning)
                                                       (concat "Flymake: "
                                                               (when .error (format "%d errors%s" .error (if .warning ", " "")))
                                                               (when .warning (format "%d warnings" .warning)))
                                                     "Flymake: no errors or warnings")))))))))))

  (advice-add #'flymake--handle-report :after #'aorst/flymake-mode-line-update)
  (add-hook 'flymake-mode-hook #'aorst/flymake-mode-line-update)
#+end_src

**** Mode-line format
Fallback format for modeline.

#+begin_src emacs-lisp
  (defvar mode-line-l-format 'aorst--mode-line-buffer-name)
  (defvar mode-line-r-format
    '(concat
      (aorst/mode-line-buffer-state)
      (aorst/mode-line-line-column)
      (aorst/mode-line-input-method)
      (aorst/mode-line-line-encoding)
      (aorst/mode-line-buffer-encoding)
      (aorst/mode-line-indent-mode)
      (aorst/mode-line-mode-name)
      (aorst/mode-line-git-branch)
      aorst--mode-line-lsp
      aorst--mode-line-flymake
      aorst--mode-line-flycheck
      aorst--mode-line-structural))

  (setq-default
   mode-line-format
   '(:eval
     (let ((mode-line-l-format (concat " " (string-trim-left (eval mode-line-l-format))))
           (mode-line-r-format (eval mode-line-r-format)))
       (concat mode-line-l-format
               (make-string (- (window-width)
                               (string-width (format-mode-line mode-line-l-format))
                               (string-width (format-mode-line mode-line-r-format)))
                            ?\s)
               mode-line-r-format))))
#+end_src

***** Mini Modeline
A package that displays mode-line in the echo area.

#+begin_src emacs-lisp
  (use-package mini-modeline
    :hook ((aorst--theme-change . aorst/mini-modeline-setup-faces)
           (after-init . mini-modeline-mode)
           (isearch-mode . aorst/mini-modeline-isearch)
           (isearch-mode-end . aorst/mini-modeline-isearch-end))
    :custom
    (mini-modeline-right-padding 2)
    (mini-modeline-display-gui-line nil)
    (mini-modeline-l-format
     '(:eval (string-trim-left (eval mode-line-l-format))))
    (mini-modeline-r-format
     '(:eval (eval mode-line-r-format)))
    :config
    (defvar aorst--mini-modeline-isearch-delay (* 60 60 1000)
      "Delay echo area update to keep the isearch prompt.")
    (defun aorst/mini-modeline-isearch ()
      (setq mini-modeline-echo-duration aorst--mini-modeline-isearch-delay))
    (defvar aorst--mini-modeline-echo-delay mini-modeline-echo-duration
      "Delay echo area update to keep the isearch prompt.")
    (defun aorst/mini-modeline-isearch-end ()
      (setq mini-modeline-echo-duration aorst--mini-modeline-echo-delay))
    (defun aorst/mini-modeline-setup-faces ()
      "Setup mini-modeline face."
      (setq mini-modeline-face-attr
            (plist-put mini-modeline-face-attr :background
                       (if (facep 'solaire-minibuffer-face)
                           (face-attribute 'solaire-minibuffer-face :background)
                         (face-attribute 'mode-line :background)))))
    (aorst/mini-modeline-setup-faces))
#+end_src

*** Frame
Calculate window divider colors based on window background color.

#+begin_src emacs-lisp
  (use-package frame
    :straight nil
    :when window-system
    :hook (aorst--theme-change . aorst/window-divider-setup-faces)
    :custom
    (window-divider-default-bottom-width 1)
    (window-divider-default-right-width 1)
    (window-divider-default-places t)
    :config
    (window-divider-mode t)
    (defun aorst/window-divider-setup-faces ()
      (let* ((color (face-attribute 'default :background))
             (color (if (fboundp #'doom-darken)
                        (if (aorst/dark-mode-p)
                            (doom-darken color 0.2)
                          (doom-darken color 0.1)))))
        (set-face-attribute 'window-divider nil :foreground color)))
    (aorst/window-divider-setup-faces))
#+end_src

*** Title
Display buffer name in the titlebar.

#+begin_src emacs-lisp
  (defcustom aorst--title-show-bufname t
    "Whether to include bufname to titlebar.
  Bufname is not necessary on GNOME, but may be useful in other DEs."
    :type 'boolean
    :group 'local-config)

  (setq-default frame-title-format
                '(:eval (let ((match (string-match "[ *]" (buffer-name))))
                          (if (or (and match (= match 0))
                                  (not aorst--title-show-bufname))
                              "Emacs"
                            "%b â€” Emacs"))))
#+end_src

*** Treemacs
File explorer that is displayed in the same frame, unlike inbuilt Speedbar.

#+begin_src emacs-lisp
  (use-package treemacs
    :when window-system
    :commands (treemacs-follow-mode
               treemacs-filewatch-mode
               treemacs-load-theme)
    :bind (("<f7>" . treemacs)
           ("C-c t" . treemacs-select-window)
           :map treemacs-mode-map
           ([C-tab] . aorst/treemacs-expand-all-projects)
           ("<drag-mouse-1>" . ignore))
    :hook ((after-init . aorst/treemacs-after-init-setup)
           (treemacs-mode . aorst/after-treemacs-setup)
           (treemacs-switch-workspace . aorst/treemacs-expand-all-projects)
           (treemacs-switch-workspace . treemacs-set-fallback-workspace)
           (treemacs-mode . aorst/treemacs-setup-title)
           (aorst--theme-change . aorst/treemacs-setup-title)
           (aorst--theme-change . aorst/treemacs-setup-faces)
           (aorst--theme-change . aorst/treemacs-variable-pitch-labels))
    :custom-face
    (treemacs-fringe-indicator-face ((t (:inherit font-lock-doc-face))))
    (treemacs-git-ignored-face ((t (:inherit (shadow)))))
    :custom
    (treemacs-width 32)
    (treemacs-is-never-other-window t)
    (treemacs-space-between-root-nodes nil)
    (treemacs-indentation 2)
    :config
    (treemacs-follow-mode t)
    (treemacs-filewatch-mode 1)
    (defun aorst/treemacs-setup-faces ()
      (set-face-attribute 'treemacs-root-face nil
                          :foreground (face-attribute 'default :foreground)
                          :inherit 'treemacs-directory-face
                          :height 1.0
                          :weight 'normal))
    (aorst/treemacs-setup-faces)
    :init
    (defun aorst/treemacs-expand-all-projects (&optional _)
      "Expand all projects."
      (interactive)
      (save-excursion
        (treemacs--forget-last-highlight)
        (dolist (project (treemacs-workspace->projects (treemacs-current-workspace)))
          (-when-let (pos (treemacs-project->position project))
            (when (eq 'root-node-closed (treemacs-button-get pos :state))
              (goto-char pos)
              (treemacs--expand-root-node pos)))))
      (treemacs--maybe-recenter 'on-distance))
    (defun aorst/treemacs-variable-pitch-labels (&rest _)
      (dolist (face '(treemacs-file-face
                      treemacs-tags-face
                      treemacs-directory-face
                      treemacs-directory-collapsed-face
                      treemacs-term-node-face
                      treemacs-help-title-face
                      treemacs-help-column-face
                      treemacs-git-added-face
                      treemacs-git-ignored-face
                      treemacs-git-renamed-face
                      treemacs-git-conflict-face
                      treemacs-git-modified-face
                      treemacs-git-unmodified-face
                      treemacs-git-untracked-face
                      treemacs-root-unreadable-face
                      treemacs-root-remote-face
                      treemacs-root-remote-unreadable-face
                      treemacs-root-remote-disconnected-face
                      treemacs-fringe-indicator-face
                      treemacs-on-failure-pulse-face
                      treemacs-on-success-pulse-face))
        (let* ((faces (face-attribute face :inherit nil))
               (faces (if (listp faces) faces (list faces))))
          (unless (memq 'variable-pitch faces)
            (set-face-attribute
             face nil :inherit
             `(variable-pitch ,@(delq 'unspecified faces)))))))
    (defun aorst/treemacs-after-init-setup ()
      "Set treemacs theme, open treemacs, and expand all projects."
      (load-file (expand-file-name "treemacs-atom-theme.el" user-emacs-directory))
      (treemacs-load-theme "Atom")
      (treemacs)
      (treemacs-fringe-indicator-mode -1)
      (aorst/treemacs-expand-all-projects)
      (windmove-right))
    (defun aorst/after-treemacs-setup ()
      "Set treemacs buffer common settings."
      (setq tab-width 1
            mode-line-format nil
            line-spacing 5)
      (setq-local scroll-step 1)
      (setq-local scroll-conservatively 10000)
      (set-window-fringes nil 1 1 nil)
      (aorst/treemacs-variable-pitch-labels))
    (define-advice treemacs-select-window (:after () aorst:treemacs-setup-fringes)
      "Set treemacs buffer fringes."
      (set-window-fringes nil 1 1 t))
    (define-advice treemacs-root-down (:after () aorst:treemacs-root-down)
      "Open all projects on root down"
      (aorst/treemacs-expand-all-projects))
    (defun aorst/treemacs-setup-title ()
      (when-let ((treemacs-buffer (treemacs-get-local-buffer)))
        (with-current-buffer treemacs-buffer
          (let ((bg (if (and (facep 'solaire-default-face)
                             (not (eq (face-attribute 'solaire-default-face :background)
                                      'unspecified)))
                        (face-attribute 'solaire-default-face :background)
                      (face-attribute 'default :background)))
                (fg (face-attribute 'default :foreground)))
            (face-remap-add-relative 'header-line
                                     :background bg
                                     :foreground fg
                                     :box (list :line-width (/ aorst--line-pixel-height 4) :color bg)))
          (setq header-line-format
                '((:eval
                   (let* ((text (treemacs-workspace->name (treemacs-current-workspace)))
                          (extra-align (+ (/ (length text) 2) 1))
                          (width (- (/ (window-width) 2) extra-align)))
                     (concat (make-string width ?\s) text)))))))))
#+end_src

**** Treemacs Magit
Package for Treemacs and Magit integration.

#+begin_src emacs-lisp
  (use-package treemacs-magit
    :after magit)
#+end_src

**** Treemacs Atom theme
An Atom inspired theme for Treemacs, that is tangled to a separate file.

#+begin_src emacs-lisp :tangle ./treemacs-atom-theme.el
  ;;; treemacs-atom-theme.el --- Atom inspired theme for Treemacs -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-
  ;;;
  ;;; Commentary:
  ;;; Simple Atom inspired theme for Treemacs package.
  ;;; Does not provide different kinds of icons for different file extensions.
  ;;; This file was automatically generated by `org-babel-tangle'.
  ;;; Do not change this file.  Treemacs theme config is located in README.org at `user-emacs-directory'
  ;;;
  ;;; Code:

  (require 'treemacs)
  (require 'all-the-icons)

  (treemacs-create-theme "Atom"
    :config
    (progn
      (treemacs-create-icon
       :icon (format " %s\t%s\t"
                     (all-the-icons-octicon
                      "chevron-down"
                      :height 0.75
                      :v-adjust 0.1
                      :face '(:foreground unspecified :inherit shadow :slant normal :weight normal))
                     (all-the-icons-octicon
                      "file-directory"
                      :v-adjust 0
                      :face '(:foreground unspecified :inherit shadow :slant normal :weight normal)))
       :fallback (propertize "- " 'face 'shadow)
       :extensions (root-open))
      (treemacs-create-icon
       :icon (format " %s\t%s\t"
                     (all-the-icons-octicon
                      "chevron-right"
                      :height 0.75
                      :v-adjust 0.1
                      :face '(:foreground unspecified :inherit shadow :slant normal :weight normal))
                     (all-the-icons-octicon
                      "file-directory"
                      :v-adjust 0
                      :face '(:foreground unspecified :inherit shadow :slant normal :weight normal)))
       :fallback (propertize "+ " 'face 'shadow)
       :extensions (root-closed))
      (treemacs-create-icon
       :icon (format " %s\t%s\t"
                     (all-the-icons-octicon
                      "chevron-down"
                      :height 0.75
                      :v-adjust 0.1
                      :face '(:foreground unspecified :inherit shadow :slant normal :weight normal))
                     (all-the-icons-octicon
                      "file-directory"
                      :v-adjust 0
                      :face '(:foreground unspecified :inherit shadow :slant normal :weight normal)))
       :fallback (propertize "- " 'face 'shadow)
       :extensions (dir-open))
      (treemacs-create-icon
       :icon (format " %s\t%s\t"
                     (all-the-icons-octicon
                      "chevron-right"
                      :height 0.75
                      :v-adjust 0.1
                      :face '(:foreground unspecified :inherit shadow :slant normal :weight normal))
                     (all-the-icons-octicon
                      "file-directory"
                      :v-adjust 0
                      :face '(:foreground unspecified :inherit shadow :slant normal :weight normal)))
       :fallback (propertize "+ " 'face 'shadow)
       :extensions (dir-closed))
      (treemacs-create-icon
       :icon (format "  %s\t"
                     (all-the-icons-octicon
                      "chevron-down"
                      :height 0.75
                      :v-adjust 0.1
                      :face '(:foreground unspecified :inherit shadow :slant normal :weight normal)))
       :fallback (propertize "â–¾ " 'face 'font-lock-string-face)
       :extensions (tag-open))
      (treemacs-create-icon
       :icon (format "  %s\t"
                     (all-the-icons-octicon
                      "chevron-right"
                      :height 0.75
                      :v-adjust 0.1
                      :face '(:foreground unspecified :inherit shadow :slant normal :weight normal)))
       :fallback (propertize "â–¸ " 'face 'font-lock-string-face)
       :extensions (tag-closed))
      (treemacs-create-icon
       :icon (format "  %s\t"
                     (all-the-icons-octicon
                      "tag"
                      :height 0.9
                      :v-adjust 0
                      :face '(:foreground unspecified :inherit shadow :slant normal :weight normal)))
       :fallback ""
       :extensions (tag-leaf))
      (treemacs-create-icon
       :icon (format " %s\t"
                     (all-the-icons-octicon
                      "flame"
                      :v-adjust 0
                      :face '(:foreground unspecified :inherit shadow :slant normal :weight normal)))
       :fallback ""
       :extensions (error))
      (treemacs-create-icon
       :icon (format " %s\t"
                     (all-the-icons-octicon
                      "stop"
                      :v-adjust 0
                      :face '(:foreground unspecified :inherit shadow :slant normal :weight normal)))
       :fallback ""
       :extensions (warning))
      (treemacs-create-icon
       :icon (format " %s\t"
                     (all-the-icons-octicon
                      "info"
                      :height 0.75
                      :v-adjust 0.1
                      :face '(:foreground unspecified :inherit shadow :slant normal :weight normal)))
       :fallback ""
       :extensions (info))
      (treemacs-create-icon
       :icon (format "   %s\t"
                     (all-the-icons-octicon
                      "file-media"
                      :v-adjust 0
                      :face '(:foreground unspecified :inherit shadow :slant normal :weight normal)))
       :fallback ""
       :extensions ("png" "jpg" "jpeg" "gif" "ico" "tif" "tiff" "svg" "bmp"
                    "psd" "ai" "eps" "indd" "mov" "avi" "mp4" "webm" "mkv"
                    "wav" "mp3" "ogg" "midi"))
      (treemacs-create-icon
       :icon (format "   %s\t"
                     (all-the-icons-octicon
                      "file-code"
                      :v-adjust 0
                      :face '(:foreground unspecified :inherit shadow :slant normal :weight normal)))
       :fallback ""
       :extensions ("yml" "yaml" "sh" "zsh" "fish" "c" "h" "cpp" "cxx" "hpp"
                    "tpp" "cc" "hh" "hs" "lhs" "cabal" "py" "pyc" "rs" "el" "erl"
                    "elc" "clj" "cljs" "cljc" "ts" "tsx" "vue" "css" "html"
                    "htm" "dart" "java" "kt" "scala" "sbt" "go" "js" "jsx"
                    "hy" "json" "jl" "ex" "exs" "eex" "ml" "mli" "pp" "dockerfile"
                    "vagrantfile" "j2" "jinja2" "tex" "racket" "rkt" "rktl" "rktd"
                    "scrbl" "scribble" "plt" "makefile" "elm" "xml" "xsl" "rb"
                    "scss" "lua" "lisp" "scm" "sql" "toml" "nim" "pl" "pm" "perl"
                    "vimrc" "tridactylrc" "vimperatorrc" "ideavimrc" "vrapperrc"
                    "cask" "r" "re" "rei" "bashrc" "zshrc" "inputrc" "editorconfig"
                    "gitconfig" "gitignore" "gitmodules" "gitattributes" "conf" "lock"
                    "project" "fnl" "config"))
      (treemacs-create-icon
       :icon (format "   %s\t"
                     (all-the-icons-octicon
                      "book"
                      :v-adjust 0
                      :face '(:foreground unspecified :inherit shadow :slant normal :weight normal)))
       :fallback ""
       :extensions ("lrf" "lrx" "cbr" "cbz" "cb7" "cbt" "cba" "chm" "djvu"
                    "doc" "docx" "pdb" "pdb" "fb2" "xeb" "ceb" "inf" "azw"
                    "azw3" "kf8" "kfx" "lit" "prc" "mobi" "pkg" "opf" "txt"
                    "pdb" "ps" "rtf" "pdg" "xml" "tr2" "tr3" "oxps" "xps"))
      (treemacs-create-icon
       :icon (format "   %s\t" (all-the-icons-octicon
                                "file-text"
                                :v-adjust 0
                                :face '(:foreground unspecified :inherit shadow :slant normal :weight normal)))
       :fallback ""
       :extensions ("md" "markdown" "rst" "log" "org" "txt"
                    "contribute" "license" "readme" "changelog"))
      (treemacs-create-icon
       :icon (format "   %s\t" (all-the-icons-octicon
                                "file-binary"
                                :v-adjust 0
                                :face '(:foreground unspecified :inherit shadow :slant normal :weight normal)))
       :fallback ""
       :extensions ("exe" "dll" "obj" "so" "o" "out"))
      (treemacs-create-icon
       :icon (format "   %s\t" (all-the-icons-octicon
                                "file-pdf"
                                :v-adjust 0
                                :face '(:foreground unspecified :inherit shadow :slant normal :weight normal)))
       :fallback ""
       :extensions ("pdf"))
      (treemacs-create-icon
       :icon (format "   %s\t" (all-the-icons-octicon
                                "file-zip"
                                :v-adjust 0
                                :face '(:foreground unspecified :inherit shadow :slant normal :weight normal)))
       :fallback ""
       :extensions ("zip" "7z" "tar" "gz" "rar" "tgz"))
      (treemacs-create-icon
       :icon (format "   %s\t" (all-the-icons-octicon
                                "file-text"
                                :v-adjust 0
                                :face '(:foreground unspecified :inherit shadow :slant normal :weight normal)))
       :fallback ""
       :extensions (fallback))))

  (provide 'treemacs-atom-theme)
  ;; treemacs-atom-theme.el ends here
#+end_src

*** Uniquify
This package makes files with identical names more distinguishable by adding directory name in the buffer name.

#+begin_src emacs-lisp
  (use-package uniquify
    :straight nil
    :custom (uniquify-buffer-name-style 'forward))
#+end_src

*** Tabline
Starting with Emacs 27 native tab support is present, however the default appearance is not great.
Tab closing semantic is also not very useful defaulting to bury buffer.

#+begin_src emacs-lisp
  (use-package tab-line
    :straight nil
    :when window-system
    :hook ((after-init . global-tab-line-mode)
           (aorst--theme-change . aorst/tabline-setup-faces))
    :config
    (defun tab-line-close-tab (&optional e)
      "Close the selected tab.

  If tab is presented in another window, close the tab by using
  `bury-buffer` function.  If tab is unique to all existing
  windows, kill the buffer with `kill-buffer` function.  Lastly, if
  no tabs left in the window, it is deleted with `delete-window`
  function."
      (interactive "e")
      (let* ((posnp (event-start e))
             (window (posn-window posnp))
             (buffer (get-pos-property 1 'tab (car (posn-string posnp)))))
        (with-selected-window window
          (let ((tab-list (tab-line-tabs-window-buffers))
                (buffer-list (flatten-list
                              (seq-reduce (lambda (list window)
                                            (select-window window t)
                                            (cons (tab-line-tabs-window-buffers) list))
                                          (window-list) nil))))
            (select-window window)
            (if (> (seq-count (lambda (b) (eq b buffer)) buffer-list) 1)
                (progn
                  (if (eq buffer (current-buffer))
                      (bury-buffer)
                    (set-window-prev-buffers window (assq-delete-all buffer (window-prev-buffers)))
                    (set-window-next-buffers window (delq buffer (window-next-buffers))))
                  (unless (cdr tab-list)
                    (ignore-errors (delete-window window))))
              (and (kill-buffer buffer)
                   (unless (cdr tab-list)
                     (ignore-errors (delete-window window)))))))))


    (defun aorst/tab-line-name-buffer (buffer &rest _buffers)
      "Create name for tab with padding and truncation.

  If buffer name is shorter than `tab-line-tab-max-width' it gets
  centered with spaces, otherwise it is truncated, to preserve
  equal width for all tabs.  This function also tries to fit as
  many tabs in window as possible, so if there are no room for tabs
  with maximum width, it calculates new width for each tab and
  truncates text if needed.  Minimal width can be set with
  `tab-line-tab-min-width' variable."
      (with-current-buffer buffer
        (let ((buffer (string-trim (buffer-name)))
              (right-pad (if tab-line-close-button-show "" " ")))
          (propertize (concat " " buffer right-pad)
                      'help-echo (when-let ((name (buffer-file-name)))
                                   (abbreviate-file-name name))))))


    (setq tab-line-close-button-show t
          tab-line-new-button-show nil
          tab-line-separator ""
          tab-line-tab-name-function #'aorst/tab-line-name-buffer
          tab-line-right-button (propertize (if (char-displayable-p ?â–¶) " â–¶ " " > ")
                                            'keymap tab-line-right-map
                                            'mouse-face 'tab-line-highlight
                                            'help-echo "Click to scroll right")
          tab-line-left-button (propertize (if (char-displayable-p ?â—€) " â—€ " " < ")
                                           'keymap tab-line-left-map
                                           'mouse-face 'tab-line-highlight
                                           'help-echo "Click to scroll left")
          tab-line-close-button (propertize (if (char-displayable-p ?Ã—) " Ã— " " x ")
                                            'keymap tab-line-tab-close-map
                                            'mouse-face 'tab-line-close-highlight
                                            'help-echo "Click to close tab")
          tab-line-exclude-modes '(ediff-mode
                                   process-menu-mode
                                   term-mode
                                   vterm-mode
                                   treemacs-mode
                                   imenu-list-major-mode))


    (defun aorst/tabline-setup-faces ()
      (let ((bg (face-attribute 'default :background))
            (fg (face-attribute 'default :foreground))
            (dark-fg (face-attribute 'shadow :foreground))
            (overline (face-attribute 'font-lock-keyword-face :foreground))
            (base (if (and (facep 'solaire-default-face)
                           (not (eq (face-attribute 'solaire-default-face :background)
                                    'unspecified)))
                      (face-attribute 'solaire-default-face :background)
                    (face-attribute 'mode-line :background)))
            (box-width (/ aorst--line-pixel-height 5)))
        (when (facep 'tab-line-tab-special)
          (set-face-attribute 'tab-line-tab-special nil
                              :slant 'normal))
        (set-face-attribute 'tab-line nil
                            :background base
                            :foreground dark-fg
                            :height 1.0
                            :inherit nil
                            :overline base
                            :box (when (> box-width 0)
                                   (list :line-width -1 :color base)))
        (set-face-attribute 'tab-line-tab nil
                            :foreground dark-fg
                            :background bg
                            :inherit nil
                            :box (when (> box-width 0)
                                   (list :line-width box-width :color bg)))
        (set-face-attribute 'tab-line-tab-inactive nil
                            :foreground dark-fg
                            :background base
                            :inherit nil
                            :box (when (> box-width 0)
                                   (list :line-width box-width :color base)))
        (set-face-attribute 'tab-line-tab-current nil
                            :foreground fg
                            :background bg
                            :inherit nil
                            :overline overline
                            :box (when (> box-width 0)
                                   (list :line-width box-width :color bg)))))

    (aorst/tabline-setup-faces)

    (define-advice tab-line-select-tab (:after (&optional e) aorst:tab-line-select-tab)
      (select-window (posn-window (event-start e)))))
#+end_src

*** Line Numbers
=display-line-numbers= provides line numbers on the left side of the window, which doesn't lag as much as =linum-mode=.

#+begin_src emacs-lisp
  (use-package display-line-numbers
    :straight nil
    :hook (prog-mode . display-line-numbers-mode)
    :custom
    (display-line-numbers-width 4)
    (display-line-numbers-grow-only t)
    (display-line-numbers-width-start t)
    :config
    (define-advice previous-line (:around (f &rest args) aorst:previous-line-margin)
      "The `display-line-numbers' mode affects `scroll-margin' variable.

  This advice recalculates the amount of lines needed to scroll to
  ensure `scroll-margin' preserved."
      (apply f args)
      (let ((diff (- scroll-margin
                     (- (line-number-at-pos (point))
                        (line-number-at-pos (window-start))))))
        (when (> diff 0)
          (scroll-down diff)))))
#+end_src

** Languages
This section contains various language specific settings and external packages that provide language support.

*** Org Mode
Org Mode is a great mode for taking notes, managing to-do lists, writing books, literate programming, and many other things.

#+begin_src emacs-lisp
  (use-package org
    :straight (:type built-in)
    :hook (((org-capture-mode org-src-mode) . aorst/discard-history)
           (org-mode . flyspell-mode))
    :bind (:map org-mode-map
           ("M-Q" . aorst/split-pararagraph-into-lines)
           ("C-c l" . org-store-link))
    :custom
    (org-startup-with-inline-images nil)
    (org-tags-column -120)
    (org-startup-folded 'content)
    (org-hide-emphasis-markers t)
    (org-adapt-indentation nil)
    (org-hide-leading-stars t)
    (org-highlight-latex-and-related '(latex))
    (org-preview-latex-default-process 'dvisvgm)
    (org-src-fontify-natively t)
    (org-preview-latex-image-directory ".ltximg/")
    (org-confirm-babel-evaluate nil)
    (org-imenu-depth 8)
    (org-log-done t)
    (org-agenda-files '("~/Tasks"))
    (org-image-actual-width nil)
    :config
    (setq org-format-latex-options
          (plist-put org-format-latex-options
                     :scale
                     (if (executable-find "gsettings")
                         (string-to-number
                          (shell-command-to-string
                           "gsettings get org.gnome.desktop.interface text-scaling-factor"))
                       1.0)))
    (defun aorst/discard-history ()
      "Discard undo history of org src and capture blocks."
      (setq buffer-undo-list nil)
      (set-buffer-modified-p nil))
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((gnuplot . t)
       (scheme . t)))
    (defun aorst/org-update-latex-preview-background-color (&rest _)
      (setq-default
       org-format-latex-options
       (plist-put org-format-latex-options
                  :background
                  (face-attribute (let ((face (cadr (assq 'default face-remapping-alist))))
                                    (if (facep face) face 'default))
                                  :background nil t))))
    (add-hook 'solaire-mode-hook #'aorst/org-update-latex-preview-background-color)
    (define-advice org-return (:around (f &rest args) aorst:org-return)
      (let ((org-src-preserve-indentation t))
        (apply f args)))
    (define-advice org-cycle (:around (f &rest args) aorst:org-cycle)
      (let ((org-src-preserve-indentation t))
        (apply f args))))
#+end_src

**** OX Hugo
Support for using Org export feature with [[https://gohugo.io/][Hugo]] static site generator.

#+begin_src emacs-lisp
  (use-package ox-hugo
    :after ox)
#+end_src

**** OX LaTeX
Support of exporting to LaTeX.

#+begin_src emacs-lisp
  (use-package ox-latex
    :straight nil
    :after ox)
#+end_src

**** Org Tempo
Org previously had an inbuilt snippets that started with =<= followed by a letter which expand to various blocks, like source code blocks, quote blocks e.t.c.
It was externalized into separate package in more recent Org mode versions.

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (use-package org-tempo
      :straight nil
      :defines org-version
      :when (not (version<= org-version "9.1.9"))))
#+end_src

*** Prog Mode
This isn't really a configuration of Prog Mode itself, but some hooks that change how programming related modes behave.

#+begin_src emacs-lisp
  (use-package prog-mode
    :straight nil
    :hook ((prog-mode . hl-line-mode)
           (prog-mode . flyspell-prog-mode)))
#+end_src

*** C/C++
These settings are for editing C source files.

#+begin_src emacs-lisp
  (use-package cc-mode
    :straight nil
    :config (defun aorst/cc-mode-setup ()
              (c-set-offset 'case-label '+)
              (setq c-basic-offset 4
                    c-default-style "linux"
                    indent-tabs-mode t
                    comment-start "//"
                    comment-end ""
                    tab-width 4))
    :hook ((c-mode-common . aorst/cc-mode-setup)))
#+end_src

*** Markdown
A package for editing markdown files.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :bind (:map markdown-mode-map
           ("M-Q" . aorst/split-pararagraph-into-lines))
    :custom
    (markdown-fontify-code-blocks-natively t)
    (markdown-command "pandoc")
    (markdown-hr-display-char nil)
    (markdown-list-item-bullets '("-"))
    :hook ((markdown-mode . flyspell-mode)))
#+end_src

*** Rust
[[https://www.rust-lang.org/][Rust]] language support.

#+begin_src emacs-lisp
  (use-package rust-mode
    :commands (rust-format-buffer)
    :bind (:map rust-mode-map
           ("C-c C-M-f" . rust-format-buffer)))
#+end_src

*** TOML
[[https://toml.io/en/][TOML]] Language support.

#+begin_src emacs-lisp
  (use-package toml-mode
    :bind (:map toml-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)))
#+end_src

*** Geiser
REPL support for various Schemes.

#+begin_src emacs-lisp
  (use-package geiser
    :hook (scheme-mode . geiser-mode)
    :custom
    (geiser-active-implementations '(guile))
    (geiser-default-implementation 'guile))
#+end_src

*** Racket
[[https://racket-lang.org/][Racket]] language support

#+begin_src emacs-lisp
  (use-package racket-mode
    :bind (:map racket-mode-map
           ("C-c C-d" . racket-run-with-debugging)
           ("C-c C-M-f" . aorst/indent-buffer)
           (")" . self-insert-command)
           ("]" . self-insert-command)
           ("}" . self-insert-command))
    :hook (racket-mode . racket-xp-mode)
    :custom (racket-show-functions '(racket-show-echo-area))
    :config
    (set-face-attribute 'racket-debug-break-face nil :background (face-attribute 'error :foreground) :foreground (face-attribute 'default :background))
    (set-face-attribute 'racket-debug-result-face nil :foreground (face-attribute 'shadow :foreground) :box nil)
    (set-face-attribute 'racket-debug-locals-face nil :foreground (face-attribute 'shadow :foreground) :box nil)
    (set-face-attribute 'racket-selfeval-face nil :foreground (face-attribute 'default :foreground)))
#+end_src

*** Emacs Lisp
Emacs lisp mode tweaks.

#+begin_src emacs-lisp
  (use-package elisp-mode
    :straight nil
    :commands aorst/emacs-lisp-indent-function
    :hook ((emacs-lisp-mode . eldoc-mode)
           (emacs-lisp-mode . aorst/emacs-lisp-setup))
    :bind (:map emacs-lisp-mode-map
           ("C-c C-M-f" . aorst/indent-buffer))
    :config
    (defun aorst/emacs-lisp-indent-function (indent-point state)
      "A replacement for `lisp-indent-function'.
  Indents plists more sensibly. Adapted from DOOM Emacs:
  https://github.com/hlissner/doom-emacs/blob/b03fdabe4fa8a07a7bd74cd02d9413339a485253/modules/lang/emacs-lisp/autoload.el#L91"
      (let ((normal-indent (current-column))
            (orig-point (point))
            target)
        (goto-char (1+ (elt state 1)))
        (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
        (cond ((and (elt state 2)
                    (or (not (looking-at-p "\\sw\\|\\s_"))
                        (eq (char-after) ?:)))
               (unless (> (save-excursion (forward-line 1) (point))
                          calculate-lisp-indent-last-sexp)
                 (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t))
               (backward-prefix-chars)
               (current-column))
              ((and (save-excursion
                      (goto-char indent-point)
                      (skip-syntax-forward " ")
                      (not (eq (char-after) ?:)))
                    (save-excursion
                      (goto-char orig-point)
                      (and (eq (char-after) ?:)
                           (eq (char-before) ?\()
                           (setq target (current-column)))))
               (save-excursion
                 (move-to-column target t)
                 target))
              ((let* ((function (buffer-substring (point) (progn (forward-sexp 1) (point))))
                      (method (or (function-get (intern-soft function) 'lisp-indent-function)
                                  (get (intern-soft function) 'lisp-indent-hook))))
                 (cond ((or (eq method 'defun)
                            (and (null method)
                                 (> (length function) 3)
                                 (string-match-p "\\`def" function)))
                        (lisp-indent-defform state indent-point))
                       ((integerp method)
                        (lisp-indent-specform method state indent-point normal-indent))
                       (method
                        (funcall method indent-point state))))))))
    (defun aorst/emacs-lisp-setup ()
      (setq-local lisp-indent-function
                  #'aorst/emacs-lisp-indent-function))
    (defun org-babel-edit-prep:emacs-lisp (&optional _babel-info)
      "Setup Emacs Lisp buffer for Org Babel."
      (setq lexical-binding t)
      (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc))))
#+end_src

*** Fennel
Fennel is a lisp dialect, that is being compiled to Lua, which means that it can run anywhere, where Lua can.
It supports compile-time macro system, and full Lua compatibility.

#+begin_src emacs-lisp
  (use-package fennel-mode
    :bind (:map fennel-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)
           ("M-." . xref-find-definitions)
           ("M-," . xref-pop-marker-stack))
    :config
    (put 'global 'fennel-indent-function 1)
    (put 'local 'fennel-indent-function 1)
    (put 'var 'fennel-indent-function 1)
    (defvar org-babel-default-header-args:fennel '((:results . "silent")))
    (defun org-babel-execute:fennel (body params)
      "Evaluate a block of Fennel code with Babel."
      (let ((inferior-lisp-buffer fennel-repl--buffer))
        (lisp-eval-string body)))
    (define-advice fennel-repl (:after (&rest _) aorst:fennel-repl-indent-function)
      (setq-local lisp-indent-function 'fennel-indent-function)))
#+end_src

*** Clojure
[[https://clojure.org/][Clojure]] language support.

#+begin_src emacs-lisp
  (use-package clojure-mode
    :hook (((clojure-mode
             clojurec-mode
             clojurescript-mode)
            . aorst/clojure-mode-setup))
    :bind (:map clojure-mode-map
           ("C-c C-M-f" . aorst/indent-buffer))
    :config
    (defun aorst/clojure-mode-setup ()
      "Setup Clojure buffer."
      (modify-syntax-entry ?# "w")
      (flycheck-mode)))
#+end_src

**** CIDER
IDE for Clojure and ClojureScript.

#+begin_src emacs-lisp
  (use-package cider
    :hook (((cider-repl-mode cider-mode) . cider-company-enable-fuzzy-completion)
           ((cider-repl-mode cider-mode) . eldoc-mode))
    :bind (:map cider-repl-mode-map
           ("C-c C-o" . cider-repl-clear-buffer))
    :custom-face
    (cider-result-overlay-face ((t (:box (:line-width -1 :color "grey50")))))
    (cider-error-highlight-face ((t (:inherit flymake-error))))
    (cider-warning-highlight-face ((t (:inherit flymake-warning))))
    :custom
    (nrepl-log-messages nil)
    (cider-repl-display-help-banner nil)
    (cider-repl-tab-command #'indent-for-tab-command)
    (nrepl-hide-special-buffers t)
    (cider-test-show-report-on-success t)
    (cider-allow-jack-in-without-project t)
    (cider-use-fringe-indicators nil)
    (cider-font-lock-dynamically '(macro var deprecated))
    (cider-save-file-on-load nil)
    (cider-inspector-fill-frame nil)
    (cider-auto-select-error-buffer t)
    (cider-eval-spinner nil)
    (cider-repl-prompt-function #'cider-repl-prompt-newline)
    :config
    (setq cider-jdk-src-paths nil)
    (dolist (src (append (file-expand-wildcards "/usr/lib/jvm/java-*-openjdk/src.zip")
                         (file-expand-wildcards "/usr/lib/jvm/java-*-openjdk/lib/src.zip")
                         (file-expand-wildcards "~/.clojure/clojure-*-sources.jar")))

      (when (file-exists-p src)
        (unless (memq src cider-jdk-src-paths)
          (add-to-list 'cider-jdk-src-paths src t))))
    (defun cider-repl-prompt-newline (namespace)
      "Return a prompt string that mentions NAMESPACE with newline
  appended."
      (format "%s\n> " namespace)))
#+end_src

**** flycheck-clj-kondo
[[https://github.com/borkdude/clj-kondo][clj-kondo]] is a static analyzer for Clojure(Script), and =flycheck-clj-kondo= is a backend for =flycheck=, that makes these two things understand each other.

#+begin_src emacs-lisp
  (use-package flycheck-clj-kondo
    :when (executable-find "clj-kondo"))
#+end_src

**** clj-refactor
=clj-refactor= provides refactoring support for Clojure projects.
It complements the refactoring functionality from =clojure-mode= and CIDER.

#+begin_src emacs-lisp
  (use-package clj-refactor
    :hook ((cider-mode . clj-refactor-mode)
           (cider-mode . yas-minor-mode))
    :custom (cljr-suppress-no-project-warning t)
    (cljr-warn-on-eval nil))
#+end_src

*** Common Lisp
Common Lisp IDE for Emacs.
Disabled until [[https://gitlab.com/technomancy/fennel-mode/-/issues/11][technomancy/fennel-mode#11]] is resolved.

#+begin_src emacs-lisp
  (use-package sly
    :custom (inferior-lisp-program "sbcl")
    :config
    ;; workaround https://gitlab.com/technomancy/fennel-mode/issues/11
    ;; Sly author claims that this is `fennel-mode' problem, as
    ;; `lisp-mode' is meant strictly for Common Lisp.
    (defun aorst/sly-ignore-fennel (f &rest args)
      "Prevent sly functions from running in `fennel-mode'."
      (unless (or (eq major-mode 'fennel-mode)
                  (eq major-mode 'fennel-repl-mode))
        (apply f args)))
    (dolist (f '(sly-mode
                 sly-editing-mode))
      (advice-add f :around #'aorst/sly-ignore-fennel))
    (add-hook 'fennel-mode (lambda () (sly-symbol-completion-mode -1))))
#+end_src

*** Cmake
A mode for editing cmake files.

#+begin_src emacs-lisp
  (use-package cmake-mode
    :bind (:map cmake-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)))
#+end_src

*** Yaml
Support for =.yaml= files.

#+begin_src emacs-lisp
  (use-package yaml-mode
    :custom (yaml-indent-offset 4))
#+end_src

*** Shell Script
Some configurations for shell script modes.

#+begin_src emacs-lisp
  (use-package sh-script
    :straight nil
    :bind (:map sh-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)))
#+end_src

*** Perl
Perl related configurations.

#+begin_src emacs-lisp
  (use-package perl-mode
    :straight nil
    :hook ((perl-mode . flycheck-mode))
    :bind (:map perl-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)))
#+end_src

*** Lua
Lua support, mainly to view what [[*Fennel][Fennel]] compiler produces.

#+begin_src emacs-lisp
  (use-package lua-mode
    :bind (:map lua-mode-map
           ("C-c C-M-f" . aorst/indent-buffer))
    :hook (lua-mode . flycheck-mode)
    :custom (lua-indent-level 2))
#+end_src

*** CSS
CSS indentation tweaks.

#+begin_src emacs-lisp
  (use-package css-mode
    :straight nil
    :custom
    (css-indent-offset 2))
#+end_src

*** JSON
Json support for Emacs.

#+begin_src emacs-lisp
  (use-package json-mode
    :hook (json-mode . flycheck-mode)
    :custom (js-indent-level 2))
#+end_src

*** Shell script
Shell script linting.

#+begin_src emacs-lisp
  (use-package sh-script
    :straight nil
    :hook (sh-mode . flycheck-mode))
#+end_src

*** Scala
Scala language support.

#+begin_src emacs-lisp
  (use-package scala-mode)
#+end_src

*** SQL
SQL mode does not provide inbuilt support for indentation handling, and instead uses this package.

#+begin_src emacs-lisp
  (use-package sql-indent)
#+end_src

*** CSV
A mode for viewing and editing char separated value files.

#+begin_src emacs-lisp
  (use-package csv-mode
    :custom (csv-align-max-width 80))
#+end_src

** Tools
Additional packages that change how Emacs works, providing more comfortable user experience.

*** Help
Select help window automatically.

#+begin_src emacs-lisp
  (use-package help
    :straight nil
    :custom (help-window-select t))
#+end_src

*** Doc View
Default resolution is too low:

#+begin_src emacs-lisp
  (use-package doc-view
    :straight nil
    :custom (doc-view-resolution 192))
#+end_src

*** vterm
This package provides a bridge to =libvterm= to display terminal as Emacs buffer.

#+begin_src emacs-lisp
  (setq use-package-hook-name-suffix "-functions")
  (use-package vterm
    :if (bound-and-true-p module-file-suffix)
    :bind (("C-`" . aorst/vterm-toggle)
           ("C-t" . aorst/vterm-focus)
           :map vterm-mode-map
           ("<insert>" . ignore)
           ("<f2>" . ignore))
    :hook (vterm-exit . aorst/kill-vterm)
    :custom (vterm-always-compile-module t)
    :config
    (defun aorst/vterm-toggle (&optional arg)
      "Toggle `vterm' window on and off with the same command."
      (interactive "P")
      (let* ((directory (if default-directory
                            default-directory
                          (expand-file-name "~/")))
             (bufname " *vterm*")
             (window (get-buffer-window bufname)))
        (if window
            (ignore-errors (delete-window window))
          (if (window-dedicated-p)
              (let ((windows (seq-drop-while #'window-dedicated-p (window-list))))
                (when (not (null windows))
                  (select-window (car windows)))))
          (let* ((win-side (unless (string= (buffer-name) " *Install vterm* ")
                             (if (symbolp arg)
                                 (cons (split-window-below (floor (* (window-height) 0.65))) 'bot)
                               (cons (split-window-right) 'right))))
                 (window (car win-side))
                 (side (cdr win-side)))
            (when window
              (select-window window))
            (cond ((get-buffer bufname)
                   (switch-to-buffer bufname)
                   ;; for `bury-buffer' to work we need a non-hidden buffer
                   (rename-buffer "*vterm*"))
                  (t (let ((default-directory directory))
                       (vterm "*vterm*"))))
            (when (bound-and-true-p global-tab-line-mode)
              (previous-buffer)
              (bury-buffer))
            (rename-buffer " *vterm*")
            (set-window-dedicated-p window t)
            (set-window-parameter window 'no-delete-other-windows t)
            (when side
              (set-window-parameter window 'window-side side))
            (set-window-parameter window 'no-other-window t)))))
    (defun aorst/vterm-focus (&optional arg)
      "Focus `vterm' or open one if there's none."
      (interactive "P")
      (let ((window (get-buffer-window " *vterm*")))
        (if window
            (select-window window)
          (aorst/vterm-toggle arg))))
    (defun aorst/kill-vterm (buf &optional event)
      "Kill the `*vterm*' buffer after shell exits."
      (when buf (kill-buffer buf))))
  (setq use-package-hook-name-suffix "-hook")
#+end_src

*** EditorConfig
=.editorconfig= file provides a nice way to synchronize some of the configurations between projects and different editors.

#+begin_src emacs-lisp
  (use-package editorconfig
    :config (editorconfig-mode 1))
#+end_src

*** Flymake
Flymake is an inbuilt package for checking various programming languages.
It is loaded mostly to define faces.

#+begin_src emacs-lisp
  (use-package flymake
    :straight nil
    :custom
    (flymake-fringe-indicator-position 'right-fringe))
#+end_src

*** Flycheck
Some languages have better support with =flycheck=.

#+begin_src emacs-lisp
  (use-package flycheck
    :custom
    (flycheck-indication-mode 'right-fringe)
    (flycheck-display-errors-delay 86400 "86400 seconds is 1 day")
    :config
    (when (fboundp #'define-fringe-bitmap)
      (define-fringe-bitmap 'flycheck-double-exclamation-mark
        (vector #b00000000
                #b00000000
                #b00000000
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b00000000
                #b01100110
                #b01100110
                #b00000000
                #b00000000
                #b00000000))
      (define-fringe-bitmap 'flycheck-exclamation-mark
        (vector #b00000000
                #b00000000
                #b00000000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00000000
                #b00011000
                #b00011000
                #b00000000
                #b00000000
                #b00000000))
      (define-fringe-bitmap 'flycheck-question-mark
        (vector #b00000000
                #b00000000
                #b00000000
                #b00111100
                #b01100110
                #b01100110
                #b01100110
                #b00000110
                #b00001100
                #b00011000
                #b00011000
                #b00000000
                #b00011000
                #b00011000
                #b00000000
                #b00000000
                #b00000000))
      (flycheck-define-error-level 'error
        :severity 100
        :compilation-level 2
        :overlay-category 'flycheck-error-overlay
        :fringe-bitmap 'flycheck-double-exclamation-mark
        :fringe-face 'flycheck-fringe-error
        :error-list-face 'flycheck-error-list-error)
      (flycheck-define-error-level 'warning
        :severity 10
        :compilation-level 1
        :overlay-category 'flycheck-warning-overlay
        :fringe-bitmap 'flycheck-exclamation-mark
        :fringe-face 'flycheck-fringe-warning
        :error-list-face 'flycheck-error-list-warning)
      (flycheck-define-error-level 'info
        :severity -10
        :compilation-level 0
        :overlay-category 'flycheck-info-overlay
        :fringe-bitmap 'flycheck-question-mark
        :fringe-face 'flycheck-fringe-info
        :error-list-face 'flycheck-error-list-info))
    (define-advice flycheck-may-use-echo-area-p (:override () aorst:flycheck-no-echo-or-buffer)
      nil))
#+end_src

**** Flycheck package
Emacs package linting via package-lint and Flycheck.

#+begin_src emacs-lisp
  (use-package flycheck-package
    :hook ((emacs-lisp-mode . flycheck-mode)
           (emacs-lisp-mode . flycheck-package-setup)))
#+end_src

*** Hydra
This is something like ability to create mappings that sit in it's own mode, like different user modes in Kakoune.
It allows me to press some shortcut and be locked in a mode-like state where keys that are related to this prefix shortcut are behaving in terms of this shortcut.
This package will be used in many other package configurations to provide sane keybindings.

#+begin_src emacs-lisp
  (use-package hydra)
#+end_src

*** Smartparens
This is a package that enables structural editing in many different languages.
Basically, for all Lisp related modes the =smartparens-strict-mode= is used, while for other modes =smartparens-mode= is enough.
Note that the ";" key is set to =sp-comment= function for =smartparens-strict-mode=.

#+begin_src emacs-lisp
  (use-package smartparens
    :hook (((clojure-mode
             emacs-lisp-mode
             common-lisp-mode
             scheme-mode
             lisp-mode
             racket-mode
             fennel-mode
             cider-repl-mode
             racket-repl-mode
             geiser-repl-mode
             inferior-lisp-mode
             inferior-emacs-lisp-mode
             sly-mrepl-mode)
            . smartparens-strict-mode)
           ((eval-expression-minibuffer-setup
             lisp-data-mode)
            . aorst/minibuffer-enable-sp)
           ((org-mode
             markdown-mode
             prog-mode)
            . smartparens-mode)
           (smartparens-mode . show-smartparens-mode))
    :bind (:map smartparens-mode-map
           ("C-M-q" . sp-indent-defun)
           :map smartparens-strict-mode-map
           (";" . sp-comment))
    :custom
    (sp-highlight-pair-overlay nil)
    (sp-highlight-wrap-overlay nil)
    (sp-highlight-wrap-tag-overlay nil)
    (sp-wrap-respect-direction t)
    (sp-show-pair-delay 0)
    (sp-echo-match-when-invisible nil)
    :custom-face
    (sp-show-pair-match-face ((t (:background unspecified
                                  :weight normal))))
    :config
    (add-to-list 'sp-lisp-modes 'fennel-mode t)
    (require 'smartparens-config)
    (sp-use-paredit-bindings)
    :config
    (defun aorst/minibuffer-enable-sp ()
      "Enable `smartparens-strict-mode' in the minibuffer, during `eval-expression'."
      (setq-local comment-start ";")
      (sp-local-pair 'minibuffer-pairs "'" nil :actions nil)
      (sp-local-pair 'minibuffer-pairs "`" nil :actions nil)
      (sp-update-local-pairs 'minibuffer-pairs)
      (smartparens-strict-mode 1))
    (defun aorst/wrap-fix-cursor-position (_ action _)
      "Set cursor position inside expression when wrapping."
      (when (and (eq action 'wrap)
                 (eq (point)
                     (marker-position (sp-get sp-last-wrapped-region :beg))))
        (goto-char (sp-get sp-last-wrapped-region :beg-in))))
    (dolist (paren '("(" "[" "{"))
      (sp-pair paren nil :post-handlers '(:add aorst/wrap-fix-cursor-position))))
#+end_src

*** Flx
Flex matching for Emacs.

#+begin_src emacs-lisp
  (use-package flx)
#+end_src

*** COMMENT Ivy
Ivy is a narrowing framework like Helm, but much lighter.

#+begin_src emacs-lisp
  (use-package ivy
    :commands ivy-mode
    :hook ((minibuffer-setup . aorst/minibuffer-defer-garbage-collection)
           (minibuffer-exit . aorst/minibuffer-restore-garbage-collection)
           (aorst--theme-change . aorst/ivy-setup-faces))
    :bind (("C-x b" . ivy-switch-buffer)
           ("C-x C-b" . ivy-switch-buffer))
    :custom-face
    (ivy-org ((t (:inherit default))))
    :custom
    (ivy-count-format "")
    (ivy-ignore-buffers '("\\` " "\\`\\*"))
    (ivy-display-style nil)
    (ivy-minibuffer-faces nil)
    (ivy-minibuffer-faces '(default default default default))
    (ivy-use-virtual-buffers t)
    (enable-recursive-minibuffers t)
    :config
    (defun aorst/ivy-setup-faces ()
      (let ((mode-line-color (face-attribute 'mode-line :background)))
        (when (fboundp #'doom-darken)
          (set-face-attribute
           'ivy-current-match nil
           :background (if (aorst/dark-mode-p)
                           (doom-lighten mode-line-color 0.2)
                         (doom-darken mode-line-color 0.1))))))
    (aorst/ivy-setup-faces)
    :init
    (setq ivy-re-builders-alist '((t . ivy--regex-fuzzy)))
    (ivy-mode 1))
#+end_src

I'm using [[https://github.com/sharkdp/fd][fd]] as a great replacement for GNU Find.
It's fast and it takes =.gitignore= into account.
Counsel has nice =counsel-file-fump= command that uses =find-program= variable, so we can advice it in order for it to use =fd=.
The same thing is for =rg=, but counsel actually has it's own variable for it, so we do no need to runtime-patch it.

#+begin_src emacs-lisp
  (use-package counsel
    :commands (counsel-M-x
               counsel-find-file
               counsel-file-jump
               counsel-recentf
               counsel-rg
               counsel-describe-function
               counsel-describe-variable
               counsel-faces
               counsel-find-library)
    :bind (("M-x" . counsel-M-x)
           ("C-x C-f" . counsel-find-file)
           ("C-x f" . counsel-file-jump)
           ("C-x C-r" . counsel-recentf)
           ("C-x d" . counsel-dired)
           ("C-h f" . counsel-describe-function)
           ("C-h C-f" . counsel-faces)
           ("C-h v" . counsel-describe-variable)
           ("C-h l" . counsel-find-library))
    :config
    (when (executable-find "fd")
      (define-advice counsel-file-jump (:around (foo &optional initial-input initial-directory) aorst:counsel-fd)
        (let ((find-program "fd")
              (counsel-file-jump-args (split-string "-L --type f --hidden")))
          (funcall foo initial-input initial-directory))))
    (when (executable-find "rg")
      (setq counsel-rg-base-command
            "rg -S --no-heading --hidden --line-number --color never %s .")))
#+end_src

*** Vertico
Vertical completion UI for minibuffer.

#+begin_src emacs-lisp
  (use-package vertico
    :hook ((minibuffer-setup . aorst/minibuffer-defer-garbage-collection)
           (minibuffer-exit . aorst/minibuffer-restore-garbage-collection)
           (aorst--theme-change . aorst/vertico-setup-faces))
    :init (vertico-mode)
    (defun aorst/vertico-setup-faces ()
      (let ((mode-line-color (face-attribute 'mode-line :background)))
        (when (fboundp #'doom-darken)
          (set-face-attribute
           'vertico-current nil
           :background (if (aorst/dark-mode-p)
                           (doom-lighten mode-line-color 0.2)
                         (doom-darken mode-line-color 0.1))))))
    (aorst/vertico-setup-faces))
#+end_src

*** Marginalia
Completion candidates annotations for minibuffer.

#+begin_src emacs-lisp
  (use-package marginalia
    :init (marginalia-mode))
#+end_src

*** Consult
A predefined set of commands for minibuffer.

#+begin_src emacs-lisp
  (use-package consult
    :bind (("C-x C-r" . consult-recent-file))
    :init
    (setq completion-in-region-function #'consult-completion-in-region))
#+end_src

*** Company
Complete anything framework.

#+begin_src emacs-lisp
  (use-package company
    :bind (:map company-mode-map
           ([remap completion-at-point] . company-complete)
           ;; ([remap indent-for-tab-command] . company-indent-or-complete-common)
           ("M-/" . company-complete)
           :map company-active-map
           ("TAB" . company-complete-common-or-cycle)
           ("<tab>" . company-complete-common-or-cycle)
           ("<S-Tab>" . company-select-previous)
           ("<backtab>" . company-select-previous)
           ("C-n" . company-select-next)
           ("C-p" . company-select-previous)
           ("C-d" . company-show-doc-buffer)
           ("M-." . company-show-location))
    :hook (after-init . global-company-mode)
    :custom
    ;; (tab-always-indent 'complete)
    ;; (tab-first-completion 'word-or-paren-or-punct)
    (company-idle-delay 0)
    (company-require-match 'never)
    (company-minimum-prefix-length 2)
    (company-tooltip-align-annotations t)
    (company-frontends '(company-pseudo-tooltip-unless-just-one-frontend
                         company-preview-frontend
                         company-echo-metadata-frontend))
    (company-backends '(company-capf company-files company-dabbrev-code))
    (company-tooltip-minimum-width 30)
    (company-tooltip-maximum-width 120)
    (company-icon-size aorst--line-pixel-height)
    ;; (company-format-margin-function nil)
    )
#+end_src

**** Company quickhelp
Documentation popup for company mode.

#+begin_src emacs-lisp
  (use-package company-quickhelp
    :hook (company-mode . company-quickhelp-mode)
    :custom
    (company-quickhelp-max-lines 13)
    (company-quickhelp-use-propertized-text t))
#+end_src

*** Undo Tree
This is a more familiar undo mode.

#+begin_src emacs-lisp
  (use-package undo-tree
    :commands global-undo-tree-mode
    :bind (("C-z" . undo-tree-undo)
           ("C-S-z" . undo-tree-redo))
    :custom
    (undo-tree-visualizer-relative-timestamps nil)
    (undo-tree-visualizer-timestamps nil)
    (undo-tree-auto-save-history nil)
    :init (global-undo-tree-mode 1))
#+end_src

*** Yasnippet
Template engine for Emacs.

#+begin_src emacs-lisp
  (use-package yasnippet
    :config
    (add-to-list 'yas-key-syntaxes 'yas-shortest-key-until-whitespace))
#+end_src

*** Magit
Emacs interface to Git.

#+begin_src emacs-lisp
  (use-package with-editor)
  (use-package magit
    :hook (git-commit-mode . flyspell-mode)
    :bind (("<f12>" . magit-status))
    :custom
    (magit-ediff-dwim-show-on-hunks t)
    (magit-diff-refine-ignore-whitespace t)
    (magit-diff-refine-hunk 'all)
    (magit-blame-styles
     '((margin
        (margin-format " %s%f" " %C %a" " %H")
        (margin-width . 42)
        (margin-face . magit-blame-margin)
        (margin-body-face magit-blame-dimmed))
       (headings
        (heading-format . "%-20a %C %s\n"))
       (highlight
        (highlight-face . magit-blame-highlight))
       (lines
        (show-lines . nil)
        (show-message . t))))
    :config
    (advice-add 'magit-set-header-line-format :override #'ignore))
#+end_src

**** Magit TODOs
Display TODO items in Magit buffers.

#+begin_src emacs-lisp
  (use-package magit-todos
    :after magit
    :init
    ;; don't break Magit on systems that don't have `nice'
    (unless (executable-find "nice")
      (setq magit-todos-nice nil))
    :config
    (let ((inhibit-message t))
      (magit-todos-mode 1))
    (transient-append-suffix 'magit-status-jump '(0 0 -1)
      '("T " "Todos" magit-todos-jump-to-todos)))
#+end_src

*** Ediff
This is a inbuilt mode for diffing files in Emacs.

#+begin_src emacs-lisp
  (use-package ediff
    :straight nil
    :hook ((ediff-prepare-buffer . outline-show-all)
           (ediff-before-setup . aorst/store-pre-ediff-winconfig)
           (ediff-quit . aorst/restore-pre-ediff-winconfig)
           (ediff-keymap-setup . aorst/ediff-setup-keys))
    :custom-face
    (ediff-fine-diff-C ((t (:background unspecified
                            :inherit ediff-current-diff-C))))
    (ediff-fine-diff-B ((t (:background unspecified
                            :inherit diff-refine-added))))
    (ediff-fine-diff-A ((t (:background unspecified
                            :inherit diff-refine-removed))))
    :config
    (advice-add 'ediff-window-display-p :override #'ignore)
    :custom
    (ediff-split-window-function 'split-window-horizontally)
    :init
    (defvar aorst--ediff-last-windows nil
      "Stores window configuration before `ediff' was invoked.")
    (defun aorst/store-pre-ediff-winconfig ()
      (setq aorst--ediff-last-windows (current-window-configuration)))
    (defun aorst/restore-pre-ediff-winconfig ()
      (set-window-configuration aorst--ediff-last-windows))
    (defun aorst/ediff-copy-both-to-C ()
      (interactive)
      (ediff-copy-diff ediff-current-difference nil 'C nil
                       (concat
                        (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
                        (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))
    (defun aorst/ediff-setup-keys ()
      (define-key ediff-mode-map "d" #'aorst/ediff-copy-both-to-C)))
#+end_src

*** Diff
Some tweaks to inbuilt diff mode.

#+begin_src emacs-lisp
  (use-package diff
    :straight nil
    :after magit
    :hook (aorst--theme-change . aorst/diff-setup-faces)
    :custom-face
    (diff-added ((t (:inherit magit-diff-added-highlight))))
    (diff-removed ((t (:inherit magit-diff-removed-highlight))))
    :config
    (defun aorst/diff-setup-faces ()
      (set-face-attribute 'diff-added nil :foreground nil :background nil)
      (set-face-attribute 'diff-removed nil :foreground nil :background nil)
      (dolist (face-reference '((diff-refine-added magit-diff-added-highlight)
                                (diff-refine-removed magit-diff-removed-highlight)))
        (apply #'aorst/create-accent-face face-reference)))
    (aorst/diff-setup-faces))
#+end_src

*** Smerge
Some tweaks to inbuilt merge tool:

#+begin_src emacs-lisp
  (use-package smerge-mode
    :straight nil
    :after magit
    :hook (aorst--theme-change . aorst/smerge-setup-faces)
    :custom-face
    (smerge-refined-added ((t (:inherit magit-diff-added-highlight))))
    (smerge-refined-removed ((t (:inherit magit-diff-removed-highlight))))
    (smerge-lower ((t (:inherit magit-diff-added-highlight))))
    (smerge-upper ((t (:inherit magit-diff-removed-highlight))))
    (smerge-markers ((t (:weight bold
                         :extend t
                         :inherit shadow))))
    :config
    (defun aorst/smerge-setup-faces ()
      (dolist (face-reference '((smerge-refined-added magit-diff-added-highlight)
                                (smerge-refined-removed magit-diff-removed-highlight)))
        (apply #'aorst/create-accent-face face-reference)))
    (aorst/smerge-setup-faces))
#+end_src

*** Multiple Cursors
This package provides multiple cursors functionality to Emacs.

#+begin_src emacs-lisp
  (use-package phi-search)
  (use-package mc-extras)
  (use-package multiple-cursors
    :requires hydra
    :commands (mc/cycle-backward
               mc/cycle-forward)
    :bind (("S-<mouse-1>" . mc/add-cursor-on-click)
           ("C-c m" . hydrant/mc/body)
           ("M-n" . mc/mark-next-like-this-symbol)
           :map mc/keymap
           ("<return>" . nil)
           ("C-s" . phi-search)
           ("C-r" . phi-search-backward))
    :config
    (define-advice mc/mark-next-like-this-symbol (:after (&rest _) aorst:mc-mark-next-like-this-symbol) (mc/cycle-forward))
    (define-advice mc/mark-next-like-this-word (:after (&rest _) aorst:mc-mark-next-like-this-word) (mc/cycle-forward))
    (define-advice mc/mark-next-lines (:after (&rest _) aorst:mc-mark-next-lines) (mc/cycle-forward))
    (define-advice mc/mark-previous-like-this-symbol (:after (&rest _) aorst:mc-mark-previous-like-this-symbol) (mc/cycle-backward))
    (define-advice mc/mark-previous-like-this-word (:after (&rest _) aorst:mc-mark-previous-like-this-word) (mc/cycle-backward))
    (when (fboundp #'defhydra)
      (defhydra hydrant/mc (:hint nil :color pink)
        "
   ^Select^                       ^Discard^                      ^Edit^               ^Navigate^
   _M-s_: split lines             _M-SPC_:  discard current      _&_: align           _(_: cycle backward
   _s_:   select regexp           _b_:      discard blank lines  _#_: insert numbers  _)_: cycle forward
   _n_:   select next word        _d_:      remove duplicated    ^ ^                  ^ ^
   _M-n_: select next symbol      _q_ or _g_: exit hydrant       ^ ^                  ^ ^
   _p_:   select previous word    _G_:      exit mc mode         ^ ^                  ^ ^
   _M-p_: select previous symbol  ^ ^                            ^ ^                  ^ ^
   _C_:   select next line"
        ("M-s" mc/edit-ends-of-lines)
        ("s" mc/mark-all-in-region-regexp)
        ("n" mc/mark-next-like-this-word)
        ("M-n" mc/mark-next-like-this-symbol)
        ("p" mc/mark-previous-like-this-word)
        ("M-p" mc/mark-previous-like-this-symbol)
        ("&" mc/vertical-align-with-space)
        ("(" mc/cycle-backward)
        (")" mc/cycle-forward)
        ("M-SPC" mc/remove-current-cursor)
        ("b" mc/remove-cursors-on-blank-lines)
        ("d" mc/remove-duplicated-cursors)
        ("C" mc/mark-next-lines)
        ("#" mc/insert-numbers)
        ("q" mc/remove-duplicated-cursors :exit t)
        ("g" mc/remove-duplicated-cursors :exit t)
        ("G" mc/keyboard-quit :exit t)
        ("C-g" mc/keyboard-quit :exit t))))
#+end_src

*** Expand Region
Expand or reduce region semantically.

#+begin_src emacs-lisp
  (use-package expand-region
    :bind (("C-c e" . hydrant/er/body))
    :requires hydra
    :config
    (defun aorst/er-exit ()
      (interactive)
      (deactivate-mark t))
    (defhydra hydrant/er (:color pink :hint nil)
      "
   ^Expand/Discard^                ^Mark^
   _e_:      expand region         _(_: inside pairs
   _r_:      reduce region         _)_: around pairs
   _g_ or _q_: exit hydrant          _'_: inside quotes
   _G_:      discard region, exit  _\"_: around quotes
   ^ ^  ^ ^                          _p_: paragraph"
      ("e" er/expand-region)
      ("r" er/contract-region)
      ("p" er/mark-paragraph)
      ("(" er/mark-inside-pairs)
      (")" er/mark-outside-pairs)
      ("'" er/mark-inside-quotes)
      ("\"" er/mark-outside-quotes)
      ("g" ignore :exit t)
      ("q" ignore :exit t)
      ("G" aorst/er-exit :exit t)
      ("Q" aorst/er-exit :exit t)
      ("C-g" aorst/er-exit :exit t)))
#+end_src

*** LSP
Packages providing integration with Language Server Protocol.

**** LSP Mode
LSP client for Emacs.

#+begin_src emacs-lisp
  (use-package lsp-mode
    :hook (((rust-mode
             c-mode
             c++-mode
             elixir-mode
             clojure-mode
             clojurec-mode
             clojurescript-mode)
            . lsp)
           (lsp-mode . yas-minor-mode))
    :custom-face
    (lsp-modeline-code-actions-face ((t (:inherit mode-line))))
    :custom
    ;; general settings
    (lsp-keymap-prefix "C-c l")
    (lsp-completion-provider :capf)
    (lsp-diagnostics-provider :flycheck)
    (lsp-session-file (expand-file-name ".lsp-session" user-emacs-directory))
    (lsp-log-io nil)
    (lsp-keep-workspace-alive nil)
    ;; DAP
    (lsp-enable-dap-auto-configure nil)
    ;; UI
    (lsp-enable-links nil)
    (lsp-headerline-breadcrumb-enable nil)
    ;; semantic code features
    (lsp-enable-folding nil)
    (lsp-enable-indentation nil)
    (lsp-enable-semantic-highlighting nil)
    (lsp-enable-symbol-highlighting t)
    ;; completion
    (lsp-completion-show-kind nil)
    ;; lens
    (lsp-lens-enable t)
    (lsp-lens-place-position 'end-of-line)
    ;; rust
    (lsp-rust-clippy-preference "on")
    (lsp-rust-server 'rust-analyzer))
#+end_src

**** LSP UI
User interface package for LSP.
This package provides documentation popup, definitions in split-view, imenu list, e.t.c.

#+begin_src emacs-lisp
  (use-package lsp-ui
    :after lsp-mode
    :commands lsp-ui-mode
    :bind (:map lsp-ui-mode-map
           ("M-." . lsp-ui-peek-find-definitions)
           ("M-S-." . lsp-ui-peek-find-references))
    :custom
    (lsp-ui-doc-border (face-attribute 'window-divider :foreground))
    (lsp-ui-sideline-enable nil)
    (lsp-ui-doc-enable nil)
    (lsp-ui-imenu-enable t)
    (lsp-ui-doc-delay 2 "higher than eldoc delay")
    (lsp-ui-doc-max-width 1000)
    (lsp-ui-doc-show-with-cursor nil)
    (lsp-ui-doc-show-with-mouse t)
    (lsp-ui-doc-position 'at-point)
    (lsp-ui-doc-enhanced-markdown nil)
    :custom-face
    (lsp-ui-peek-highlight ((t (:foreground unspecified
                                :background unspecified
                                :box unspecified
                                :inherit lsp-face-highlight-textual))))
    :config
    (when (fboundp #'aorst/escape)
      (define-advice lsp-ui-doc--make-request (:around (foo) aorst:hide-lsp-ui-doc)
        (unless (eq this-command 'aorst/escape)
          (funcall foo))))
    (lsp-ui-mode))
#+end_src

**** LSP Java
Java language server requires JDK 11 to run, so this package is only loaded when JDK 11 is available.
Note that path to java may differ on different systems.

#+begin_src emacs-lisp
  (use-package lsp-java
    :when (file-exists-p "/usr/lib/jvm/java-11-openjdk/bin/java")
    :custom (lsp-java-java-path "/usr/lib/jvm/java-11-openjdk/bin/java"))
#+end_src

**** LSP Treemacs
Side panel explorer for LSP based on Treemacs.

#+begin_src emacs-lisp
  (use-package lsp-treemacs
    :custom
    (lsp-treemacs-theme "Iconless"))
#+end_src

*** Project
Tweaks to inbuilt project management mode.

#+begin_src emacs-lisp
  (use-package project
    :straight nil
    :config
    (defvar aorst--project-root-markers
      '("Cargo.toml" "compile_commands.json" "compile_flags.txt" "project.clj" ".git" "deps.edn")
      "Files or directories that indicate the root of a project.")
    (defun aorst/project-find-root (path)
      "Recursive search in PATH for root markers."
      (let ((this-dir (file-name-as-directory (file-truename path))))
        (cond
         ((aorst/project-root-p this-dir) (cons 'transient this-dir))
         ((equal "/" this-dir) nil)
         (t (aorst/project-find-root (concat this-dir "../"))))))
    (defun aorst/project-root-p (path)
      "Check if current PATH has any of project root markers."
      (memq t (mapcar (lambda (file)
                        (file-exists-p (concat path file)))
                      aorst--project-root-markers)))
    (add-to-list 'project-find-functions #'aorst/project-find-root))
#+end_src

*** Clang Format
A package to format C code with Clang Format.

#+begin_src emacs-lisp
  (use-package clang-format
    :after cc-mode
    :bind (:map c-mode-base-map
           ("C-c C-M-f" . clang-format-buffer)))
#+end_src

*** Server
Start Emacs server if none running already.
Clients will connect to this server to reuse frame.

#+begin_src emacs-lisp
  (use-package server
    :straight nil
    :config
    (unless (server-running-p)
      (server-start)))
#+end_src

We need the =.desktop= file that uses the advantage of possibly running server:

#+begin_src conf-desktop :tangle "~/.local/share/applications/emacs.desktop" :mkdirp yes
  [Desktop Entry]
  Name=Emacs
  GenericName=Text Editor
  Comment=Edit text
  MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
  Exec=sh -c 'if [ -n "$*" ]; then exec emacsclient -a emacs -n --display="$DISPLAY" "$@"; else exec emacs; fi' dummy %F
  Icon=emacs
  Type=Application
  Terminal=false
  Categories=Development;TextEditor;
  StartupNotify=true
  StartupWMClass=Emacs
  Keywords=Text;Editor;
  Actions=new-window;new-instance;

  [Desktop Action new-window]
  Name=New Window
  Exec=emacsclient --alternate-editor= --create-frame %F

  [Desktop Action new-instance]
  Name=New Instance
  Exec=emacs %F
#+end_src

This will allow us to open files with =emacs-launcher=, and it will automatically reuse existing window if present.
Precisely what it does is:

- call =emacs= if no arguments provided, or
- call =emacsclient -a emacs= with arguments.
  =emacsclient= will try to connect to a server, and if there's none, it will fire up =emacs= which will create server, and opening new files will be done in this instance of =emacs=.

With this file we should be able to launch Emacs from the file context menu, or whit "open with" sub menu, and it will reuse existing window if present.

*** Hideshow
This inbuilt mode provides code folding.

#+begin_src emacs-lisp
  (use-package hideshow
    :straight nil
    :requires hydra
    :hook (prog-mode . hs-minor-mode)
    :bind (:map prog-mode-map
           ("C-c h" . hydrant/hideshow-menu/body))
    :config
    (defhydra hydrant/hideshow-menu (:color pink :hint nil)
      "
   ^Hide^       ^Show^       ^Exit^
   _ha_: all    _sa_: all    _qs_: quit show all
   _hb_: block  _sb_: block  _qh_: quit hide all"
      ("ha" hs-hide-all)
      ("hb" hs-hide-block)
      ("sa" hs-show-all)
      ("sb" hs-show-block)
      ("qs" hs-show-all :exit t)
      ("qh" hs-hide-all :exit t)
      ("C-g" ignore :exit t)))
#+end_src

*** Edit Indirect
This package makes it possible to edit Markdown code blocks in separate buffers.

#+begin_src emacs-lisp
  (use-package edit-indirect
    :hook ((edit-indirect-after-creation . aorst/edit-indirect-header-line-setup))
    :bind (:map edit-indirect-mode-map
           ("C-c C-c" . edit-indirect-commit)
           ("C-c C-k" . edit-indirect-abort)
           ("C-c '" . nil))
    :config
    (defun aorst/edit-indirect-header-line-setup ()
      (setq-local
       header-line-format
       (substitute-command-keys
        "\\<edit-indirect-mode-map>Edit, then exit with `\\[edit-indirect-commit]' or abort with `\\[edit-indirect-abort]'"))))
#+end_src

*** Separedit
This package provides a way to edit comments in sources as separate buffers with another major mode, like Markdown.
Additionally it provides string escaping, when editing nested strings.

#+begin_src emacs-lisp
  (use-package separedit
    :hook (separedit-buffer-creation . aorst/separedit-header-line-setup)
    :bind (:map prog-mode-map
           ("C-c '" . separedit)
           :map edit-indirect-mode-map
           ("C-c '" . separedit))
    :custom
    (separedit-default-mode 'gfm-mode)
    :config
    (defun aorst/separedit-header-line-setup ()
      (setq-local
       header-line-format
       (substitute-command-keys
        "\\<edit-indirect-mode-map>Edit, then exit with `\\[separedit-commit]' or abort with `\\[edit-indirect-abort]'"))))
#+end_src

*** Recent files
Settings to =recentf= mode.

#+begin_src emacs-lisp
  (use-package recentf
    :straight nil
    :config
    (add-to-list 'recentf-exclude "\\.gpg\\")
    (recentf-mode))
#+end_src

*** Dumb Jump
Dumbest definition jumping that just work.

#+begin_src emacs-lisp
  (use-package dumb-jump
    :custom
    (dumb-jump-prefer-searcher 'rg)
    (dumb-jump-selector 'ivy)
    :config
    (add-to-list 'xref-backend-functions #'dumb-jump-xref-activate))
#+end_src

*** Which Key
A useful package that displays all keybindings available for the chord you're entering after a certain delay.

#+begin_src emacs-lisp
  (use-package which-key
    :config (which-key-mode t))
#+end_src

*** GCMH
Garbage Collector Magic Hack.
Runs GC when Emacs is idle, and increases GC threshold during active use.

#+begin_src emacs-lisp
  (use-package gcmh
    :config (gcmh-mode t))
#+end_src

*** Parens
Some tweaks to inbuilt parenthesis highlighting mode.

#+begin_src emacs-lisp
  (use-package paren
    :straight nil
    :custom
    (show-paren-when-point-in-periphery t)
    (show-paren-delay 0))
#+end_src

*** Writable Grep
This package provides a way of editing grep buffer and applying edits to the files.
Extremely useful with ivy-occur.

#+begin_src emacs-lisp
  (use-package wgrep)
#+end_src

*** Xref
Workaround for a problem with Treemacs and marker stack: [[https://github.com/Alexander-Miller/treemacs/issues/734][Alexander-Miller/treemacs#734]].

#+begin_src emacs-lisp
  (use-package xref
    :straight nil
    :config
    (when (featurep 'treemacs)
      (define-advice xref-push-marker-stack (:around (fn &optional m) aorst:remove-treemacs-from-xref-marker-stack)
        (let ((m (or m (point-marker))))
          (when (buffer-local-value 'treemacs--in-this-buffer (marker-buffer m))
            (with-current-buffer (window-buffer (next-window (selected-window) nil nil))
              (setf m (point-marker))))
          (funcall fn m)))))
#+end_src

*** VC mode
Tweaks for inbuilt VC mode.

#+begin_src emacs-lisp
  (use-package vc-hooks
    :straight nil
    :custom (vc-follow-symlinks t))
#+end_src

*** Quail
Hide quail buffers from buffer menu.

#+begin_src emacs-lisp
  (use-package quail
    :straight nil
    :config
    (defun aorst/hide-quail-buffer ()
      "Hide Quail buffer."
      (with-current-buffer quail-completion-buf
        (when (string= "*Quail Completions*" (buffer-name))
          (rename-buffer " *Quail Completions*"))))
    (define-advice quail-setup-completion-buf (:after () aorst:hide-quail-buffer)
      (aorst/hide-quail-buffer)))
#+end_src

*** ISAYT
Indent S-expressions as you type.

#+begin_src emacs-lisp
  (use-package isayt
    :straight (:host gitlab
               :repo "andreyorst/isayt.el"
               :branch "main")
    :hook (smartparens-strict-mode . isayt-mode))
#+end_src

*** Eldoc
Eldoc tweaks.

#+begin_src emacs-lisp
  (use-package eldoc
    :straight nil
    :custom (eldoc-echo-area-use-multiline-p nil))
#+end_src

*** Auto revert mode
Watch files and update buffer contents if files changed on disk.

#+begin_src emacs-lisp
  (use-package autorevert
    :straight nil
    :hook (after-init . global-auto-revert-mode))
#+end_src

*** HL TODO
Highlight =TODO= markers in files.
Great addition to [[*Magit TODOs][Magit TODOs]].

#+begin_src emacs-lisp
  (use-package hl-todo
    :hook (prog-mode . hl-todo-mode))
#+end_src

*** Outline
Simple hydrant for =outline-minor-mode=.

#+begin_src emacs-lisp
  (use-package outline
    :straight nil
    :bind (("C-c o" . hydrant/outline-menu/body))
    :requires hydra
    :config
    (defhydra hydrant/outline-menu (:color pink :hint nil)
      "
   ^Hide^       ^Show^        ^Move^
   _ho_: other  _sa_: all     _n_: next
   ^  ^         _t_:  toggle  _p_: previous"
      ("ho" outline-hide-other)
      ("sa" outline-show-all)
      ("t" outline-cycle)
      ("n" outline-next-heading)
      ("p" outline-previous-heading)
      ("C-g" ignore :exit t)))
#+end_src

*** Paren-face
Dims parentheses a bit, making those less in your face.

#+begin_src emacs-lisp
  (use-package paren-face
    :hook ((clojure-mode
            emacs-lisp-mode
            common-lisp-mode
            scheme-mode
            lisp-mode
            racket-mode
            fennel-mode
            cider-repl-mode
            racket-repl-mode
            geiser-repl-mode
            inferior-lisp-mode
            inferior-emacs-lisp-mode)
           . paren-face-mode)
    :custom (paren-face-regexp "[][(){}]"))
#+end_src

*** Jdecomp
Java bytecode decompiler support for viewing =.class= files.

#+begin_src emacs-lisp
  (use-package jdecomp
    :when (file-exists-p (expand-file-name "~/.local/bin/fernflower.jar"))
    :hook (archive-mode . jdecomp-mode)
    :custom
    (jdecomp-decompiler-type 'fernflower)
    (jdecomp-decompiler-paths '((fernflower . "~/.local/bin/fernflower.jar"))))
#+end_src

*** Profiler
Hydrant for quick access to the Emacs profiling functions:

#+begin_src emacs-lisp
  (use-package profiler
    :straight nil
    :requires hydra
    :config
    (defhydra hydrant/profiler-menu (:color pink :hint nil)
        "
   ^Start^    ^Stop/Report^
   _c_: CPU   _s_: stop
   _m_: MEM   _r_: report
   _b_: both  ^ ^
   "
        ("c" (lambda () (interactive) (profiler-start 'cpu)))
        ("m" (lambda () (interactive) (profiler-start 'mem)))
        ("b" (lambda () (interactive) (profiler-start 'cpu+mem)))
        ("s" profiler-stop)
        ("r" profiler-report)
        ("C-g" ignore :exit t)))
#+end_src

*** Scroll on jump
This package adds smooth scrolling on events that usually make Emacs jump around.
With smooth scrolling it is much easier to see where the text actually moved.

#+begin_src emacs-lisp
  (use-package scroll-on-jump
    :custom
    (scroll-on-jump-smooth nil)
    (scroll-on-jump-duration 0.1337)
    :config
    (scroll-on-jump-advice-add beginning-of-buffer)
    (scroll-on-jump-advice-add end-of-buffer)
    (scroll-on-jump-advice-add flyspell-goto-next-error)
    (when (featurep 'smartparens)
      (define-key smartparens-mode-map
        (kbd "C-M-f") (scroll-on-jump-interactive 'sp-forward-sexp))
      (define-key smartparens-mode-map
        (kbd "C-M-b") (scroll-on-jump-interactive 'sp-backward-sexp)))
    (scroll-on-jump-with-scroll-advice-add scroll-up-command)
    (scroll-on-jump-with-scroll-advice-add scroll-down-command)
    (scroll-on-jump-with-scroll-advice-add isearch-update)
    (scroll-on-jump-with-scroll-advice-add recenter-top-bottom))
#+end_src

*** Reverse IM
Reverses input method to allow shortcuts to be layout agnostic.

#+begin_src emacs-lisp
  (use-package reverse-im
    :custom
    (reverse-im-input-methods '("russian-computer"))
    :config
    (reverse-im-mode t))
#+end_src

*** Compile
Tweaks to inbuilt =compile.el= mode.

#+begin_src emacs-lisp
  (use-package compile
    :straight nil
    :custom
    (compilation-scroll-output 'first-error))
#+end_src

*** Isearch
Tweaks to inbuilt incremental search mode.

#+begin_src emacs-lisp
  (use-package isearch
    :straight nil
    :bind (:map isearch-mode-map
           ("<backspace>" . isearch-del-char)))
#+end_src

*** Eshell
Emacs shell settings.
Eshell is a shell implemented in Emacs Lisp, that (in theory) works the same across all systems.

#+begin_src emacs-lisp
  (use-package esh-mode
    :straight nil
    :custom (eshell-scroll-show-maximum-output nil))
#+end_src

** =(provide 'init)=
This concludes the =init.el= file.

#  LocalWords:  init el startup GC unstyled UI Resizing resized ELPA
#  LocalWords:  MELPA uncomment Makefile Readline Kakoune whitespace
#  LocalWords:  Solaire DOOM's fallbacks doto Clojure Tooltips DejaVu
#  LocalWords:  tooltips Treemacs Flycheck modeline minibuffer config
#  LocalWords:  filetree Uniquify Tabline Prog TOML Geiser REPL Cmake
#  LocalWords:  cmake Yaml IDE ClojureScript flycheck clj kondo Kibit
#  LocalWords:  backend refactor refactoring linter Lua CSS Erlang VM
#  LocalWords:  scalable interop JSON vterm Json EditorConfig Paredit
#  LocalWords:  Smartparens Parinfer configs Flx runtime Posframe LSP
#  LocalWords:  posframe frontend Yasnippet Magit TODOs TODO Ediff VC
#  LocalWords:  Kakoune's Iedit DAP Hideshow workspace Separedit GCMH
#  LocalWords:  Parens readonly Flymake autoloaded Smerge popup imenu
#  LocalWords:  JDK Ripgrep ISAYT Eldoc multiline eldoc HL

# Local Variables:
# eval: (add-hook 'after-save-hook #'org-babel-tangle nil t)
# End:
