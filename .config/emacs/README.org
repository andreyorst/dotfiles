#+title: Emacs configuration with Org Mode
#+author: Andrey Listopadov
#+email: andreyorst@gmail.com
#+setupfile: ./.org-defaults.org
#+startup: noinlineimages
#+property: header-args :results silent

* About this document
This is a GNU Emacs configuration file, written as an Org document.
It is meant to be placed in the =user-emacs-directory=, and compiled with =org-babel-tangle=.
As a result =init.el= and =early-init.el= files are created, located in the same directory as this file, as well as some other files across the system.
You can review which files are created by searching for =:tangle= entries in this document.
Both =init.el= and =early-init.el= are in read only mode by default, and only this file is meant for editing, and the changes are automatically tangled on save.

* =early-init.el=
:properties:
:header-args+: :tangle "./early-init.el"
:end:
Emacs 27 introduced new initialization file called =earli-init.el=, which is executed before =init.el=.
It is meant to configure package initialization and early graphical interface tweaks, before actually drawing a window.

#+begin_src emacs-lisp
  ;;; early-init.el --- Early initialization -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-

  ;; Author: Andrey Listopadov
  ;; Keywords: literate programming, Emacs configuration
  ;; Homepage: https://gitlab.com/andreyorst/dotfiles/-/tree/master/.config/emacs

  ;;; Commentary:
  ;; Emacs config.
  ;; This file was automatically generated by `org-babel-tangle'.
  ;; Do not change this file.  Main config is located in README.org at `user-emacs-directory'

  ;;; Code:
#+end_src

** Garbage Collection and Performance
One of the main reasons why Emacs startup time is big is that the garbage collection is invoked a lot, causing the increase of the startup time.
This can be migrated by setting high GC threshold and restoring it back in =after-init-hook=.

#+begin_src emacs-lisp
  (defvar aorst--gc-cons-threshold gc-cons-threshold)
  (defvar aorst--gc-cons-percentage gc-cons-percentage)
  (defvar aorst--file-name-handler-alist file-name-handler-alist)

  (setq-default gc-cons-threshold 402653184
                gc-cons-percentage 0.6
                file-name-handler-alist nil)

  (defun aorst/restore-defaults-after-init ()
    "Restore default values after initialization."
    (setq-default gc-cons-threshold aorst--gc-cons-threshold
                  gc-cons-percentage aorst--gc-cons-percentage
                  file-name-handler-alist aorst--file-name-handler-alist))

  (add-hook 'after-init-hook #'aorst/restore-defaults-after-init)

  (setq read-process-output-max (* 1024 1024 4) ; 4mb
        inhibit-compacting-font-caches t
        message-log-max 16384)
#+end_src

** Native Compiled Emacs Lisp
Emacs 28 can compile Emacs Lisp to native code.
These settings enable background asynchronous compilation, and dynamic reloading of compiled modules.

#+begin_src emacs-lisp
  (when (featurep 'native-compile)
    (setq native-comp-deferred-compilation t)
    (setq native-comp-async-report-warnings-errors nil))
#+end_src

** User Interface
This code sets default size of the frame and prevents the glimpse of unstyled Emacs by disabling some UI elements early.
Resizing frame is also expensive, and setting =x-gtk-resize-child-frames= variable to =resize-mode= is a workaround for the [[https://gitlab.gnome.org/GNOME/mutter/-/issues/840][issue]] with child frames not being resized correctly under Mutter.

#+begin_src emacs-lisp
  (setq-default initial-frame-alist '((width . 170)
                                      (height . 56)
                                      (tool-bar-lines . 0)
                                      (bottom-divider-width . 0)
                                      (right-divider-width . 1))
                default-frame-alist initial-frame-alist
                frame-inhibit-implied-resize t
                x-gtk-resize-child-frames 'resize-mode
                fringe-indicator-alist (assq-delete-all 'truncation fringe-indicator-alist))
#+end_src

** =straight.el=
Straight is an alternative way to manage package installations.
It can install packages from Git repositories listed on ELPA, MELPA, and directly from Git URLs.

#+begin_src emacs-lisp
  (defvar straight-process-buffer)
  (setq-default straight-process-buffer " *straight-process*")

  (defvar straight-build-dir)
  (setq straight-build-dir (format "build-%s" emacs-version))

  (defvar bootstrap-version)
  (let ((bootstrap-file
	 (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	(bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
	  (url-retrieve-synchronously
	   "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	   'silent 'inhibit-cookies)
	(goto-char (point-max))
	(eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

** early =package.el= settings
=package.el= initialization is expensive, thus should be disabled before loading main init file:

#+begin_src emacs-lisp
  (setq package-enable-at-startup nil)
#+end_src

** Loading of elisp files
Prefer loading newer files to the byte-compiled ones that have older time-stamp when running non-interactively to prevent the use of stale byte-code.
Saves us a little IO time to skip the mtime checks on every =*.elc= file.

#+begin_src emacs-lisp
  (setq load-prefer-newer noninteractive)
#+end_src

** =(provide 'early-init)=
This concludes the =early-init.el= file.

#+begin_src emacs-lisp
  (provide 'early-init)
  ;;; early-init.el ends here
#+end_src

* =init.el=
:properties:
:header-args+: :tangle "./init.el"
:end:
Main GNU Emacs init file.

#+begin_src emacs-lisp
  ;;; init.el --- Emacs main configuration file -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-

  ;; Author: Andrey Listopadov
  ;; Keywords: literate programming, Emacs configuration
  ;; Homepage: https://gitlab.com/andreyorst/dotfiles/-/tree/master/.config/emacs

  ;;; Commentary:
  ;; Emacs config.
  ;; This file was automatically generated by `org-babel-tangle'.
  ;; Do not change this file.  Main config is located in README.org at `user-emacs-directory'

  ;;; Code:
#+end_src

** Loading =early-init.el= in Emacs 26 and earlier
When using pre Emacs 27 =eraly-init.el= must be loaded manually before anything from =init.el=.

#+begin_src emacs-lisp
  (unless (featurep 'early-init)
    (load (expand-file-name "early-init" user-emacs-directory)))
#+end_src

** Defaults
Section with configurations that need to be done early enough or hard to categorize.

*** =use-package=
A macro for managing installed packages, and encapsulating their configurations.

#+begin_src emacs-lisp
  (straight-use-package 'use-package)
  (defvar straight-use-package-by-default)
  (setq straight-use-package-by-default t)
  (require 'use-package)
#+end_src

*** Custom File and Disabled Commands
Emacs customization system writes to =init.el= by default which is not great when using tangle approach.
To preserve custom modifications it is moved to a separate file.

#+begin_src emacs-lisp
  (use-package cus-edit
    :straight nil
    :custom (custom-file (expand-file-name "custom.el" user-emacs-directory))
    :init (load custom-file :noerror))
#+end_src

Same thing with disabled commands.

#+begin_src emacs-lisp
  (defvar aorst--disabled-commands (expand-file-name "disabled.el" user-emacs-directory)
    "File to store disabled commands, that were enabled permamently.")

  (define-advice enable-command (:around (foo command) aorst:put-in-custom-file)
    (let ((user-init-file aorst--disabled-commands))
      (funcall foo command)))

  (load aorst--disabled-commands :noerror)
#+end_src

*** Personal custom group
Group for custom, which provides a way of persisting options without needing to use concrete values in this config directly.
Can be used for creating machine local configurations.

#+begin_src emacs-lisp
  (defgroup local-config nil
    "Customization group for local settings."
    :prefix "local-config-")
#+end_src

*** User Credentials
Some modes can use full name and e-mail address automatically.

#+begin_src emacs-lisp
  (use-package startup
    :straight nil
    :no-require t
    :custom
    (user-mail-address "andreyorst@gmail.com")
    (user-full-name "Andrey Listopadov"))
#+end_src

*** Bell
No bell.

#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
#+end_src

*** Backups
Backup files and auto-save files are kept within =.cache= directory located at =user-emacs-direcotry=.

#+begin_src emacs-lisp
  (use-package files
    :straight nil
    :custom
    (backup-by-copying t)
    (create-lockfiles nil)
    (backup-directory-alist
     `(("." . ,(expand-file-name ".cache/backups" user-emacs-directory))))
    (auto-save-file-name-transforms
     `((".*" ,(expand-file-name ".cache/auto-save/" user-emacs-directory) t)))
    (auto-save-no-message t)
    (auto-save-interval 100)
    :config
    (let ((auto-save-dir (expand-file-name ".cache/auto-save/" user-emacs-directory)))
      (unless (file-exists-p auto-save-dir)
        (make-directory auto-save-dir t))))
#+end_src

*** Yes or No
Prompt for =y= or =n= instead of =yes= or =no=.

#+begin_src emacs-lisp
  (use-package subr
    :straight nil
    :no-require t
    :init
    (fset 'yes-or-no-p 'y-or-n-p))
#+end_src

*** Mouse and Scrolling
Disabling menu popup on shift clicks, scroll acceleration, hover highlighting, and enabling mouse support in terminal.
Also advising =scroll-left= to prevent over-scrolling past the visible part of the text (prevents further scrolling when longest line end is /visible/).

#+begin_src emacs-lisp
  (use-package mwheel
    :straight nil
    :demand
    :bind (("S-<down-mouse-1>" . nil)
           ("S-<mouse-3>" . nil)
           ("<mouse-4>" . mwheel-scroll)
           ("<mouse-5>" . mwheel-scroll))
    :custom
    (mouse-wheel-flip-direction t)
    (mouse-wheel-tilt-scroll t)
    (mouse-wheel-progressive-speed nil)
    :config
    (global-set-key (kbd "<mouse-3>") menu-bar-edit-menu)
    (defun aorst/truncated-lines-p ()
      "Non-nil if any line is longer than `window-width' + `window-hscroll'.
  Returns t if any line exceeds right border of the window.  Used
  for stopping scroll from going beyond the longest line.  Based on
  `so-long-detected-long-line-p'."
      (save-excursion
        (goto-char (point-min))
        (let* ((window-width
                ;; this computes a more accurate width rather than `window-width', and respects
                ;; `text-scale-mode' font width.
                (/ (window-body-width nil t) (window-font-width)))
               (hscroll-offset
                ;; `window-hscroll' returns columns that are not affected by `text-scale-mode'.
                ;; Because of that we have to recompute correct `window-hscroll' by multiplying
                ;; it with a non-scaled value, and divide with scaled width value, and round it
                ;; to upper boundary.  Since there's no way to get unscaled value, we have to
                ;; get a width of a face that is not scaled by `text-scale-mode', such as
                ;; `window-divider' face.
                (ceiling (/ (* (window-hscroll) (window-font-width nil 'window-divider))
                            (float (window-font-width)))))
               (line-number-width
                ;; compensate line numbers width
                (if (bound-and-true-p display-line-numbers-mode)
                    (- display-line-numbers-width)
                  0))
               ;; subtracting 2 for extra space in case some calculations were imprecise
               (threshold (+ window-width hscroll-offset line-number-width -2)))
          (catch 'excessive
            (while (not (eobp))
              (setq start (point))
              (save-restriction
                (narrow-to-region start (min (+ start 1 threshold)
                                             (point-max)))
                (forward-line 1))
              (unless (or (bolp)
                          (and (eobp) (<= (- (point) start)
                                          threshold)))
                (throw 'excessive t)))))))
    (define-advice scroll-left (:around (foo &optional arg set-minimum) aorst:scroll-left)
      (when (and truncate-lines
                 (not (memq major-mode '(vterm-mode term-mode)))
                 (aorst/truncated-lines-p))
        (funcall foo arg set-minimum)))
    (setq-default auto-window-vscroll nil
                  mouse-highlight nil
                  hscroll-step 1
                  hscroll-margin 1
                  scroll-margin 1
                  scroll-preserve-screen-position nil)
    (unless (display-graphic-p)
      (xterm-mouse-mode t)))
#+end_src

*** Tab character
Tab character is rarely a mandatory, and only a small selection of tools require it (e.g. Makefile).

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

*** History
Preserve history between sessions.

#+begin_src emacs-lisp
  (use-package savehist
    :straight nil
    :config (savehist-mode 1))
#+end_src

*** Keyboard Layout
This configures two keyboard layouts: =qwerty= and =йцукен=, which can be toggled inside Emacs with =C-\= to keep chords like =C-x= work independently of the active layout.

#+begin_src emacs-lisp
  (use-package mule-cmds
    :straight nil
    :no-require t
    :custom
    (default-input-method 'russian-computer))
#+end_src

*** UTF8
=UTF8= should be preferred.

#+begin_src emacs-lisp
  (prefer-coding-system 'utf-8)
  (when (display-graphic-p)
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src

*** Default Major Mode
Lisp interaction mode adds a bit of startup time, and is rarely needed.

#+begin_src emacs-lisp
  (use-package startup
    :straight nil
    :no-require t
    :custom
    (initial-major-mode 'fundamental-mode)
    (initial-scratch-message ""))
#+end_src

*** Simple
Configurations for inbuilt =simple.el= module.
=Zap-up-to-char= and =zap-to-char= are swapped because of personal preference.
This also changes =C-g= to quit current action regardless of active window.

#+begin_src emacs-lisp
  (use-package simple
    :straight nil
    :bind (("M-z" . zap-up-to-char)
           ("M-S-z" . zap-to-char)
           ("C-x k" . kill-this-buffer)
           ("C-h C-f" . describe-face)
           ("<f2>" . ignore))
    :hook ((before-save . delete-trailing-whitespace)
           (overwrite-mode . aorst/overwrite-set-cursor-shape))
    :custom
    (yank-excluded-properties t)
    (blink-matching-delay 0)
    (blink-matching-paren t)
    :config
    (defun aorst/overwrite-set-cursor-shape ()
      (when (display-graphic-p)
        (setq cursor-type (if overwrite-mode 'hollow 'box))))
    :init
    (column-number-mode 1)
    (line-number-mode 1)
    (transient-mark-mode -1)
    (define-advice keyboard-quit (:around (quit) aorst:keyboard-quit)
      "Quit in current context.

  When there is an active minibuffer and we are not inside it close
  it.  When we are inside the minibuffer use the regular
  `minibuffer-keyboard-quit' which quits any active region before
  exiting.  When there is no minibuffer `keyboard-quit' unless we
  are defining or executing a macro."
      (cond ((active-minibuffer-window)
             (if (minibufferp)
                 (minibuffer-keyboard-quit)
               (abort-recursive-edit)))
            (t
             (unless (or defining-kbd-macro
                         executing-kbd-macro)
               (funcall quit))))))
#+end_src

*** Selection
Delete selection by typing.

#+begin_src emacs-lisp
  (use-package delsel
    :straight nil
    :init
    (delete-selection-mode t))
#+end_src

*** Line truncation
Disables line wrapping.

#+begin_src emacs-lisp
  (setq-default truncate-lines t)
  (setq-default bidi-paragraph-direction 'left-to-right)

  (when (version<= "27.1" emacs-version)
    (setq bidi-inhibit-bpa t))
#+end_src

*** Minibuffer
Disabling clicks in minibuffer, to prevent opening =*Messages*= buffer.
Also changing completion styles for a more fast completion feedback, with the downside of a bit more strict matching.

#+begin_src emacs-lisp
  (use-package minibuffer
    :straight nil
    :bind (:map minibuffer-inactive-mode-map
           ("<mouse-1>" . ignore))
    :custom
    (completion-styles '(partial-completion basic))
    (read-buffer-completion-ignore-case t)
    (read-file-name-completion-ignore-case t)
    :custom-face
    (completions-first-difference ((t (:inherit unspecified)))))
#+end_src

*** Form feed
Render =^L= as continuous comment or dashed line.

#+begin_src emacs-lisp
  (defun aorst/formfeed-line ()
    "Display the formfeed ^L char as comment or as continuous line."
    (unless buffer-display-table
      (setq buffer-display-table (make-display-table)))
    (aset buffer-display-table ?\^L
          (vconcat (make-list (or fill-column 70)
                              (make-glyph-code
                               (string-to-char (or comment-start "-"))
                               'shadow)))))

  (dolist (mode-hook '(help-mode-hook
                       org-mode-hook
                       outline-mode-hook
                       prog-mode-hook))
    (add-hook mode-hook #'aorst/formfeed-line))
#+end_src

*** Window
Binding for =bury-buffer= command.

#+begin_src emacs-lisp
  (use-package window
    :straight nil
    :bind ("C-x C-b" . bury-buffer))
#+end_src

** Functions
This section describes additional functions for internal use in configurations of various packages, that are general enough.
All functions and variables are prefixed with =aorst/= and =aorst--= respectively to prevent conflicts.

*** =font-installed-p=
Checks if font is available on the system.

#+begin_src emacs-lisp
  (defun aorst/font-installed-p (font-name)
    "Check if font with FONT-NAME is available."
    (find-font (font-spec :name font-name)))
#+end_src

*** =split-paragraph-into-lines=
Format paragraph by following one sentence per line style of editing.

#+begin_src emacs-lisp
  (defun aorst/split-pararagraph-into-lines ()
    "Split current paragraph into lines with one sentence each."
    (interactive)
    (save-excursion
      (let ((fill-column most-positive-fixnum))
        (fill-paragraph))
      (let ((auto-fill-p auto-fill-function)
            (end (progn (end-of-line) (backward-sentence) (point))))
        (back-to-indentation)
        (unless (= (point) end)
          (auto-fill-mode -1)
          (while (< (point) end)
            (forward-sentence)
            (delete-horizontal-space)
            (newline-and-indent))
          (deactivate-mark)
          (when auto-fill-p
            (auto-fill-mode t))
          (when (looking-at "^$")
            (backward-delete-char 1))))))
#+end_src

*** =dark-mode-p=
Shorter predicate for dark mode check:

#+begin_src emacs-lisp
  (defun aorst/dark-mode-p ()
    "Check if frame is dark or not."
    (if (and window-system
             (executable-find "gsettings"))
        (thread-last "gsettings get org.gnome.desktop.interface gtk-theme"
          shell-command-to-string
          string-trim-right
          (string-suffix-p "-dark'"))
      (eq 'dark (frame-parameter nil 'background-mode))))
#+end_src

*** =termuxp=
[[https://termux.com/][Termux]] is an Android terminal emulator and Linux environment app that works directly with no rooting or setup required.
Emacs runs well in Termux, though some features may be missing, due to older version.

#+begin_src emacs-lisp
  (defun aorst/termuxp ()
    "Detect if Emacs is running in Termux."
    (executable-find "termux-info"))
#+end_src

*** =create-accent-face=
Creates a slight variation of a face, by blending =ref-face= background color with foreground color.
It is used to create refine faces for diffs.
Depends on DOOM's =doom-blend= function, and if it is not available, it fallbacks to =inverse-video= method, which is used by default for refine face anyways.

#+begin_src emacs-lisp
  (defun aorst/create-accent-face (face ref-face)
    "Set FACE background to accent color by blending REF-FACE foreground and background.
  Depends on `doom-blend'."
    (let ((fg (face-attribute ref-face :foreground nil t))
          (bg (face-attribute ref-face :background nil t)))
      (if (and (stringp fg)
               (stringp bg)
               (fboundp #'doom-blend))
          (set-face-attribute face nil
                              :foreground fg
                              :distant-foreground fg
                              :weight 'bold
                              :background (if (aorst/dark-mode-p)
                                              (doom-blend bg fg 0.8)
                                            (doom-blend bg fg 0.9))
                              :inherit nil
                              :extend t
                              :inverse-video nil)
        (set-face-attribute face nil
                            :foreground nil
                            :distant-foreground nil
                            :background nil
                            :weight 'bold
                            :inherit ref-face
                            :extend t
                            :inverse-video t))))
#+end_src

*** =minibuffer-defer-garbage-collection=
When minibuffer pops up, the garbage collection is deferred for more optimal filtering performance.

#+begin_src emacs-lisp
  (defun aorst/minibuffer-defer-garbage-collection ()
    "Defer garbage collection for minibuffer"
    (setq gc-cons-threshold most-positive-fixnum))

  (defun aorst/minibuffer-restore-garbage-collection ()
    "Resotre garbage collection settings."
    (run-at-time
     1 nil (lambda () (setq gc-cons-threshold aorst--gc-cons-threshold))))
#+end_src

** User Interface
Packages that affect user interface.

*** Splash Screen
Disable splash screen.

#+begin_src emacs-lisp
  (use-package startup
    :straight nil
    :no-require t
    :custom
    (inhibit-splash-screen t))
#+end_src

*** Menu bar
Menu bar is organized in trees and is handy when working with new packages.
However in terminal Emacs it is completely useless.

#+begin_src emacs-lisp
  (use-package menu-bar
    :straight nil
    :unless (display-graphic-p)
    :config
    (menu-bar-mode -1))
#+end_src

*** Line height
When =text-scale-mode= is active it's hard to tell what line height actually is.
This variable helps calculating that reliably.

#+begin_src emacs-lisp
  (defvar aorst--line-pixel-height (line-pixel-height)
    "Line height in pixels.
  Used in various places to avoid getting wrong line height when
  `text-scale-mode' is active.")
#+end_src

*** Menus, Tooltips, Scroll bars
Tooltips should be handled with Emacs, not with GTK.
Scrollbars and toolbar are disabled.

#+begin_src emacs-lisp
  (when window-system
    (setq-default x-gtk-use-system-tooltips nil)
    (setq-default tooltip-x-offset 0)
    (setq-default tooltip-y-offset aorst--line-pixel-height)
    (setq-default tooltip-frame-parameters
                  `((name . "tooltip")
                    (internal-border-width . 2)
                    (border-width . 1)
                    (no-special-glyphs . t)))
    (scroll-bar-mode -1)
    (tool-bar-mode -1))
#+end_src

*** Cursor Type
When using graphical Emacs, a more traditional bar cursor is used, and shown only in the active window.

#+begin_src emacs-lisp
  (when window-system
    (setq-default cursor-type 'box
                  cursor-in-non-selected-windows nil))
#+end_src

*** Font
[[https://www.jetbrains.com/lp/mono/][JetBrains Mono]] font has nice support for ligatures, and overall looks great, supporting a lot of languages and styles like *bold*, /italics/ for not only Latin languages.
If neither =JetBrainsMono= is not found =Source Code Pro= is used as a fallback.

#+begin_src emacs-lisp
  (cond ((aorst/font-installed-p "JetBrainsMono")
         (set-face-attribute 'default nil :font "JetBrainsMono 10"))
        ((aorst/font-installed-p "Source Code Pro")
         (set-face-attribute 'default nil :font "Source Code Pro 10")))
#+end_src

For variable pitched fonts DejaVu font is used if available.

#+begin_src emacs-lisp
  (when (aorst/font-installed-p "DejaVu Sans")
    (set-face-attribute 'variable-pitch nil :font "DejaVu Sans 10"))
#+end_src

*** Theme
=doom-themes= package is a theme collection, originally developed for [[https://github.com/hlissner/doom-emacs][DOOM Emacs]].
Provided themes define colors for pretty much every popular Emacs package, which helps make Emacs look very consistent.

#+begin_src emacs-lisp
  (defcustom aorst--dark-theme 'doom-spacegrey
    "Dark theme to use."
    :tag "Dark theme"
    :type 'symbol
    :group 'local-config)

  (defcustom aorst--light-theme 'doom-one-light
    "Light theme to use."
    :tag "Light theme"
    :type 'symbol
    :group 'local-config)

  (defcustom aorst--termux-theme 'doom-molokai
    "Theme to use in Termux."
    :tag "Termux theme"
    :type 'symbol
    :group 'local-config)

  (use-package doom-themes
    :custom
    (doom-themes-enable-bold t)
    (doom-themes-enable-italic t)
    :custom-face
    (fringe ((t (:background nil))))
    (highlight ((t (:foreground unspecified
                    :distant-foreground unspecified
                    :background unspecified))))
    (secondary-selection ((t (:foreground unspecified
                              :background unspecified
                              :inherit region
                              :extend t))))
    (font-lock-comment-face ((t (:background unspecified))))
    :config
    (cond ((aorst/termuxp)
           (load-theme aorst--termux-theme t))
          ((aorst/dark-mode-p)
           (load-theme aorst--dark-theme t))
          (t
           (load-theme aorst--light-theme t))))
#+end_src

The following code specifies hooks that will run via advice, which in turn runs after =load-theme= function.
It is useful to update some faces that are out of scope of current theme or dynamically changed by me, therefore have to be recalculated.

#+begin_src emacs-lisp
  (defvar aorst--theme-change-hook nil
    "Hook run after a color theme is changed with `load-theme' or `disable-theme'.")

  (defun aorst/run-theme-change-hooks (&rest _)
    "Run theme change hooks."
    (run-hooks 'aorst--theme-change-hook))

  (advice-add 'load-theme :after #'aorst/run-theme-change-hooks)
  (advice-add 'disable-theme :after #'aorst/run-theme-change-hooks)

  (setq-default custom-safe-themes t)
#+end_src

*** Mode-line
Mode-line is displayed at the bottom of each buffer, and shows necessary information about buffer state.
There are several packages that can make the mode-line appear differently, but most will reuse mode-line settings.

#+begin_src emacs-lisp
  (setq mode-line-percent-position nil)

  (dolist (face '(mode-line mode-line-inactive))
    (set-face-attribute face nil
                        :box nil))
#+end_src

*** Title
Display buffer name in the titlebar.

#+begin_src emacs-lisp
  (defcustom aorst--title-show-bufname t
    "Whether to include bufname to titlebar.
  Bufname is not necessary on GNOME, but may be useful in other DEs."
    :type 'boolean
    :group 'local-config)

  (setq-default frame-title-format
                '(:eval (let ((match (string-match "[ *]" (buffer-name))))
                          (if (or (and match (= match 0))
                                  (not aorst--title-show-bufname))
                              "Emacs"
                            "%b — Emacs"))))
#+end_src

*** Uniquify
This package makes files with identical names more distinguishable by adding directory name in the buffer name.

#+begin_src emacs-lisp
  (use-package uniquify
    :straight nil
    :custom (uniquify-buffer-name-style 'forward))
#+end_src

*** Line Numbers
=display-line-numbers= provides line numbers on the left side of the window, which doesn't lag as much as =linum-mode=.

#+begin_src emacs-lisp
  (use-package display-line-numbers
    :straight nil
    :custom
    (display-line-numbers-width 4)
    (display-line-numbers-grow-only t)
    (display-line-numbers-width-start t))
#+end_src

*** Minions
Hide those minor modes.

#+begin_src emacs-lisp
  (use-package minions
    :custom
    (minions-direct '(flycheck-mode flymake-mode))
    :config
    (minions-mode))
#+end_src

** Languages
This section contains various language specific settings and external packages that provide language support.

*** Org Mode
Org Mode is a great mode for taking notes, managing to-do lists, writing books, literate programming, and many other things.

#+begin_src emacs-lisp
  (use-package org
    :straight (:type built-in)
    :hook ((org-capture-mode org-src-mode) . aorst/discard-history)
    :bind (:map org-mode-map
           ("M-Q" . aorst/split-pararagraph-into-lines)
           ("C-c l" . org-store-link))
    :custom-face
    (org-block ((t (:extend t))))
    (org-block-begin-line ((t (:slant unspecified
                               :weight normal
                               :background unspecified
                               :inherit org-block
                               :extend t))))
    (org-block-end-line ((t (:slant unspecified
                             :weight normal
                             :background unspecified
                             :inherit org-block-begin-line
                             :extend t))))
    (org-drawer ((t (:foreground nil :inherit shadow))))
    :custom
    (org-startup-with-inline-images nil)
    (org-tags-column -120)
    (org-startup-folded 'content)
    (org-hide-emphasis-markers nil)
    (org-adapt-indentation nil)
    (org-hide-leading-stars nil)
    (org-highlight-latex-and-related '(latex))
    (org-preview-latex-default-process 'dvisvgm)
    (org-src-fontify-natively t)
    (org-preview-latex-image-directory ".ltximg/")
    (org-confirm-babel-evaluate nil)
    (org-log-done 'time)
    (org-image-actual-width nil)
    :config
    (setq org-format-latex-options
          (plist-put org-format-latex-options
                     :scale
                     (if (executable-find "gsettings")
                         (string-to-number
                          (shell-command-to-string
                           "gsettings get org.gnome.desktop.interface text-scaling-factor"))
                       1.0)))
    (defun aorst/discard-history ()
      "Discard undo history of org src and capture blocks."
      (setq buffer-undo-list nil)
      (set-buffer-modified-p nil))
    (define-advice org-return (:around (f &rest args) aorst:org-return)
      (let ((org-src-preserve-indentation t))
        (apply f args)))
    (define-advice org-cycle (:around (f &rest args) aorst:org-cycle)
      (let ((org-src-preserve-indentation t))
        (apply f args)))
    (defun org-babel-edit-prep:emacs-lisp (_info)
      "Setup Emacs Lisp buffer for Org Babel."
      (setq lexical-binding t)
      (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc))))
#+end_src

Support for using Org export feature with [[https://gohugo.io/][Hugo]] static site generator.

#+begin_src emacs-lisp
  (use-package ox-hugo
    :after ox)
#+end_src

Support of exporting to LaTeX.

#+begin_src emacs-lisp
  (use-package ox-latex
    :straight nil
    :after ox)
#+end_src

Org previously had an inbuilt snippets that started with =<= followed by a letter which expand to various blocks, like source code blocks, quote blocks e.t.c.
It was externalized into separate package in more recent Org mode versions.

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (use-package org-tempo
      :straight nil
      :defines org-version
      :unless (version<= org-version "9.1.9")))
#+end_src

*** Prog Mode
This isn't really a configuration of Prog Mode itself, but some things that change how programming related modes behave.

#+begin_src emacs-lisp
  (use-package prog-mode
    :straight nil
    :bind (:map prog-mode-map
           ("M-q" . aorst/indent-or-fill-sexp))
    :config
    (defun aorst/indent-or-fill-sexp ()
      "Indent s-expression or fill string/comment."
      (interactive)
      (let ((ppss (syntax-ppss)))
        (if (or (nth 3 ppss)
                (nth 4 ppss))
            (fill-paragraph)
          (indent-sexp)))))
#+end_src

*** C/C++
These settings are for editing C source files.

#+begin_src emacs-lisp
  (use-package cc-mode
    :straight nil
    :config (defun aorst/cc-mode-setup ()
              (c-set-offset 'case-label '+)
              (setq c-basic-offset 4
                    c-default-style "linux"
                    comment-start "//"
                    comment-end ""
                    tab-width 4))
    :hook ((c-mode-common . aorst/cc-mode-setup)))
#+end_src

*** Markdown
A package for editing markdown files.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :bind (:map markdown-mode-map
           ("M-Q" . aorst/split-pararagraph-into-lines))
    :custom
    (markdown-fontify-code-blocks-natively t)
    (markdown-command "pandoc")
    (markdown-hr-display-char nil)
    (markdown-list-item-bullets '("-")))
#+end_src

*** Rust
[[https://www.rust-lang.org/][Rust]] language support.

#+begin_src emacs-lisp
  (use-package rust-mode
    :commands (rust-format-buffer)
    :bind (:map rust-mode-map
           ("C-c C-M-f" . rust-format-buffer)))
#+end_src

*** TOML
[[https://toml.io/en/][TOML]] Language support.

#+begin_src emacs-lisp
  (use-package toml-mode)
#+end_src

*** Geiser
REPL support for various Schemes.

#+begin_src emacs-lisp
  (use-package geiser
    :hook (scheme-mode . geiser-mode)
    :custom
    (geiser-active-implementations '(guile))
    (geiser-default-implementation 'guile))
#+end_src

*** Emacs Lisp
Emacs lisp mode tweaks.

#+begin_src emacs-lisp
  (use-package elisp-mode
    :straight nil
    :commands aorst/emacs-lisp-indent-function
    :hook ((emacs-lisp-mode . eldoc-mode)
           (emacs-lisp-mode . aorst/emacs-lisp-setup))
    :config
    (defun aorst/emacs-lisp-indent-function (indent-point state)
      "A replacement for `lisp-indent-function'.
  Indents plists more sensibly. Adapted from DOOM Emacs:
  https://github.com/hlissner/doom-emacs/blob/bf8495b4/modules/lang/emacs-lisp/autoload.el#L110"
      (let ((normal-indent (current-column))
            (orig-point (point))
            target)
        (goto-char (1+ (elt state 1)))
        (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
        (cond ((and (elt state 2)
                    (or (not (looking-at-p "\\sw\\|\\s_"))
                        (eq (char-after) ?:)))
               (unless (> (save-excursion (forward-line 1) (point))
                          calculate-lisp-indent-last-sexp)
                 (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t))
               (backward-prefix-chars)
               (current-column))
              ((and (save-excursion
                      (goto-char indent-point)
                      (skip-syntax-forward " ")
                      (not (eq (char-after) ?:)))
                    (save-excursion
                      (goto-char orig-point)
                      (and (eq (char-after) ?:)
                           (eq (char-before) ?\()
                           (setq target (current-column)))))
               (save-excursion
                 (move-to-column target t)
                 target))
              ((let* ((function (buffer-substring (point) (progn (forward-sexp 1) (point))))
                      (method (or (function-get (intern-soft function) 'lisp-indent-function)
                                  (get (intern-soft function) 'lisp-indent-hook))))
                 (cond ((or (eq method 'defun)
                            (and (null method)
                                 (> (length function) 3)
                                 (string-match-p "\\`def" function)))
                        (lisp-indent-defform state indent-point))
                       ((integerp method)
                        (lisp-indent-specform method state indent-point normal-indent))
                       (method
                        (funcall method indent-point state))))))))
    (defun aorst/emacs-lisp-setup ()
      (setq-local lisp-indent-function
                  #'aorst/emacs-lisp-indent-function)))
#+end_src

*** Fennel
Fennel is sort of a lisp dialect, that is being compiled to Lua, which means that it can run anywhere, where Lua can.
It supports compile-time macro system, and has a full Lua compatibility.
Lua runtime itself is very lisp-like so putting an S-expression based syntax on it feels very natural.

#+begin_src emacs-lisp
  (use-package fennel-mode
    :bind (:map fennel-mode-map
           ("C-c C-k" . aorst/eval-each-sexp)
           ("M-." . xref-find-definitions)
           ("M-," . xref-pop-marker-stack)
           :map fennel-repl-mode-map
           ("C-c C-q" . aorst/quit-fennel-repl))
    :config
    (put 'global 'fennel-indent-function 1)
    (put 'local 'fennel-indent-function 1)
    (put 'var 'fennel-indent-function 1)
    (defvar org-babel-default-header-args:fennel '((:results . "silent")))
    (defun org-babel-execute:fennel (body params)
      "Evaluate a block of Fennel code with Babel."
      (unless (bufferp fennel-repl--buffer)
        (fennel-repl nil))
      (let ((inferior-lisp-buffer fennel-repl--buffer))
        (lisp-eval-string body)))
    (defun aorst/eval-each-sexp (&optional arg)
      "Evaluate each s-expression in the buffer consequentially.
  If prefix ARG specified, call `fennel-reload' function.  If
  double prefix ARG specified call `fennel-reload' function and ask
  for module name."
      (interactive "P")
      (if (symbolp arg)
          (save-excursion
            (save-restriction
              (goto-char (point-min))
              (while (save-excursion
                       (search-forward-regexp "[^[:space:]]." nil t))
                (forward-sexp)
                (lisp-eval-last-sexp))))
        (when fennel-mode-switch-to-repl-after-reload
          (switch-to-lisp t))
        (if (equal arg '(4))
            (funcall-interactively 'fennel-reload nil)
          (funcall-interactively 'fennel-reload t))))
    (defun aorst/quit-fennel-repl ()
      (interactive)
      (let ((window (get-buffer-window fennel-repl--buffer))
            (kill-buffer-query-functions
             (delq 'process-kill-buffer-query-function kill-buffer-query-functions)))
        (ignore-errors
          (when window
            (delete-window window)))
        (kill-buffer fennel-repl--buffer))))
#+end_src

*** Clojure
[[https://clojure.org/][Clojure]] language support.

#+begin_src emacs-lisp
  (use-package clojure-mode
    :hook (((clojure-mode
             clojurec-mode
             clojurescript-mode)
            . aorst/clojure-mode-setup))
    :config
    (defvar org-babel-default-header-args:clojure '((:results . "silent")))'
    (defun org-babel-execute:clojure (body params)
      "Evaluate a block of Clojure code with Babel."
      (lisp-eval-string body))
    (defun aorst/clojure-mode-setup ()
      "Setup Clojure buffer."
      (modify-syntax-entry ?# "w")
      (flycheck-mode)))
#+end_src

IDE for Clojure and ClojureScript.

#+begin_src emacs-lisp
  (use-package cider
    :hook ((cider-repl-mode cider-mode) . eldoc-mode)
    :bind (:map cider-repl-mode-map
           ("C-c C-o" . cider-repl-clear-buffer))
    :custom-face
    (cider-result-overlay-face ((t (:box (:line-width -1 :color "grey50")))))
    (cider-error-highlight-face ((t (:inherit flymake-error))))
    (cider-warning-highlight-face ((t (:inherit flymake-warning))))
    :custom
    (nrepl-log-messages nil)
    (cider-repl-display-help-banner nil)
    (cider-repl-tab-command #'indent-for-tab-command)
    (nrepl-hide-special-buffers t)
    (cider-test-show-report-on-success t)
    (cider-allow-jack-in-without-project t)
    (cider-use-fringe-indicators nil)
    (cider-font-lock-dynamically '(macro var deprecated))
    (cider-save-file-on-load nil)
    (cider-inspector-fill-frame nil)
    (cider-auto-select-error-buffer t)
    (cider-eval-spinner t)
    (cider-repl-prompt-function #'cider-repl-prompt-newline)
    (nrepl-use-ssh-fallback-for-remote-hosts t)
    :config
    (setq cider-jdk-src-paths nil)
    (dolist (src (append (file-expand-wildcards "/usr/lib/jvm/java-*-openjdk/src.zip")
                         (file-expand-wildcards "/usr/lib/jvm/java-*-openjdk/lib/src.zip")
                         (file-expand-wildcards "~/.clojure/clojure-*-sources.jar")))

      (when (file-exists-p src)
        (unless (memq src cider-jdk-src-paths)
          (add-to-list 'cider-jdk-src-paths src t))))
    (defun cider-repl-prompt-newline (namespace)
      "Return a prompt string that mentions NAMESPACE with newline
  appended."
      (format "%s\n> " namespace)))
#+end_src

[[https://github.com/borkdude/clj-kondo][clj-kondo]] is a static analyzer for Clojure(Script), and =flycheck-clj-kondo= is a backend for =flycheck=, that makes these two things understand each other.

#+begin_src emacs-lisp
  (use-package flycheck-clj-kondo
    :when (executable-find "clj-kondo"))
#+end_src

=clj-refactor= provides refactoring support for Clojure projects.
It complements the refactoring functionality from =clojure-mode= and CIDER.

#+begin_src emacs-lisp
  (use-package clj-refactor
    :hook ((cider-mode . clj-refactor-mode)
           (cider-mode . yas-minor-mode))
    :custom
    (cljr-suppress-no-project-warning t)
    (cljr-suppress-middleware-warnings t)
    (cljr-warn-on-eval nil))
#+end_src

*** Common Lisp
Common Lisp IDE for Emacs.

#+begin_src emacs-lisp
  (use-package sly
    :custom (inferior-lisp-program "sbcl")
    :config
    ;; workaround https://gitlab.com/technomancy/fennel-mode/issues/11
    ;; Sly author claims that this is `fennel-mode' problem, as
    ;; `lisp-mode' is meant strictly for Common Lisp.
    (defun aorst/sly-ignore-fennel (f &rest args)
      "Prevent sly functions from running in `fennel-mode'."
      (unless (or (eq major-mode 'fennel-mode)
                  (eq major-mode 'fennel-repl-mode))
        (apply f args)))
    (dolist (f '(sly-mode
                 sly-editing-mode))
      (advice-add f :around #'aorst/sly-ignore-fennel))
    (add-hook 'fennel-mode (lambda () (sly-symbol-completion-mode -1))))
#+end_src

*** Yaml
Support for =.yaml= files.

#+begin_src emacs-lisp
  (use-package yaml-mode
    :custom (yaml-indent-offset 4))
#+end_src

*** Shell Script
Some configurations for shell script modes.

#+begin_src emacs-lisp
  (use-package sh-script
    :straight nil
    :hook (sh-mode . flycheck-mode))
#+end_src

*** Perl
Perl related configurations.

#+begin_src emacs-lisp
  (use-package perl-mode
    :straight nil
    :hook ((perl-mode . flycheck-mode)))
#+end_src

*** Lua
Lua support, mainly to view what [[*Fennel][Fennel]] compiler produces.

#+begin_src emacs-lisp
  (use-package lua-mode
    :hook (lua-mode . flycheck-mode)
    :custom (lua-indent-level 2)
    :config
    (defvar org-babel-default-header-args:lua '((:results . "silent")))
    (defun org-babel-execute:lua (body params)
      "Evaluate a block of Lua code with Babel."
      (lua-get-create-process)
      (lua-send-string body)))
#+end_src

*** CSS
CSS indentation tweaks.

#+begin_src emacs-lisp
  (use-package css-mode
    :straight nil
    :custom
    (css-indent-offset 2))
#+end_src

*** JSON
Json support for Emacs.

#+begin_src emacs-lisp
  (use-package json-mode
    :hook (json-mode . flycheck-mode)
    :custom (js-indent-level 2))
#+end_src

*** Scala
Scala language support.

#+begin_src emacs-lisp
  (use-package scala-mode)
#+end_src

*** CSV
A mode for viewing and editing char separated value files.

#+begin_src emacs-lisp
  (use-package csv-mode
    :custom (csv-align-max-width 80))
#+end_src

*** Erlang
Support for Erlang language.

#+begin_src emacs-lisp
  (use-package erlang)
#+end_src

*** Elixir
Support for Elixir language.

#+begin_src emacs-lisp
  (use-package elixir-mode)
#+end_src

** Tools
Additional packages that change how Emacs works, providing more comfortable user experience.

*** Help
Select help window automatically.

#+begin_src emacs-lisp
  (use-package help
    :straight nil
    :custom (help-window-select t))
#+end_src

*** Doc View
Default resolution is too low:

#+begin_src emacs-lisp
  (use-package doc-view
    :straight nil
    :custom (doc-view-resolution 192))
#+end_src

*** vterm
This package provides a bridge to =libvterm= to display terminal as Emacs buffer.

#+begin_src emacs-lisp
  (use-package vterm
    :if (bound-and-true-p module-file-suffix)
    :bind (:map vterm-mode-map
           ("<insert>" . ignore)
           ("<f2>" . ignore))
    :custom
    (vterm-always-compile-module t)
    (vterm-environment '("VTERM=1")))
#+end_src

*** EditorConfig
=.editorconfig= file provides a nice way to synchronize some of the configurations between projects and different editors.

#+begin_src emacs-lisp
  (use-package editorconfig
    :config (editorconfig-mode 1))
#+end_src

*** Flymake
Flymake is an inbuilt package for checking various programming languages.
It is loaded mostly to define faces.

#+begin_src emacs-lisp
  (use-package flymake
    :straight nil
    :custom
    (flymake-fringe-indicator-position 'right-fringe))
#+end_src

*** Flyspell
On the fly spell checking.

#+begin_src emacs-lisp
  (use-package flyspell
    :when (or (executable-find "ispell")
              (executable-find "aspell")
              (executable-find "hunspell"))
    :hook (((org-mode git-commit-mode markdown-mode) . flyspell-mode)
           (prog-mode . flyspell-prog-mode)))
#+end_src

*** Flycheck
Some languages have better support with =flycheck=.

#+begin_src emacs-lisp
  (use-package flycheck
    :custom
    (flycheck-indication-mode 'right-fringe)
    (flycheck-display-errors-delay 86400 "86400 seconds is 1 day")
    :config
    (when (fboundp #'define-fringe-bitmap)
      (define-fringe-bitmap 'flycheck-double-exclamation-mark
        (vector #b00000000
                #b00000000
                #b00000000
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b00000000
                #b01100110
                #b01100110
                #b00000000
                #b00000000
                #b00000000))
      (define-fringe-bitmap 'flycheck-exclamation-mark
        (vector #b00000000
                #b00000000
                #b00000000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00000000
                #b00011000
                #b00011000
                #b00000000
                #b00000000
                #b00000000))
      (define-fringe-bitmap 'flycheck-question-mark
        (vector #b00000000
                #b00000000
                #b00000000
                #b00111100
                #b01100110
                #b01100110
                #b01100110
                #b00000110
                #b00001100
                #b00011000
                #b00011000
                #b00000000
                #b00011000
                #b00011000
                #b00000000
                #b00000000
                #b00000000))
      (flycheck-define-error-level 'error
        :severity 100
        :compilation-level 2
        :overlay-category 'flycheck-error-overlay
        :fringe-bitmap 'flycheck-double-exclamation-mark
        :fringe-face 'flycheck-fringe-error
        :error-list-face 'flycheck-error-list-error)
      (flycheck-define-error-level 'warning
        :severity 10
        :compilation-level 1
        :overlay-category 'flycheck-warning-overlay
        :fringe-bitmap 'flycheck-exclamation-mark
        :fringe-face 'flycheck-fringe-warning
        :error-list-face 'flycheck-error-list-warning)
      (flycheck-define-error-level 'info
        :severity -10
        :compilation-level 0
        :overlay-category 'flycheck-info-overlay
        :fringe-bitmap 'flycheck-question-mark
        :fringe-face 'flycheck-fringe-info
        :error-list-face 'flycheck-error-list-info))
    (define-advice flycheck-mode-line-status-text (:override (&optional status)
                                                   aorst:flycheck-mode-line-indicator)
      "Get a text describing STATUS for use in the mode line.

  STATUS defaults to `flycheck-last-status-change' if omitted or
  nil."
      (let ((text (pcase (or status flycheck-last-status-change)
                    (`not-checked "-/-")
                    (`no-checker "-")
                    (`running "*/*")
                    (`errored "!")
                    (`finished
                     (let-alist (flycheck-count-errors flycheck-current-errors)
                       (propertize (format "%s/%s" (or .error 0) (or .warning 0))
                                   'help-echo (if (or .error .warning)
                                                  (concat "Flycheck: "
                                                          (when .error (format "%d errors%s" .error (if .warning ", " "")))
                                                          (when .warning (format "%d warnings" .warning))
                                                          "\nmouse-1: list errors")
                                                "Flycheck: no errors or warnings")
                                   'local-map 'flycheck-error-list-mode-line-map)))
                    (`interrupted ".")
                    (`suspicious "?"))))
        (concat " " flycheck-mode-line-prefix ":" text)))
    (define-advice flycheck-may-use-echo-area-p (:override () aorst:flycheck-no-echo-or-buffer)
      nil))
#+end_src

**** Flycheck package
Emacs package linting via package-lint and Flycheck.

#+begin_src emacs-lisp
  (use-package flycheck-package
    :hook ((emacs-lisp-mode . flycheck-mode)
           (emacs-lisp-mode . flycheck-package-setup)))
#+end_src

*** Hydra
This is something like ability to create mappings that sit in it's own mode, like different user modes in Kakoune.
It allows me to press some shortcut and be locked in a mode-like state where keys that are related to this prefix shortcut are behaving in terms of this shortcut.
This package will be used in many other package configurations to provide sane keybindings.

#+begin_src emacs-lisp
  (use-package hydra)
#+end_src

*** Smartparens
Structural editing similar to Paredit.

#+begin_src emacs-lisp
  (use-package smartparens
    :hook (((clojure-mode
             emacs-lisp-mode
             common-lisp-mode
             scheme-mode
             lisp-mode
             racket-mode
             fennel-mode
             cider-repl-mode
             racket-repl-mode
             geiser-repl-mode
             inferior-lisp-mode
             inferior-emacs-lisp-mode
             sly-mrepl-mode)
            . smartparens-strict-mode)
           ((eval-expression-minibuffer-setup
             lisp-data-mode)
            . aorst/minibuffer-enable-sp)
           (prog-mode . smartparens-mode))
    :bind (:map smartparens-mode-map
           ("C-M-q" . sp-indent-defun)
           :map smartparens-strict-mode-map
           (";" . sp-comment))
    :custom
    (sp-highlight-pair-overlay nil)
    (sp-highlight-wrap-overlay nil)
    (sp-highlight-wrap-tag-overlay nil)
    (sp-show-pair-delay 0)
    (sp-echo-match-when-invisible nil)
    :config
    (require 'smartparens-config)
    (sp-use-paredit-bindings)
    (define-key smartparens-mode-map (kbd "M-r") 'sp-rewrap-sexp) ; needs to be set manually, because :bind section runs before config
    (add-to-list 'sp-lisp-modes 'fennel-mode t)
    (defun aorst/minibuffer-enable-sp ()
      "Enable `smartparens-strict-mode' in the minibuffer, during `eval-expression'."
      (setq-local comment-start ";")
      (sp-local-pair 'minibuffer-pairs "'" nil :actions nil)
      (sp-local-pair 'minibuffer-pairs "`" nil :actions nil)
      (sp-update-local-pairs 'minibuffer-pairs)
      (smartparens-strict-mode 1)))
#+end_src

*** Vertico
Vertical completion UI for the minibuffer.

#+begin_src emacs-lisp
  (use-package vertico
    :hook ((minibuffer-setup . aorst/minibuffer-defer-garbage-collection)
           (minibuffer-exit . aorst/minibuffer-restore-garbage-collection)
           (aorst--theme-change . aorst/vertico-setup-faces))
    :init (vertico-mode)
    (defun aorst/vertico-setup-faces ()
      (let ((mode-line-color (face-attribute 'mode-line :background)))
        (when (fboundp #'doom-darken)
          (set-face-attribute
           'vertico-current nil
           :background (if (aorst/dark-mode-p)
                           (doom-lighten mode-line-color 0.2)
                         (doom-darken mode-line-color 0.1))))))
    (aorst/vertico-setup-faces))
#+end_src

*** Marginalia
Completion candidates annotations for minibuffer.

#+begin_src emacs-lisp
  (use-package marginalia
    :init (marginalia-mode))
#+end_src

*** Consult
A predefined set of commands for minibuffer.

#+begin_src emacs-lisp
  (use-package consult
    :bind (("C-x C-r" . consult-recent-file))
    :init
    (setq completion-in-region-function #'consult-completion-in-region))
#+end_src

*** Company
Complete anything framework.

#+begin_src emacs-lisp
  (use-package company
    :bind (:map company-mode-map
           ([remap completion-at-point] . company-complete)
           ("M-/" . company-complete)
           :map company-active-map
           ("TAB" . company-complete-common-or-cycle)
           ("<tab>" . company-complete-common-or-cycle)
           ("<S-Tab>" . company-select-previous)
           ("<backtab>" . company-select-previous)
           ("C-n" . company-select-next)
           ("C-p" . company-select-previous)
           ("C-d" . company-show-doc-buffer)
           ("M-." . company-show-location))
    :hook (after-init . global-company-mode)
    :custom
    (company-idle-delay 0)
    (company-require-match 'never)
    (company-minimum-prefix-length 2)
    (company-tooltip-align-annotations t)
    (company-frontends '(company-pseudo-tooltip-unless-just-one-frontend
                         company-preview-frontend
                         company-echo-metadata-frontend))
    (company-backends '(company-capf company-files company-dabbrev-code))
    (company-tooltip-minimum-width 30)
    (company-tooltip-maximum-width 120)
    (company-icon-size aorst--line-pixel-height))
#+end_src

**** Company quickhelp
Documentation popup for company mode.

#+begin_src emacs-lisp
  (use-package company-quickhelp
    :hook (company-mode . company-quickhelp-mode)
    :custom
    (company-quickhelp-max-lines 13)
    (company-quickhelp-use-propertized-text t))
#+end_src

*** Undo Tree
This is a more familiar undo mode.

#+begin_src emacs-lisp
  (use-package undo-tree
    :commands global-undo-tree-mode
    :custom
    (undo-tree-visualizer-relative-timestamps nil)
    (undo-tree-visualizer-timestamps nil)
    (undo-tree-auto-save-history nil)
    :init (global-undo-tree-mode 1))
#+end_src

*** Yasnippet
Template engine for Emacs.

#+begin_src emacs-lisp
  (use-package yasnippet)
#+end_src

*** Magit
Emacs interface to Git.

#+begin_src emacs-lisp
  (use-package with-editor)
  (use-package magit
    :hook ((git-commit-mode . flyspell-mode)
           (aorst--theme-change . aorst/magit-setup-diff-faces))
    :custom
    (magit-ediff-dwim-show-on-hunks t)
    (magit-diff-refine-ignore-whitespace t)
    (magit-diff-refine-hunk 'all)
    :config
    (advice-add 'magit-set-header-line-format :override #'ignore)
    (defun aorst/magit-setup-diff-faces ()
      (set-face-attribute 'diff-added nil :foreground nil :background nil :inherit 'magit-diff-added)
      (set-face-attribute 'diff-removed nil :foreground nil :background nil :inherit 'magit-diff-removed)
      (set-face-attribute 'smerge-lower nil :foreground nil :background nil :inherit 'magit-diff-added)
      (set-face-attribute 'smerge-upper nil :foreground nil :background nil :inherit 'magit-diff-removed)
      (dolist (face-reference '((diff-refine-added magit-diff-added-highlight)
                                (diff-refine-removed magit-diff-removed-highlight)
                                (smerge-refined-added magit-diff-added-highlight)
                                (smerge-refined-removed magit-diff-removed-highlight)))
        (apply #'aorst/create-accent-face face-reference)))
    (aorst/magit-setup-diff-faces))
#+end_src

**** Magit TODOs
Display TODO items in Magit buffers.

#+begin_src emacs-lisp
  (use-package magit-todos
    :after magit
    :init
    ;; don't break Magit on systems that don't have `nice'
    (unless (executable-find "nice")
      (setq magit-todos-nice nil))
    :config
    (let ((inhibit-message t))
      (magit-todos-mode 1))
    (transient-append-suffix 'magit-status-jump '(0 0 -1)
      '("T " "Todos" magit-todos-jump-to-todos)))
#+end_src

*** Ediff
This is a inbuilt mode for diffing files in Emacs.

#+begin_src emacs-lisp
  (use-package ediff
    :straight nil
    :hook (ediff-prepare-buffer . outline-show-all)
    :config
    (advice-add 'ediff-window-display-p :override #'ignore)
    :custom
    (ediff-split-window-function 'split-window-horizontally))
#+end_src

*** Multiple Cursors
This package provides multiple cursors functionality to Emacs.

#+begin_src emacs-lisp
  (use-package phi-search)
  (use-package mc-extras)
  (use-package multiple-cursors
    :requires hydra
    :commands (mc/cycle-backward
               mc/cycle-forward)
    :bind (("S-<mouse-1>" . mc/add-cursor-on-click)
           ("M-n" . mc/mark-next-like-this-symbol)
           :map mode-specific-map
           ("m" . hydrant/mc/body)
           :map mc/keymap
           ("<return>" . nil)
           ("C-s" . phi-search)
           ("C-r" . phi-search-backward))
    :config
    (dolist (f '(mc/mark-next-like-this-symbol
                 mc/mark-next-like-this-word
                 mc/mark-next-lines))
      (advice-add f :after (lambda (&rest _) (mc/cycle-forward))))
    (dolist (f '(mc/mark-previous-like-this-symbol
                 mc/mark-previous-like-this-word))
      (advice-add f :after (lambda (&rest _) (mc/cycle-backward))))
    (when (fboundp #'defhydra)
      (defhydra hydrant/mc (:hint nil :color pink)
        "
   ^Select^                       ^Discard^                      ^Edit^               ^Navigate^
   _M-s_: split lines             _M-SPC_:  discard current      _&_: align           _(_: cycle backward
   _s_:   select regexp           _b_:      discard blank lines  _#_: insert numbers  _)_: cycle forward
   _n_:   select next word        _d_:      remove duplicated    ^ ^                  ^ ^
   _M-n_: select next symbol      _q_ or _g_: exit hydrant       ^ ^                  ^ ^
   _p_:   select previous word    ^ ^    ^ ^                     ^ ^                  ^ ^
   _M-p_: select previous symbol  ^ ^                            ^ ^                  ^ ^
   _C_:   select next line"
        ("M-s" mc/edit-ends-of-lines)
        ("s" mc/mark-all-in-region-regexp)
        ("n" mc/mark-next-like-this-word)
        ("M-n" mc/mark-next-like-this-symbol)
        ("p" mc/mark-previous-like-this-word)
        ("M-p" mc/mark-previous-like-this-symbol)
        ("&" mc/vertical-align-with-space)
        ("(" mc/cycle-backward)
        (")" mc/cycle-forward)
        ("M-SPC" mc/remove-current-cursor)
        ("b" mc/remove-cursors-on-blank-lines)
        ("d" mc/remove-duplicated-cursors)
        ("C" mc/mark-next-lines)
        ("#" mc/insert-numbers)
        ("q" mc/remove-duplicated-cursors :exit t)
        ("g" mc/remove-duplicated-cursors :exit t)
        ("C-g" keyboard-quit :exit t))))
#+end_src

*** Expand Region
Expand or reduce region semantically.

#+begin_src emacs-lisp
  (use-package expand-region
    :bind (:map mode-specific-map
           ("e" . hydrant/er/body))
    :requires hydra
    :config
    (defun aorst/er-exit ()
      (interactive)
      (deactivate-mark t))
    (defhydra hydrant/er (:color pink :hint nil)
      "
   ^Mark^              ^Expand or Discard^
   _(_: inside pairs   _e_:   ^ ^  expand region
   _)_: around pairs   _r_:   ^ ^  reduce region
   _'_: inside quotes  _g_ or _q_: exit hydrant
   _\"_: around quotes ^ ^    ^ ^
   _p_: paragraph      ^ ^    ^ ^"
      ("e" er/expand-region)
      ("r" er/contract-region)
      ("p" er/mark-paragraph)
      ("(" er/mark-inside-pairs)
      (")" er/mark-outside-pairs)
      ("'" er/mark-inside-quotes)
      ("\"" er/mark-outside-quotes)
      ("g" ignore :exit t)
      ("q" ignore :exit t)
      ("C-g" aorst/er-exit :exit t)))
#+end_src

*** LSP
Packages providing integration with Language Server Protocol.

**** LSP Mode
LSP client for Emacs.

#+begin_src emacs-lisp
  (use-package lsp-mode
    :requires yasnippet
    :hook (((c-mode
             c++-mode
             clojure-mode
             clojurec-mode
             clojurescript-mode)
            . lsp)
           (lsp-mode . yas-minor-mode))
    :custom
    ;; general settings
    (lsp-keymap-prefix "C-c l")
    (lsp-completion-provider :capf)
    (lsp-diagnostics-provider :auto)
    (lsp-session-file (expand-file-name ".lsp-session" user-emacs-directory))
    (lsp-log-io nil)
    (lsp-keep-workspace-alive nil)
    (lsp-idle-delay 0.05)
    ;; DAP
    (lsp-enable-dap-auto-configure nil)
    ;; UI
    (lsp-enable-links nil)
    (lsp-headerline-breadcrumb-enable nil)
    (lsp-modeline-code-actions-enable nil)
    ;; semantic code features
    (lsp-enable-folding nil)
    (lsp-enable-indentation nil)
    (lsp-enable-semantic-highlighting nil)
    (lsp-enable-symbol-highlighting nil)
    (lsp-enable-on-type-formatting nil)
    (lsp-enable-text-document-color nil)
    ;; completion
    (lsp-completion-show-kind nil)
    ;; lens
    (lsp-lens-enable t)
    (lsp-lens-place-position 'end-of-line))
#+end_src

**** LSP Java
Java language server requires JDK 11 to run, so this package is only loaded when JDK 11 is available.
Note that path to java may differ on different systems.

#+begin_src emacs-lisp
  (use-package lsp-java
    :requires lsp-mode
    :when (file-exists-p "/usr/lib/jvm/java-11-openjdk/bin/java")
    :custom (lsp-java-java-path "/usr/lib/jvm/java-11-openjdk/bin/java"))
#+end_src

*** Project
Tweaks to inbuilt project management mode.

#+begin_src emacs-lisp
  (use-package project
    :bind (:map project-prefix-map
           ("s" . aorst/project-save-some-buffers))
    :custom
    (project-compilation-buffer-name-function 'project-prefixed-buffer-name)
    :config
    (defvar aorst--project-root-markers
      '("Cargo.toml" "compile_commands.json" "compile_flags.txt" "project.clj" ".git" "deps.edn")
      "Files or directories that indicate the root of a project.")
    (defun aorst/project-root-p (path)
      "Check if current PATH has any of project root markers."
      (memq t (mapcar (lambda (file)
                        (file-exists-p (concat path file)))
                      aorst--project-root-markers)))
    (defun aorst/project-find-root (path)
      "Recursive search in PATH for root markers."
      (cond
       ((aorst/project-root-p path) (cons 'transient path))
       ((equal "/" path) nil)
       (t (aorst/project-find-root
           (file-name-directory
            (directory-file-name path))))))
    (add-to-list 'project-find-functions #'aorst/project-find-root)
    (define-advice project-compile (:around (fn &rest args)
                                    aorst:save-only-project-buffers)
      "Only ask to save project related buffers."
      (let* ((project-buffers
              (project-buffers (project-current)))
             (compilation-save-buffers-predicate
              (lambda () (memq (current-buffer) project-buffers))))
        (apply fn args)))
    (defun aorst/project-save-some-buffers (&optional arg)
      "Save some modified file-visiting buffers in current project.

  Optional argument ARG (interactively, prefix argument) non-nil
  means save all with no questions."
      (interactive "P")
      (let* ((project-buffers (project-buffers (project-current)))
             (pred (lambda () (memq (current-buffer) project-buffers))))
        (save-some-buffers arg pred))))
#+end_src

*** Server
Start Emacs server if none running already.
Clients will connect to this server to reuse frame.

#+begin_src emacs-lisp
  (use-package server
    :straight nil
    :config
    (unless (server-running-p)
      (server-start)))
#+end_src

**** Desktop launcher
We need the =.desktop= file that uses the advantage of a possibly running server:

#+begin_src conf-desktop # :tangle "~/.local/share/applications/emacs.desktop" :mkdirp yes
  [Desktop Entry]
  Name=Emacs
  GenericName=Text Editor
  Comment=Edit text
  MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
  Exec=sh -c "if [ -n \\"\\$*\\" ]; then exec emacsclient -a emacs -n \\"\\$@\\"; else exec emacs; fi" dummy %F
  Icon=emacs
  Type=Application
  Terminal=false
  Categories=Development;TextEditor;
  StartupNotify=true
  StartupWMClass=Emacs
  Keywords=Text;Editor;
#+end_src

This will allow us to open files with =emacs-launcher=, and it will automatically reuse existing window if present.
Precisely what it does is:

- call =emacs= if no arguments provided, or
- call =emacsclient -a emacs= with arguments.
  =emacsclient= will try to connect to a server, and if there's none, it will fire up =emacs= which will create server, and opening new files will be done in this instance of =emacs=.

With this file we should be able to launch Emacs from the file context menu, or whit "open with" sub menu, and it will reuse existing window if present.

*** Edit Indirect
This package makes it possible to edit Markdown code blocks in separate buffers.

#+begin_src emacs-lisp
  (use-package edit-indirect
    :hook ((edit-indirect-after-creation . aorst/edit-indirect-header-line-setup))
    :bind (:map edit-indirect-mode-map
           ("C-c C-c" . edit-indirect-commit)
           ("C-c C-k" . edit-indirect-abort)
           ("C-c '" . nil))
    :config
    (defun aorst/edit-indirect-header-line-setup ()
      (setq-local
       header-line-format
       (substitute-command-keys
        "\\<edit-indirect-mode-map>Edit, then exit with `\\[edit-indirect-commit]' or abort with `\\[edit-indirect-abort]'"))))
#+end_src

*** Separedit
This package provides a way to edit comments in sources as separate buffers with another major mode, like Markdown.
Additionally it provides string escaping, when editing nested strings.

#+begin_src emacs-lisp
  (use-package separedit
    :hook (separedit-buffer-creation . aorst/separedit-header-line-setup)
    :bind (:map prog-mode-map
           ("C-c '" . separedit)
           :map edit-indirect-mode-map
           ("C-c '" . separedit))
    :custom
    (separedit-default-mode 'gfm-mode)
    :config
    (defun aorst/separedit-header-line-setup ()
      (setq-local
       header-line-format
       (substitute-command-keys
        "\\<edit-indirect-mode-map>Edit, then exit with `\\[separedit-commit]' or abort with `\\[edit-indirect-abort]'"))))
#+end_src

*** Recent files
Settings to =recentf= mode.

#+begin_src emacs-lisp
  (use-package recentf
    :straight nil
    :custom
    (recentf-max-menu-items 50)
    :config
    (add-to-list 'recentf-exclude "\\.gpg\\")
    (recentf-mode))
#+end_src

*** Dumb Jump
Dumbest definition jumping that just work.

#+begin_src emacs-lisp
  (use-package dumb-jump
    :custom
    (dumb-jump-prefer-searcher 'rg)
    (dumb-jump-selector 'completing-read)
    :config
    (add-to-list 'xref-backend-functions #'dumb-jump-xref-activate))
#+end_src

*** Which Key
A useful package that displays all keybindings available for the chord you're entering after a certain delay.

#+begin_src emacs-lisp
  (use-package which-key
    :config (which-key-mode t))
#+end_src

*** GCMH
Garbage Collector Magic Hack.
Runs GC when Emacs is idle, and increases GC threshold during active use.

#+begin_src emacs-lisp
  (use-package gcmh
    :config (gcmh-mode t))
#+end_src

*** Parens
Some tweaks to inbuilt parenthesis highlighting mode.

#+begin_src emacs-lisp
  (use-package paren
    :straight nil
    :hook (prog-mode . show-paren-mode)
    :custom
    (show-paren-delay 0)
    (show-paren-when-point-in-periphery t))
#+end_src

*** VC mode
Tweaks for inbuilt VC mode.

#+begin_src emacs-lisp
  (use-package vc-hooks
    :straight nil
    :custom (vc-follow-symlinks t))
#+end_src

*** ISAYT
Indent S-expressions as you type.

#+begin_src emacs-lisp
  (use-package isayt
    :straight (:host gitlab
               :repo "andreyorst/isayt.el"
               :branch "main")
    :hook ((paredit-mode smartparens-strict-mode) . isayt-mode))
#+end_src

*** Eldoc
Eldoc tweaks.

#+begin_src emacs-lisp
  (use-package eldoc
    :straight nil
    :custom (eldoc-echo-area-use-multiline-p nil))
#+end_src

*** Auto revert mode
Watch files and update buffer contents if files changed on disk.

#+begin_src emacs-lisp
  (use-package autorevert
    :straight nil
    :hook (after-init . global-auto-revert-mode))
#+end_src

*** HL TODO
Highlight =TODO= markers in files.

#+begin_src emacs-lisp
  (use-package hl-todo
    :hook (prog-mode . hl-todo-mode))
#+end_src

*** Compile
Tweaks to inbuilt =compile.el= mode.

#+begin_src emacs-lisp
  (defmacro aorst/add-compilation-error-syntax (name regexp file line &optional col level)
    "Register new compilation error syntax.

  Add NAME symbol to `compilation-error-regexp-alist', and then add
  REGEXP FILE LINE and optional COL LEVEL info to
  `compilation-error-regexp-alist-alist'."
    (declare (indent 1))
    `(progn (add-to-list 'compilation-error-regexp-alist ',name)
            (add-to-list 'compilation-error-regexp-alist-alist
                         '(,name ,regexp ,file ,line ,col ,level))))

  (use-package compile
    :straight nil
    :custom
    (compilation-scroll-output 'first-error)
    :config
    (aorst/add-compilation-error-syntax kaocha-tap
      "^not ok.*(\\([^:]*\\):\\([0-9]*\\))$"
      (1 "src/%s" "test/%s") 2)
    (aorst/add-compilation-error-syntax kaocha-fail
      ".*FAIL in.*(\\([^:]*\\):\\([0-9]*\\))$"
      (1 "src/%s" "test/%s") 2)
    (aorst/add-compilation-error-syntax lua-stacktrace
      "\\(?:^[[:space:]]+\\([^
  :]+\\):\\([[:digit:]]+\\):[[:space:]]+in.+$\\)"
      1 2))
#+end_src

*** Isearch
Tweaks to inbuilt incremental search mode.

#+begin_src emacs-lisp
  (use-package isearch
    :straight nil
    :bind (:map isearch-mode-map
           ("<backspace>" . isearch-del-char)
           ("<left>" . aorst/isearch-backward-char)
           :map minibuffer-local-isearch-map
           ("<right>" . forward-char))
    :config
    (defun aorst/isearch-backward-char (&optional n)
      (interactive)
      (isearch-edit-string)
      (backward-char n)))
#+end_src

*** Eshell
Emacs shell settings.
Eshell is a shell implemented in Emacs Lisp, that (in theory) works the same across all systems.

#+begin_src emacs-lisp
  (use-package esh-mode
    :straight nil
    :custom (eshell-scroll-show-maximum-output nil))
#+end_src

*** Dired
Dired settings.

#+begin_src emacs-lisp
  (use-package dired
    :straight nil
    :custom
    (dired-listing-switches "-al --group-directories-first"))
#+end_src

*** Comint
Prevent automatic recentering when using inferior buffers.

#+begin_src emacs-lisp
  (use-package comint
    :straight nil
    :custom (comint-scroll-show-maximum-output nil))
#+end_src

*** Rect
Additional functions for rectangle manipulation.

#+begin_src emacs-lisp
  (use-package rect
    :straight nil
    :bind (("C-x r C-y" . aorst/yank-rectangle-add-lines))
    :config
    (defun aorst/yank-rectangle-add-lines ()
      (interactive "*")
      (when (use-region-p)
        (delete-region (region-beginning) (region-end)))
      (save-restriction
        (narrow-to-region (point) (point))
        (yank-rectangle))))
#+end_src

*** JDecomp
Package for automatic decompiling of Java bytecode files.

#+begin_src emacs-lisp
  (defvar fernflower-path
      (file-truename "~/.local/lib/java-decompiler.jar")
      "Path to the fernflower library.")

  (use-package jdecomp
    :when (file-exists-p fernflower-path)
    :hook (archive-mode . jdecomp-mode)
    :custom
    (jdecomp-decompiler-type 'fernflower)
    (jdecomp-decompiler-paths
     `((fernflower . ,fernflower-path))))
#+end_src

** =(provide 'init)=
This concludes the =init.el= file.

#+begin_src emacs-lisp
  (provide 'init)
  ;;; init.el ends here
#+end_src

#  LocalWords:  init el startup GC unstyled UI Resizing resized ELPA
#  LocalWords:  MELPA uncomment Makefile Readline Kakoune whitespace
#  LocalWords:  Solaire DOOM's fallbacks doto Clojure Tooltips DejaVu
#  LocalWords:  tooltips Treemacs Flycheck modeline minibuffer config
#  LocalWords:  filetree Uniquify Tabline Prog TOML Geiser REPL Cmake
#  LocalWords:  cmake Yaml IDE ClojureScript flycheck clj kondo Kibit
#  LocalWords:  backend refactor refactoring linter Lua CSS Erlang VM
#  LocalWords:  scalable interop JSON vterm Json EditorConfig Paredit
#  LocalWords:  Smartparens Parinfer configs Flx runtime Posframe LSP
#  LocalWords:  posframe frontend Yasnippet Magit TODOs TODO Ediff VC
#  LocalWords:  Kakoune's Iedit DAP Hideshow workspace Separedit GCMH
#  LocalWords:  Parens readonly Flymake autoloaded Smerge popup imenu
#  LocalWords:  JDK Ripgrep ISAYT Eldoc multiline eldoc HL LocalWords
#  LocalWords:  projectless Vertico Orderless orderless

# Local Variables:
# eval: (add-hook 'after-save-hook #'org-babel-tangle nil t)
# End:
