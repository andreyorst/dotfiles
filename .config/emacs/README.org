#+title: Emacs configuration with Org Mode
#+author: Andrey Orst
#+email: andreyorst@gmail.com
#+setupfile: ./.org-defaults.org
#+startup: noinlineimages
#+property: header-args :tangle "./init.el" :results silent

[[file:.screenshot.png]]

* About this document
This is my Emacs configuration file written as Org document.
I do all edits here, then /compile/ it to initialization files.
Emacs is complex tool, and by having my configuration in Org Mode, I can separate it to different sections.
I also can add short description for packages, and toggle configuration parts on and off with ease.

I try to maintain my Emacs configuration simple, fast, and small, keeping as much of vanilla Emacs as I can.
But I'm a sane person so some aspects, which in my opinion are actually insane, are changed.

This file is self contained Emacs configuration, thus it is the only file you need to bootstrap Emacs 26 and higher.
It will configure itself, although you need [[https://orgmode.org/][Org Mode]] for this to work.
Org mode comes inbuilt with all current versions of Emacs.

If you've downloaded this file, put it to =~/.config/emacs= or =~/.emacs.d/=, and run =org-babel-tangle=, then restart Emacs.
This function exports all code blocks accordingly to =header-args= property at the top of this document, and under some headings.
As a result =init.el= and =early-init.el= files are created, located in the same directory as this file, which should be in =user-emacs-directory=.
This is why I'm using tangle approach, instead of =org-babel-load-file=, as there's no way to provide =early-init= this way.
After first tangle, every time this file is saved it gets re-tangled automatically.
And, because both =init.el= and =early-init.el= are in read only mode, only this file needs to be edited.

Since I'm trying to follow Emacs conventions, good Emacs Lisp file starts with commentary:

#+begin_src emacs-lisp
  ;;; init.el --- Emacs main configuration file -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-
  ;;;
  ;;; Commentary:
  ;;; Emacs config by Andrey Orst.
  ;;; This file was automatically generated by `org-babel-tangle'.
  ;;; Do not change this file.  Main config is located in README.org at `user-emacs-directory'
  ;;;
  ;;; Code:
#+end_src

At this point configurations will be split in different sections grouped by something common to them all.

* Initial Setup
Emacs starts fast, but as amount of packages grows it gets slower.
The init time is important because I like to close Emacs when I'm not using it.
I'm not closing and opening it for every file, or like every 15 minutes, but still.
The faster it starts - the better for me.

** =early-init.el=
:properties:
:header-args+: :tangle "./early-init.el"
:end:
These settings are going into  different init file: =earli-init.el=.
We are going to use some speedup tricks from [[https://github.com/hlissner/doom-emacs][doom-emacs]] here.
But before that, let's add top comment as we did for =init.el=:

#+begin_src emacs-lisp
  ;;; early-init.el --- early configurations -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-
  ;;;
  ;;; Commentary:
  ;;; Emacs confi by Andrey Orst.
  ;;; This file was automatically generated by `org-babel-tangle'.
  ;;; Do not change this file.  Main config is located in README.org at `user-emacs-directory'
  ;;;
  ;;; Code:
#+end_src

*** Garbage Collection
The main problem with Emacs startup is garbage collection system.
It is invoked so many times on startup that it causes quite big impact on startup time.
We're talking /seconds/.
One can raise limit when to trigger garbage collection, but this will end up in unpleasant editing experience.
So I'm declaring these variables to store default values for the GC, to restore them after initialization is finished:

#+begin_src emacs-lisp
  (defvar aorst--gc-cons-threshold gc-cons-threshold)
  (defvar aorst--gc-cons-percentage gc-cons-percentage)
  (defvar aorst--file-name-handler-alist file-name-handler-alist)
#+end_src

Now we can tweak CG.
We need to raise threshold to prevent it running.
And as well we tweak some other slow bits:

#+begin_src emacs-lisp
  (setq-default gc-cons-threshold 402653184
                gc-cons-percentage 0.6
                inhibit-compacting-font-caches t
                message-log-max 16384
                file-name-handler-alist nil)
#+end_src

Then we need a hook that restores initial values once initialization done:

#+begin_src emacs-lisp
  (add-hook 'after-init-hook
            (lambda ()
              (setq gc-cons-threshold aorst--gc-cons-threshold
                    gc-cons-percentage aorst--gc-cons-percentage
                    file-name-handler-alist aorst--file-name-handler-alist)))
#+end_src

*** Native Compiled Emacs Lisp
There's a very interesting project that I'm currently using, called [[http://akrl.sdf.org/gccemacs.html][gccemacs]].
It provides a way to compile Emacs Lisp into native code, thus making Emacs much more robust and snappy.
In order to compile everything that Emacs loads asynchronously we can set this variable to =true=.

#+begin_src emacs-lisp
  (defvar comp-deferred-compilation)
  (setq comp-deferred-compilation t)
#+end_src

This way I can compile Emacs from source as I usually do, and then continue using it as normal.
And Emacs will do it's native compilation in background for every loaded package.
That's amazing!

*** User Interface
Prevent the glimpse of un-styled Emacs by disabling these UI elements early.

#+begin_src emacs-lisp
  (setq initial-frame-alist '((width . 170)
                              (height . 56)
                              (tool-bar-lines . 0)
                              (bottom-divider-width . 0)
                              (right-divider-width . 1))
        default-frame-alist initial-frame-alist)
#+end_src

Resizing frame is also expensive so we inhibit it.
Setting =x-gtk-resize-child-frames= variable to =resize-mode= fixes the [[https://gitlab.gnome.org/GNOME/mutter/-/issues/840][issue]] with child frames not being resized correctly under GNOME Shell.

#+begin_src emacs-lisp
  (setq frame-inhibit-implied-resize t
        x-gtk-resize-child-frames 'resize-mode)
#+end_src

*** =straight.el=
Straight is an alternative way to manage package installations.
It is a purely functional package manager.
It installs packages from Git repositories listed on ELPA and MELPA, or from Git URL.
First, we have to bootstrap it:

#+begin_src emacs-lisp
  (defvar bootstrap-version)
  (defvar straight-repository-branch)
  (setq straight-repository-branch "develop")
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

Now we can install =use-package= with it:

#+begin_src emacs-lisp
  (straight-use-package 'use-package)
  (defvar straight-use-package-by-default)
  (setq straight-use-package-by-default t)
#+end_src

*** early =package.el= settings
=package.el= initialization is expensive so we disable it at startup:

#+begin_src emacs-lisp
  (setq package-enable-at-startup nil)
#+end_src

*** =(provide 'early-init)=
This concludes the =early-init.el= file.

#+begin_src emacs-lisp
  (provide 'early-init)
  ;;; early-init.el ends here
#+end_src

*** Loading =early-init.el= in Emacs 26 and earlier
:properties:
:header-args+: :tangle "./init.el"
:end:
Before Emacs 27 there were no such thing as =eraly-init.el=.
So if I will use older Emacs with this configuration it will miss settings that are done there.
This code manually loads this file in such case:

#+begin_src emacs-lisp
  (unless (featurep 'early-init)
    (load (expand-file-name "early-init" user-emacs-directory)))
#+end_src

We do it as early as possible, as it is important to load these settings before all settings specified in =init.el=.

** COMMENT =package.el=
#+begin_comment
This section is commented because I'm no longer using =package.el= as my package manager.
Instead I'm using =straight.el=, which provides more facilites, and does not have most of =package.el= problems.
However, I still keep this configuration, since I might switch back, and I would not want to configure everything again.
If you want to use =package.el= instead, make sure to uncomment this heading, and comment =straight.el= heading.
#+end_comment

To obtain plugins we need =package.el= package.
Although this is builtin and convenient, it's also slow and messy.
Instead of using =package= directly we will use =use-package= to manage package configurations.

Melpa is a package repository, that I use to get packages.
Since all packages that I need can be obtained from there, I did not bothered with different methods of installation.

#+begin_src emacs-lisp
  (defvar package-archives)
  (setq package-archives
        '(("gnu" . "https://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")))
#+end_src

Emacs 26.2 had a bug with downloading from Elpa.
Here's a workaround, although it is dangerous to use this, as it is pretty insecure.
So please upgrade to more recent Emacs, in case you're still using Emacs 26.2.

#+begin_src emacs-lisp
  (when (version= emacs-version "26.2")
    (defvar gnutls-algorithm-priority)
    (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3"))
#+end_src

Found this trick [[https://genehack.blog/2020/04/a-bit-of-emacs-advice/][here]], and adopted the idea.
But instead of using Boolean, I've decided to track time since last package refresh, and use customize to store it.
This variable is going to hold either =nil= or date-time string.

#+begin_src emacs-lisp
  (defcustom package-last-refresh-date nil
    "Date and time when package lists have been refreshed.

  This variable is then used to check whether
  `package-refresh-contents' call is needed before calling
  `package-install'. Value of this varialbe is updated when
  `package-refresh-contents' is called.

  See `package-refresh-hour-threshold' for amount of time needed to
  trigger refresh."
    :type 'string
    :group 'package)
#+end_src

And we need a variable that holds amount of hours that will trigger the refresh:

#+begin_src emacs-lisp
  (defcustom package-automatic-refresh-threshold 24
    "Amount of hours since last `package-refresh-contents' call
  needed to trigger automatic refresh before calling `package-install'."
    :type 'number
    :group 'package)
#+end_src

This advice first checks if our date-time string exists, and then checks if there's more than 24 hours passed since last check.

#+begin_src emacs-lisp
  (define-advice package-install (:before (&rest _))
    (let ((seconds-per-hour 3600))
      (when (or (null package-last-refresh-date)
                (> (/ (float-time
                       (time-subtract (date-to-time (format-time-string "%Y-%m-%dT%H:%M"))
                                      (date-to-time package-last-refresh-date)))
                      seconds-per-hour)
                   package-automatic-refresh-threshold))
        (package-refresh-contents))))
#+end_src

Now all packages that use =package-install= should periodically refresh package contents.
In order to update time we also have to advice =package-refresh-contents=:

#+begin_src emacs-lisp
  (define-advice package-refresh-contents (:after (&rest _))
    (customize-save-variable 'package-last-refresh-date (format-time-string "%Y-%m-%dT%H:%M")))
#+end_src

This way if I refresh packages from package menu, or manually or via that =package-install= advice =package-last-refresh-date= will be updated and persistently saved via =custom=.

Last thing we need to do is to install =use-package=:

#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (defvar use-package-always-ensure)
  (setq use-package-always-ensure t)
#+end_src

** =use-package=
I use =use-package= to install, load and configure my packages.
I find this way very consistent and easy to understand, and maintain.
At this point =use-package= should be already installed by either =package.el= or =straight.el=, depending on what is enabled above.
Only thing left to do is to require =use-package= itself:

#+begin_src emacs-lisp
  (require 'use-package)
#+end_src

* Defaults
Emacs is old.
I understand that back then it could be appropriate decisions, but as of today they are completely obliterated by the passage of time.

** User Credentials
Let's set full name and e-mail address in case I would send e-mail from Emacs, or some modes can use those settings, like Org Mode:

#+begin_src emacs-lisp
  (use-package startup
    :no-require t
    :straight nil
    :custom
    (user-mail-address "andreyorst@gmail.com")
    (user-full-name "Andrey Orst"))
#+end_src

** Bell
I'm not trying to insult on anyone, but usage of the bell is just insane.
It's not 1980's, computers have their own speakers and rich displays, why would anyone want to use builtin speaker?
Why everyone should know when I'm mistaken?
Disable bell.

#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
#+end_src

** Backups
I don't know who decided that having backups all over the place is good idea, but I don't think alike.
Instead let's put backup files in default cache directory:

#+begin_src emacs-lisp
  (use-package files
    :straight nil
    :custom
    (backup-by-copying t)
    (create-lockfiles nil)
    (backup-directory-alist '(("." . "~/.cache/emacs-backups")))
    (auto-save-file-name-transforms '((".*" "~/.cache/emacs-backups/" t))))
#+end_src

** Yes or No
For some reason in some situations Emacs asks for typing =yes= or =no= explicitly, instead of accepting =y= or =n=.
This can be fixed with this.

#+begin_src emacs-lisp
  (use-package subr
    :no-require t
    :straight nil
    :init
    (fset 'yes-or-no-p 'y-or-n-p))
#+end_src

** Echo Keystrokes
Emacs displays pressed key after some time but it's too fast for me, because I use Emacs on the phone too, and the keyboard is a bit small for lightning fast typing.

#+begin_src emacs-lisp
  (add-hook 'after-init-hook (lambda () (setq echo-keystrokes 5)))
#+end_src

** Mouse and Scrolling
I don't want menus on shift clicks:

#+begin_src emacs-lisp
  (global-unset-key (kbd "S-<down-mouse-1>"))
  (global-unset-key (kbd "<mouse-3>"))
  (global-set-key [mouse-3] menu-bar-edit-menu)
  (global-unset-key (kbd "S-<mouse-3>"))
#+end_src

I also don't like how Emacs handles scrolling, that it speeds it up and automatically scrolls horizontally.

Also, changing =mouse-highlight= to =nil= value disables highlighting of hovered item when the point moves which is kinda convenient when working with =flycheck=.

#+begin_src emacs-lisp
  (setq-default mouse-wheel-progressive-speed nil
                auto-window-vscroll nil
                mouse-highlight nil
                hscroll-step 1
                hscroll-margin 1
                scroll-step 10)
#+end_src

If by chance I would need to use Emacs in terminal, I'd like to keep mouse working:

#+begin_src emacs-lisp
  (unless (display-graphic-p)
    (xterm-mouse-mode t))
#+end_src

** Tab character
Another default setting that I kinda dislike.
Not that I'm a fan of spaces over tabs - tabs have their use and spaces do to, but I find that there are much more modes or even languages that expect spaces, and not tabs.
For the record, I need tab characters only when I work with C/C++ code and Makefile rules, and pretty much everything else uses spaces.

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

** Custom File and Disabled Commands
I don't like custom, and especially would like to stop it from interfering to my configuration files, so lets move it to separate file.

#+begin_src emacs-lisp
  (use-package cus-edit
    :straight nil
    :custom
    (custom-file (expand-file-name "custom.el" user-emacs-directory))
    :init
    (load custom-file :noerror))
#+end_src

I also don't like that Emacs has disabled commands, and enabling them modifies my =init.el= that I don't modify myself.
Let's put those commands to =disabled.el= file instead:

#+begin_src emacs-lisp
  (defvar aorst--disabled-commands (expand-file-name "disabled.el" user-emacs-directory)
    "File to store disabled commands, that were enabled permamently.")
  (defadvice en/disable-command (around put-in-custom-file activate)
    "Put declarations in disabled.el."
    (let ((user-init-file aorst--disabled-commands))
      ad-do-it))
  (load aorst--disabled-commands :noerror)
#+end_src

** History
Another feature I want is history between sessions. I'm not sure why it isn't default.

#+begin_src emacs-lisp
  (use-package savehist
    :straight nil
    :config (savehist-mode 1))
#+end_src

** Keyboard Layout
I use two keyboard layouts: =qwerty= and =Ð¹Ñ†ÑƒÐºÐµÐ½=, therefore I need a way to switch between those.
But there's a problem - such chords as =C-x= which will become a =C-Ñ‡= if I select Cyrillic layout in the OS.
Luckily for me, Emacs provides a method to switch layouts within Emacs with =C-\=, so all common shortcuts will still work fine.

#+begin_src emacs-lisp
  (use-package mule-cmds
    :no-require t
    :straight nil
    :custom
    (default-input-method 'russian-computer))
#+end_src

I'm not using =russian-jcuken= here because this layout has inverted number-line, so to access numbers I need to use Shift key.
=russian-computer= doesn't have this problem.

** UTF8
Let's use =UTF8= if we can:

#+begin_src emacs-lisp
  (prefer-coding-system 'utf-8)
  (when (display-graphic-p)
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src

** Default Major Mode
I would like =*scratch*= buffer to use =fundamental= mode, so fully empty Emacs session loads faster.
Since it's no longer Emacs Lisp interaction buffer, let's also remove initial message:

#+begin_src emacs-lisp
  (use-package startup
    :no-require t
    :straight nil
    :custom
    (initial-major-mode 'fundamental-mode)
    (initial-scratch-message ""))
#+end_src

** Selection
It is convenient to delete selection by typing:

#+begin_src emacs-lisp
  (use-package delsel
    :straight nil
    :init
    (delete-selection-mode t))
#+end_src

** Default Bindings and More
Configurations for inbuilt =simple.el= module.
By default Emacs uses =kill-region= command on =C-w= shortcut.
I find this counter intuitive.
GNU Readline uses =C-w= to kill word backwards.
Other software uses this shortcut to kill window.
I prefer Readline approach.
Also I've missed =o= and =O= commands from Kakoune.
With =newline-below= and =newline-above= it is now possible to have same shortcuts in Emacs.

Emacs has nice function, =zap-up-to-char= but for some reason it's not bound to any key.
I find it more usable than =zap-to-char= so let's swap those here.

Also, I don't want my files to contain trailing whitespaces, so =before-save-hook= hook will get rid of those automatically for me.

#+begin_src emacs-lisp
  (use-package simple
    :straight nil
    :bind (("C-w" . aorst/kill-region-or-word)
           ("C-x C-x" . aorst/exchange-point-and-mark)
           ("C-o" . aorst/newline-below)
           ("C-S-o" . aorst/newline-above)
           ("M-z" . zap-up-to-char)
           ("C-x k" . kill-this-buffer)
           ("M-S-z" . zap-to-char))
    :hook ((before-save . delete-trailing-whitespace)
           (overwrite-mode . aorst/overwrite-set-cursor-shape))
    :init
    (defun aorst/kill-region-or-word (arg)
      (interactive "*p")
      (if (and transient-mark-mode
               mark-active)
          (kill-region (region-beginning) (region-end))
        (backward-kill-word arg)))
    (defun aorst/exchange-point-and-mark (arg)
     (interactive "*p")
     (when (and transient-mark-mode
                mark-active)
       (exchange-point-and-mark)))
    (defun aorst/newline-below ()
      (interactive)
      (end-of-line)
      (newline-and-indent))
    (defun aorst/newline-above ()
      (interactive)
      (back-to-indentation)
      (newline-and-indent)
      (forward-line -1)
      (indent-according-to-mode))
    (defun aorst/overwrite-set-cursor-shape ()
      (when (display-graphic-p)
        (setq cursor-type (if overwrite-mode 'box 'bar)))))
#+end_src

** Line truncation
Let's disable line wrapping by default, unless I need it:

#+begin_src emacs-lisp
  (setq-default truncate-lines t)
#+end_src

* Functions
This section describes functions I have defined for use inside configurations of various packages, that are general enough to be placed in particular package configuration.
For example when function is shared between configurations and some configuration may not be loaded.

I prefix my functions with =aorst/= and variables with =aorst--= to make those easier to browse with =ivy= and to explicitly define that the function is not a part of a particular package.

** =real-buffer-p=
This function decides if buffer should be considered a "real" buffer.
Real buffer concept is introduced [[*Solaire Mode][Solaire Mode]] but is actually useful in several other places.
However, wheres Solaire Mode decided if buffer is real by checking if this is a file visiting buffer, I instead decide which buffers are not real, and everything else as real buffers.
This is due to the fact of how I stylize [[*Tabline][Tabline]] package from Emacs 27, and it looks nice when buffers that have tabs are real buffers.

#+begin_src emacs-lisp
  (defun aorst/real-buffer-p (&optional buffer)
    "Determines whether BUFFER is real."
    (not (or (string-match-p
              (regexp-opt '("*Treemacs"
                            "*vterm*"
                            " *Minibuf"
                            " *Echo Area"
                            "*Process List*"
                            " *LV*"))
              (buffer-name buffer))
             (minibufferp))))
#+end_src

** =escape=
One thing that bothered me is that =C-g= is universal way to cancel things in Emacs, but you have to be in exact window to cancel action.
This function intelligently tries to cancel regardless of active window:

#+begin_src emacs-lisp
  (defun aorst/escape ()
    "Quit in current context.

  When there is an active minibuffer and we are not inside it close
  it.  When we are inside the minibuffer use the regular
  `minibuffer-keyboard-quit' which quits any active region before
  exiting.  When there is no minibuffer `keyboard-quit' unless we
  are defining or executing a macro."
    (interactive)
    (cond ((active-minibuffer-window)
           (if (minibufferp)
               (minibuffer-keyboard-quit)
             (abort-recursive-edit)))
          ((bound-and-true-p iedit-mode)
           (iedit-quit))
          (t
           (unless (or defining-kbd-macro
                       executing-kbd-macro)
             (keyboard-quit))))
    (message this-command))
  (global-set-key [remap keyboard-quit] #'aorst/escape)
#+end_src

** =font-installed-p=
This function checks if font is available on the system.

#+begin_src emacs-lisp
  (defun aorst/font-installed-p (font-name)
    "Check if font with FONT-NAME is available."
    (find-font (font-spec :name font-name)))
#+end_src

** =indent-buffer=
This function is kinda a way to indent a buffer by using language indentation rules provided by current mode.
If there's a tool that can properly format buffer it should be used instead of this function.

#+begin_src emacs-lisp
  (defun aorst/indent-buffer ()
    "Indent whole buffer."
    (interactive)
    (save-excursion
      (save-restriction
        (indent-region (point-min) (point-max)))))

  (global-set-key (kbd "C-c C-M-f") #'aorst/indent-buffer)
#+end_src

** =split-paragraph-into-lines=
This function helps me follow one sentence per line style of edxiting.
I can write text as normal, fill it if I feel like it, and then reformat it with a single keybinding.

#+begin_src emacs-lisp
  (defun aorst/split-pararagraph-into-lines ()
    "Split current paragraph into lines with one sentence each."
    (interactive)
    (save-excursion
      (let ((fill-column (point-max)))
        (fill-paragraph))
      (let ((auto-fill-p auto-fill-function)
            (end (progn (end-of-line) (backward-sentence) (point))))
        (back-to-indentation)
        (unless (= (point) end)
          (auto-fill-mode -1)
          (while (< (point) end)
            (forward-sentence)
            (delete-horizontal-space)
            (newline-and-indent))
          (deactivate-mark)
          (when auto-fill-p
            (auto-fill-mode t))
          (when (looking-at "^$")
            (backward-delete-char 1))))))
#+end_src

* User Interface
Packages that affect user interface.

** Splash Screen
Emacs displays splash screen once started with no files.
I don't need it, so let's disable it.

#+begin_src emacs-lisp
  (use-package startup
    :no-require t
    :straight nil
    :custom
    (inhibit-splash-screen t))
#+end_src

** Menus and Tooltips
I don't need all these tooltips, menus and scroll bars.
Emacs enables all of those by default, so let's disable them as early as possible:

#+begin_src emacs-lisp
  (tooltip-mode -1)
  (fset 'menu-bar-open nil)

  (when window-system
    (scroll-bar-mode -1)
    (tool-bar-mode -1))
#+end_src

** Cursor Type
Also let's use bar cursor when in window system, which is visible only
in active window:

#+begin_src emacs-lisp
  (when window-system
    (setq-default cursor-type 'bar
                  cursor-in-non-selected-windows nil))
#+end_src

** Font
Currently I'm using [[https://www.jetbrains.com/lp/mono/][JetBrains Mono]] font, that has nice support for ligatures, and overall looks great.
I'm also a big fan of [[https://github.com/source-foundry/Hack][Hack]] font.
It has nice support of languages and styles like *bold*, /italics/ for not only Latin languages.
If neither =JetBrainsMono=, nor =Hack= are not found, we try =Source Code Pro= as a fallback option.

#+begin_src emacs-lisp
  (cond ((aorst/font-installed-p "JetBrainsMono")
         (set-face-attribute 'default nil :font "JetBrainsMono 10"))
        ((aorst/font-installed-p "Hack")
         (set-face-attribute 'default nil :font "Hack 10"))
        ((aorst/font-installed-p "Source Code Pro")
         (set-face-attribute 'default nil :font "Source Code Pro 10")))
#+end_src

*** Ligatures
With the inclusion of [[https://github.com/harfbuzz/harfbuzz][HarfBuzz]] support into Emacs 27+, it is now possible to use =auto-composition-mode= to add ligatures.
What's especially cool, is that we can specify which ligatures we want, by defining regular expressions:

#+begin_src emacs-lisp
  (when (aorst/font-installed-p "JetBrainsMono")
    (let ((ligatures `((?-  ,(regexp-opt '("-|" "-~" "---" "-<<" "-<" "--" "->" "->>" "-->")))
                       (?/  ,(regexp-opt '("///" "/=" "/==" "/>" "//"))) ;; "/*"
                       (?*  ,(regexp-opt '("*>"))) ;; "***" "*/"
                       (?<  ,(regexp-opt '("<-" "<<-" "<=>" "<=" "<|" "<||" "<|||" "<|>" "<:" "<>" "<-<"
                                             "<<<" "<==" "<<=" "<=<" "<==>" "<-|" "<<" "<~>" "<=|" "<~~" "<~"
                                             "<$>" "<$" "<+>" "<+" "</>" "</" "<*" "<*>" "<->" "<!--")))
                       (?:  ,(regexp-opt '(":>" ":<" ":::" "::" ":?" ":?>" ":=" "::=")))
                       (?=  ,(regexp-opt '("=>>" "==>" "=/=" "=!=" "=>" "===" "=:=" "==")))
                       (?!  ,(regexp-opt '("!==" "!!" "!=")))
                       (?>  ,(regexp-opt '(">]" ">:" ">>-" ">>=" ">=>" ">>>" ">-" ">=")))
                       (?&  ,(regexp-opt '("&&&" "&&")))
                       (?|  ,(regexp-opt '("|||>" "||>" "|>" "|]" "|}" "|=>" "|->" "|=" "||-" "|-" "||=" "||")))
                       (?.  ,(regexp-opt '(".." ".?" ".=" ".-" "..<" "...")))
                       (?+  ,(regexp-opt '("+++" "+>" "++")))
                       (?\[ ,(regexp-opt '("[||]" "[<" "[|")))
                       (?\{ ,(regexp-opt '("{|")))
                       (?\? ,(regexp-opt '("??" "?." "?=" "?:")))
                       (?#  ,(regexp-opt '("####" "###" "#[" "#{" "#=" "#!" "#:" "#_(" "#_" "#?" "#(" "##")))
                       (?\; ,(regexp-opt '(";;")))
                       (?_  ,(regexp-opt '("_|_" "__")))
                       (?~  ,(regexp-opt '("~~" "~~>" "~>" "~-" "~@")))
                       (?$  ,(regexp-opt '("$>")))
                       (?^  ,(regexp-opt '("^=")))
                       (?\] ,(regexp-opt '("]#"))))))
      (dolist (char-regexp ligatures)
        (apply (lambda (char regexp)
                 (set-char-table-range
                  composition-function-table
                  char `([,regexp 0 font-shape-gstring])))
               char-regexp))))
#+end_src

Although I don't need =auto-composition-mode= for all buffers, so let's disable it, and enable manually later:

#+begin_src emacs-lisp
  (use-package composite
    :straight nil
    :hook (prog-mode . auto-composition-mode)
    :init (global-auto-composition-mode -1))
#+end_src

** Icons
=all-the-icons= package provides nice icons for Emacs via custom fonts.

#+begin_src emacs-lisp
  (use-package all-the-icons
    :config
    (when (and (not (aorst/font-installed-p "all-the-icons"))
               (window-system))
      (all-the-icons-install-fonts t)))
#+end_src

I don't use this package directly yet, but some other packages do, like DOOM Modeline or Treemacs.

** Theme
I'm using *doom-themes* package to make my Emacs look modern.
This theme collection was developed for [[https://github.com/hlissner/doom-emacs][DOOM Emacs]], and I find these themes actually great on its own.
This package contains nice variant of Atom-like One theme which I like.
But it is also an amazingly well put set of themes, which define colors for pretty much every popular Emacs package.

#+begin_src emacs-lisp
  (use-package doom-themes
    :custom
    (doom-themes-enable-bold t)
    (doom-themes-enable-italic t)
    :custom-face
    (shadow    ((t (:foreground "grey50"))))
    (highlight ((t (:foreground unspecified
                    :distant-foreground unspecified
                    :background unspecified))))
    (org-block-begin-line ((t (:slant unspecified
                               :background unspecified
                               :inherit org-block))))
    (org-block-end-line   ((t (:inherit org-block-begin-line))))
    (secondary-selection  ((t (:foreground unspecified
                               :background unspecified
                               :inherit region))))
    (org-level-2 ((t (:inherit outline-3))))
    (org-level-3 ((t (:inherit outline-4))))
    (org-level-4 ((t (:inherit outline-2))))
    (org-level-5 ((t (:inherit outline-1))))
    (org-level-6 ((t (:inherit outline-3))))
    (org-level-7 ((t (:inherit outline-4))))
    (org-level-8 ((t (:inherit outline-2))))
    (org-drawer ((t (:foreground nil :inherit font-lock-comment-face))))
    (font-lock-comment-face ((t (:background unspecified))))
    (fill-column-indicator ((t (:inherit font-lock-comment-face))))
    :config
    (if (display-graphic-p)
        (load-theme 'doom-one-light t)
      (load-theme 'doom-one t)))
#+end_src

** Solaire Mode
This package helps distinguish buffers that have file opened and buffers that are for utilities like file browser.
Also it has cool name!
=\[T]/=

I really want Solaire to treat =*scratch*= buffer as real.
For that I need to define my own function that will decide if buffer is real or not.
Now we can set up Solaire Mode and assign =aorst/real-buffer-p= to =solaire-mode-real-buffer-fn=.

#+begin_src emacs-lisp
  (use-package solaire-mode
    :straight (:host github
               :repo "hlissner/emacs-solaire-mode")
    :commands (solaire-global-mode
               solaire-mode-swap-bg
               turn-on-solaire-mode
               solaire-mode-in-minibuffer
               solaire-mode-reset)
    :hook (((after-revert
             change-major-mode
             org-src-mode) . turn-on-solaire-mode)
           (snippet-mode . solaire-mode))
    :custom
    (solaire-mode-real-buffer-fn #'aorst/real-buffer-p)
    :config
    (solaire-global-mode 1)
    (defun aorst/create-image-with-background-color (args)
      "Specify background color of Org-mode inline image through modify `ARGS'."
      (apply (lambda (file type data-p &rest props)
               (append (list file type data-p)
                       (list :background (face-attribute
                                          (let ((face (cadr (assq 'default face-remapping-alist))))
                                            (if (facep face) face 'default))
                                          :background nil t))
                       props))
             args))
    (advice-add 'create-image :filter-args #'aorst/create-image-with-background-color)
    (solaire-mode-swap-bg))
#+end_src

** Mode-line
Mode-line is displayed at the bottom of each buffer, and shows necessary information about buffer state.
There are several packages that can make your mode-line appear differently, but most will reuse mode-line settings.

#+begin_src emacs-lisp
  (setq-default column-number-mode t
                line-number-mode t
                size-indication-mode nil
                mode-line-position nil
                mode-line-percent-position nil
                mode-line-in-non-selected-windows nil)
#+end_src

Also, let's remove that bevel thing.

#+begin_src emacs-lisp
  (dolist (face '(mode-line mode-line-inactive))
    (set-face-attribute face nil
                        :box nil))
#+end_src

*** Mode-line functions
Most of these functions are based on what [[https://github.com/seagle0128/doom-modeline][DOOM Modeline]] does.
Although I want to use more compact mode-line, without many additional settings that DOOM Mode-line provides.

**** =mode-line-buffer-name=
Buffer name module for mode-line.
Returns buffer name or empty string if buffer is special and starts from space.

#+begin_src emacs-lisp
  (defun aorst/mode-line-buffer-name ()
    (let* ((name (buffer-name))
           (match (string-match " " name)))
      (if (and match (= match 0)) nil (concat "  " name))))
#+end_src

**** =mode-line-buffer-modified=
Modified state module for mode-line.

#+begin_src emacs-lisp
  (defun aorst/mode-line-buffer-modified ()
    (when (and buffer-file-name (buffer-modified-p))
        (if (char-displayable-p ?ðŸ’¾) " ðŸ’¾" "*")))
#+end_src

**** =mode-line-line-column=
Line-column module for mode-line.

#+begin_src emacs-lisp
  (defun aorst/mode-line-line-column ()
    (propertize
     "  %C:%l"
     'help-echo "goto line"
     'local-map (let ((map (make-sparse-keymap)))
                  (define-key map [mode-line mouse-1] #'goto-line)
                  map)))
#+end_src

**** =mode-line-line-encoding=
Line encoding module for mode-line.

#+begin_src emacs-lisp
  (defun aorst/mode-line-line-encoding ()
    (let ((eol (coding-system-eol-type buffer-file-coding-system)))
      (propertize
       (pcase eol
         (0 "  LF")
         (1 "  CRLF")
         (2 "  CR")
         (_ ""))
       'help-echo (format "End-of-line style: %s"
                          (pcase eol
                            (0 "Unix-style LF")
                            (1 "DOS-style CRLF")
                            (2 "Mac-style CR")
                            (_ "Undecided")))
       'local-map (let ((map (make-sparse-keymap)))
                    (define-key map [mode-line mouse-1] 'mode-line-change-eol)
                    map))))
#+end_src

**** =mode-line-input-method=
Input method module for mode-line.

#+begin_src emacs-lisp
  (defun aorst/mode-line-input-method ()
    (when current-input-method
      (propertize
       (concat "  " current-input-method-title)
       'help-echo (concat
                   "Current input method: "
                   current-input-method
                   "\nmouse-2: Disable input method\nmouse-3: Describe current input method")
       'local-map mode-line-input-method-map)))
#+end_src

**** =mode-line-buffer-encoding=
Buffer encoding module for mode-line.

#+begin_src emacs-lisp
  (defun aorst/mode-line-buffer-encoding ()
    (propertize
     (let ((sys (coding-system-plist buffer-file-coding-system)))
       (if (memq (plist-get sys :category)
                 '(coding-category-undecided coding-category-utf-8))
           "  UTF-8"
         (concat "  " (upcase (symbol-name (plist-get sys :name))))))
     'help-echo 'mode-line-mule-info-help-echo
     'local-map mode-line-coding-system-map))
#+end_src

**** =mode-line-indent-mode=
Indentation info module for mode-line.

#+begin_src emacs-lisp
  (defvar-local aorst--mode-line--current-major-mode nil
    "Holds current major mode.
  Used for quicker check if `aorst/mode-line-indent-mode' need to
  do any meaningful stuff.")

  (defvar-local aorst--mode-line--indent-var nil
    "Holds variable that is used for setting indent offset in current major mode.
  Used for both checking if we need to do meaningful work in
  `aorst/mode-line-indent-mode', and for getting updated value.")

  (defvar-local aorst--mode-line--indent-var-value nil
    "Holds indent offset value, that was gathered before.
  Used to check if we need to preform meaningful work in
  `aorst/mode-line-indent-mode'.")

  (defvar-local aorst--mode-line--indent-mode-string nil)

  (defun aorst/mode-line-indent-mode ()
    "Compute mode-line string with current indent mode.
  Does heavy work only if major-mode has changed since last call,
  or if current indent offset has changed since last call, or if
  there's no previous result of this function stored."
    (unless (and (eq major-mode aorst--mode-line--current-major-mode)
                 (eq aorst--mode-line--indent-var-value
                     (symbol-value aorst--mode-line--indent-var))
                 aorst--mode-line--indent-mode-string)
      (setq-local aorst--mode-line--current-major-mode major-mode)
      (setq-local aorst--mode-line--indent-var (aorst/mode-line--get-indent-var))
      (setq-local aorst--mode-line--indent-var-value (symbol-value aorst--mode-line--indent-var))
      (setq-local aorst--mode-line--indent-mode-string
                  (propertize
                   (concat "  "
                           (when (and (not indent-tabs-mode)
                                      aorst--mode-line--indent-var-value)
                             (format "%d " aorst--mode-line--indent-var-value))
                           (if indent-tabs-mode "Tabs" "Spaces"))
                   'help-echo (concat "Indent mode"
                                      (when aorst--mode-line--indent-var
                                        (format ": %S" aorst--mode-line--indent-var))
                                      "\nmouse-1: toggle indent "
                                      (if indent-tabs-mode "Spaces" "Tabs")
                                      " mode")
                   'local-map (let ((map (make-sparse-keymap)))
                                (define-key map [mode-line mouse-1] 'aorst/toggle-indent-mode)
                                map))))
    aorst--mode-line--indent-mode-string)

  (defun aorst/mode-line--get-indent-var ()
    "Get variable that holds indent offset for current major mode.
  Uses `editorconfig-indentation-alist' variable as a source for
  all relationshipts between major modes and their respective
  offset variables."
    (when (boundp 'editorconfig-indentation-alist)
      (car (assoc-default
            major-mode
            editorconfig-indentation-alist
            (lambda (car key)
              (provided-mode-derived-p key car))))))

  (defun aorst/toggle-indent-mode ()
    "Toggle `indent-tabs-mode' on and off."
    (interactive)
    (setq-local indent-tabs-mode (not indent-tabs-mode)))
#+end_src

**** =mode-line-mode-name=
Major mode module for mode-line

#+begin_src emacs-lisp
  (defvar-local aorst--mode-line--major-mode-string nil)

  (defun aorst/mode-line-mode-name ()
    (unless (and (eq aorst--mode-line--current-major-mode
                     major-mode)
                 aorst--mode-line--major-mode-string)
      (setq-local aorst--mode-line--major-mode-string
                 (propertize
                   (concat "  " (format-mode-line mode-name))
                   'help-echo (format "Major-mode: %s" (format-mode-line mode-name)))))
    aorst--mode-line--major-mode-string)
#+end_src

**** =mode-line-git-branch=
Git branch module for mode-line.

#+begin_src emacs-lisp
  (defun aorst/mode-line-git-branch ()
    (when (and vc-mode buffer-file-name)
      (let* ((str (when vc-display-status
                    (substring
                     vc-mode
                     (+ (if (eq (vc-backend buffer-file-name) 'Hg) 2 3)
                        2)))))
        (when str
          (concat (if (char-displayable-p ?î‚ ) "  î‚  " "  @ ") str)))))
#+end_src

**** =mode-line-readonly=
Read only state module for mode-line.

#+begin_src emacs-lisp
  (defun aorst/mode-line-readonly ()
    (when buffer-read-only
      (propertize
       (if (char-displayable-p ?ðŸ”’) "  ðŸ”’" "  RO")
       'help-echo "Make file writable"
       'local-map (let ((map (make-sparse-keymap)))
                    (define-key map [mode-line mouse-1] 'mode-line-toggle-read-only)
                    map))))
      ;; (propertize
      ;;  (if (char-displayable-p ?ðŸ”“) "  ðŸ”“" "  RW")
      ;;  'help-echo "Make file read only"
      ;;  'local-map (let ((map (make-sparse-keymap)))
      ;;               (define-key map [mode-line mouse-1] 'mode-line-toggle-read-only)
      ;;               map))))
#+end_src

**** =mode-line-flycheck=
Flycheck module for mode-line.

#+begin_src emacs-lisp
  (defun aorst/mode-line-flycheck ()
    (when (bound-and-true-p flycheck-mode)
      (concat
       "  "
       (pcase flycheck-last-status-change
         (`not-checked (propertize "-" 'help-echo "Flycheck: not checked"))
         (`no-checker (propertize "-" 'help-echo "Flycheck: no checker"))
         (`running (propertize "*" 'help-echo "Flycheck: checking"))
         (`errored (propertize "!" 'help-echo "Flycheck: error"))
         (`finished
          (let-alist (flycheck-count-errors flycheck-current-errors)
            (propertize (format "%s/%s" (or .error 0) (or .warning 0))
                        'help-echo (if (or .error .warning)
                                       "Flycheck: errors\nmouse-1: list errors"
                                     "Flycheck: no errors or warnings")
                        'local-map 'flycheck-error-list-mode-line-map)))
         (`interrupted (propertize "x" 'help-echo "Flycheck: interrupted"))
         (`suspicious (propertize "?" 'help-echo "Flycheck: suspicious"))))))
#+end_src

**** =mode-line-structural=
Support for various structural editing modes in mode-line.

#+begin_src emacs-lisp
  (defun aorst/mode-line-structural ()
    (cond ((bound-and-true-p parinfer-rust-mode)
           (propertize (concat "  Parinfer: " parinfer-rust--mode)
                       'help-echo (concat "Parinfer " parinfer-rust--mode
                                          " mode is enabled for current buffer\nmouse-1: toggle Parinfer mode")
                       'local-map (let ((map (make-sparse-keymap)))
                                    (define-key map [mode-line mouse-1] #'parinfer-rust-toggle-paren-mode)
                                    map)))
          ((bound-and-true-p paredit-mode)
           (propertize "  Paredit" 'help-echo "Paredit mode is enabled for current buffer"))
          ((bound-and-true-p lispy-mode)
           (propertize "  Lispy" 'help-echo "Lispy mode is enabled for current buffer"))
          ((bound-and-true-p electric-pair-mode)
           (propertize "  EPM" 'help-echo "Electric Pair mode is enabled for current buffer"))))
#+end_src

*** Mode-line format
Fallback format for modeline.

#+begin_src emacs-lisp
  (setq-default
   mode-line-format
   '(:eval
     (let ((format
            (format-mode-line
             (concat
              (aorst/mode-line-buffer-modified)
              (aorst/mode-line-readonly)
              (aorst/mode-line-line-column)
              (aorst/mode-line-input-method)
              (aorst/mode-line-line-encoding)
              (aorst/mode-line-buffer-encoding)
              (aorst/mode-line-indent-mode)
              (aorst/mode-line-mode-name)
              (aorst/mode-line-git-branch)
              (aorst/mode-line-flycheck)
              (aorst/mode-line-structural)))))
       (concat (make-string (- (window-width)
                               (string-width format)
                               1)
                            ?\s)
               format))))
#+end_src

*** Mini Modeline
A very interesting package that displays mode-line in the echo area (minibuffer).
Currently it uses default format, and I'm looking forward to integrate DOOM mode-line with it.

#+begin_src emacs-lisp
  (use-package mini-modeline
    :straight (:host github
               :repo "kiennq/emacs-mini-modeline")
    :custom
    (mini-modeline-display-gui-line nil)
    (mini-modeline-r-format
     '(:eval (concat
              (aorst/mode-line-buffer-modified)
              (aorst/mode-line-readonly)
              (aorst/mode-line-line-column)
              (aorst/mode-line-input-method)
              (aorst/mode-line-line-encoding)
              (aorst/mode-line-buffer-encoding)
              (aorst/mode-line-indent-mode)
              (aorst/mode-line-mode-name)
              (aorst/mode-line-git-branch)
              (aorst/mode-line-flycheck)
              (aorst/mode-line-structural))))
    :config
    (mini-modeline-mode t))
#+end_src

** Frame
Some tweaks to window divider colors.

#+begin_src emacs-lisp
  (when window-system
    (use-package frame
      :straight nil
      :custom
      (window-divider-default-bottom-width 1)
      (window-divider-default-right-width 1)
      (window-divider-default-places t)
      :config
      (window-divider-mode t)
      (set-face-attribute 'window-divider nil
                          :foreground (face-attribute
                                       'mode-line-inactive :background))))
#+end_src

** Title
Emacs uses weird method of naming a frame.
I'd like to see a file I'm currently working on in the task bar in case my Emacs was minimized for some reason.
But I don't really need all these special buffers in the frame title.
We can avoid this with this little check for space and asterisk at the beginning of buffer name.

#+begin_src emacs-lisp
  (setq-default frame-title-format
                '(:eval (let ((match (string-match "[ *]" (buffer-name))))
                          (if (and match (= match 0)) "Emacs" "%b â€” Emacs"))))
#+end_src

** Treemacs
To make Emacs look more like a modern text editor we need a file explorer.
Emacs has builtin package for this, named =speedbar=, but It uses external frame and has so many features that I don't know if I really need.
With this package, and its supplement packages I can have a consistent filetree inside my Emacs frame.
Which is good.
But there's more: DOOM Themes support this package as well, which means that Treemacs will look just as great as DOOM themed Emacs!

#+begin_src emacs-lisp
  (use-package treemacs
    :commands (treemacs-follow-mode
               treemacs-filewatch-mode
               treemacs-fringe-indicator-mode
               treemacs-load-theme)
    :bind (("<f7>" . treemacs)
           ("<f8>" . treemacs-select-window)
           :map treemacs-mode-map
           ([C-tab] . aorst/treemacs-expand-all-projects))
    :hook ((after-init . aorst/treemacs-after-init-setup)
           (treemacs-mode . aorst/after-treemacs-setup)
           (treemacs-switch-workspace . aorst/treemacs-expand-all-projects)
           (treemacs-switch-workspace . treemacs-set-fallback-workspace)
           (treemacs-mode . aorst/treemacs-setup-title))
    :custom-face
    (treemacs-fringe-indicator-face ((t (:inherit font-lock-doc-face))))
    :custom
    (treemacs-width 32)
    (treemacs-is-never-other-window t)
    (treemacs-space-between-root-nodes nil)
    (treemacs-indentation 2)
    :config
    (use-package treemacs-magit)
    (treemacs-follow-mode t)
    (treemacs-filewatch-mode t)
    (treemacs-fringe-indicator-mode t)
    (set-face-attribute 'treemacs-root-face nil
                        :foreground (face-attribute 'default :foreground)
                        :height 1.0
                        :weight 'normal)
    (treemacs-create-theme "Atom"
      :config
      (progn
        (treemacs-create-icon
         :icon (format " %s\t"
                       (all-the-icons-octicon
                        "repo"
                        :v-adjust -0.1
                        :face '(:inherit font-lock-doc-face :slant normal)))
         :extensions (root))
        (treemacs-create-icon
         :icon (format "%s\t%s\t"
                       (all-the-icons-octicon
                        "chevron-down"
                        :height 0.75
                        :v-adjust 0.1
                        :face '(:inherit font-lock-doc-face :slant normal))
                       (all-the-icons-octicon
                        "file-directory"
                        :v-adjust 0
                        :face '(:inherit font-lock-doc-face :slant normal)))
         :extensions (dir-open))
        (treemacs-create-icon
         :icon (format "%s\t%s\t"
                       (all-the-icons-octicon
                        "chevron-right"
                        :height 0.75
                        :v-adjust 0.1
                        :face '(:inherit font-lock-doc-face :slant normal))
                       (all-the-icons-octicon
                        "file-directory"
                        :v-adjust 0
                        :face '(:inherit font-lock-doc-face :slant normal)))
         :extensions (dir-closed))
        (treemacs-create-icon
         :icon (format "%s\t%s\t"
                       (all-the-icons-octicon
                        "chevron-down"
                        :height 0.75
                        :v-adjust 0.1
                        :face '(:inherit font-lock-doc-face :slant normal))
                       (all-the-icons-octicon
                        "package"
                        :v-adjust 0
                        :face '(:inherit font-lock-doc-face :slant normal)))
         :extensions (tag-open))
        (treemacs-create-icon
         :icon (format "%s\t%s\t"
                       (all-the-icons-octicon
                        "chevron-right"
                        :height 0.75
                        :v-adjust 0.1
                        :face '(:inherit font-lock-doc-face :slant normal))
                       (all-the-icons-octicon
                        "package"
                        :v-adjust 0
                        :face '(:inherit font-lock-doc-face :slant normal)))
         :extensions (tag-closed))
        (treemacs-create-icon
         :icon (format "%s\t"
                       (all-the-icons-octicon
                        "tag"
                        :height 0.9
                        :v-adjust 0
                        :face '(:inherit font-lock-doc-face :slant normal)))
         :extensions (tag-leaf))
        (treemacs-create-icon
         :icon (format "%s\t"
                       (all-the-icons-octicon
                        "flame"
                        :v-adjust 0
                        :face '(:inherit font-lock-doc-face :slant normal)))
         :extensions (error))
        (treemacs-create-icon
         :icon (format "%s\t"
                       (all-the-icons-octicon
                        "stop"
                        :v-adjust 0
                        :face '(:inherit font-lock-doc-face :slant normal)))
         :extensions (warning))
        (treemacs-create-icon
         :icon (format "%s\t"
                       (all-the-icons-octicon
                        "info"
                        :height 0.75
                        :v-adjust 0.1
                        :face '(:inherit font-lock-doc-face :slant normal)))
         :extensions (info))
        (treemacs-create-icon
         :icon (format "  %s\t"
                       (all-the-icons-octicon
                        "file-media"
                        :v-adjust 0
                        :face '(:inherit font-lock-doc-face :slant normal)))
         :extensions ("png" "jpg" "jpeg" "gif" "ico" "tif" "tiff" "svg" "bmp"
                      "psd" "ai" "eps" "indd" "mov" "avi" "mp4" "webm" "mkv"
                      "wav" "mp3" "ogg" "midi"))
        (treemacs-create-icon
         :icon (format "  %s\t"
                       (all-the-icons-octicon
                        "file-code"
                        :v-adjust 0
                        :face '(:inherit font-lock-doc-face :slant normal)))
         :extensions ("yml" "yaml" "sh" "zsh" "fish" "c" "h" "cpp" "cxx" "hpp"
                      "tpp" "cc" "hh" "hs" "lhs" "cabal" "py" "pyc" "rs" "el"
                      "elc" "clj" "cljs" "cljc" "ts" "tsx" "vue" "css" "html"
                      "htm" "dart" "java" "kt" "scala" "sbt" "go" "js" "jsx"
                      "hy" "json" "jl" "ex" "exs" "eex" "ml" "mli" "pp" "dockerfile"
                      "vagrantfile" "j2" "jinja2" "tex" "racket" "rkt" "rktl" "rktd"
                      "scrbl" "scribble" "plt" "makefile" "elm" "xml" "xsl" "rb"
                      "scss" "lua" "lisp" "scm" "sql" "toml" "nim" "pl" "pm" "perl"
                      "vimrc" "tridactylrc" "vimperatorrc" "ideavimrc" "vrapperrc"
                      "cask" "r" "re" "rei" "bashrc" "zshrc" "inputrc" "editorconfig"
                      "gitconfig"))
        (treemacs-create-icon
         :icon (format "  %s\t"
                       (all-the-icons-octicon
                        "book"
                        :v-adjust 0
                        :face '(:inherit font-lock-doc-face :slant normal)))
         :extensions ("lrf" "lrx" "cbr" "cbz" "cb7" "cbt" "cba" "chm" "djvu"
                      "doc" "docx" "pdb" "pdb" "fb2" "xeb" "ceb" "inf" "azw"
                      "azw3" "kf8" "kfx" "lit" "prc" "mobi" "pkg" "opf" "txt"
                      "pdb" "ps" "rtf" "pdg" "xml" "tr2" "tr3" "oxps" "xps"))
        (treemacs-create-icon
         :icon (format "  %s\t" (all-the-icons-octicon
                                 "file-text"
                                 :v-adjust 0
                                 :face '(:inherit font-lock-doc-face :slant normal)))
         :extensions ("md" "markdown" "rst" "log" "org" "txt"
                      "CONTRIBUTE" "LICENSE" "README" "CHANGELOG"))
        (treemacs-create-icon
         :icon (format "  %s\t" (all-the-icons-octicon
                                 "file-binary"
                                 :v-adjust 0
                                 :face '(:inherit font-lock-doc-face :slant normal)))
         :extensions ("exe" "dll" "obj" "so" "o" "out"))
        (treemacs-create-icon
         :icon (format "  %s\t" (all-the-icons-octicon
                                 "file-pdf"
                                 :v-adjust 0
                                 :face '(:inherit font-lock-doc-face :slant normal)))
         :extensions ("pdf"))
        (treemacs-create-icon
         :icon (format "  %s\t" (all-the-icons-octicon
                                 "file-zip"
                                 :v-adjust 0
                                 :face '(:inherit font-lock-doc-face :slant normal)))
         :extensions ("zip" "7z" "tar" "gz" "rar" "tgz"))
        (treemacs-create-icon
         :icon (format "  %s\t" (all-the-icons-octicon
                                 "file-text"
                                 :v-adjust 0
                                 :face '(:inherit font-lock-doc-face :slant normal)))
         :extensions (fallback))))
    :init
    (defun aorst/treemacs-expand-all-projects (&optional _)
      "Expand all projects."
      (interactive)
      (save-excursion
        (treemacs--forget-last-highlight)
        (dolist (project (treemacs-workspace->projects (treemacs-current-workspace)))
          (-when-let (pos (treemacs-project->position project))
            (when (eq 'root-node-closed (treemacs-button-get pos :state))
              (goto-char pos)
              (treemacs--expand-root-node pos)))))
      (treemacs--maybe-recenter 'on-distance))
    (defun aorst/treemacs-variable-pitch-labels (&rest _)
      (dolist (face '(treemacs-file-face
                      treemacs-root-face
                      treemacs-tags-face
                      treemacs-directory-face
                      treemacs-directory-collapsed-face
                      treemacs-term-node-face
                      treemacs-help-title-face
                      treemacs-help-column-face
                      treemacs-git-added-face
                      treemacs-git-ignored-face
                      treemacs-git-renamed-face
                      treemacs-git-conflict-face
                      treemacs-git-modified-face
                      treemacs-git-unmodified-face
                      treemacs-git-untracked-face
                      treemacs-root-unreadable-face
                      treemacs-root-remote-face
                      treemacs-root-remote-unreadable-face
                      treemacs-root-remote-disconnected-face
                      treemacs-fringe-indicator-face
                      treemacs-on-failure-pulse-face
                      treemacs-on-success-pulse-face))
        (let ((faces (face-attribute face :inherit nil)))
          (set-face-attribute
           face nil :inherit
           `(variable-pitch ,@(delq 'unspecified (if (listp faces) faces (list faces))))))))
    (defun aorst/treemacs-after-init-setup ()
      "Set treemacs theme, open treemacs, and expand all projects."
      (when (display-graphic-p)
        (treemacs-load-theme "Atom"))
      (setq treemacs-collapse-dirs 0)
      (treemacs)
      (aorst/treemacs-expand-all-projects)
      (windmove-right))
    (defun aorst/after-treemacs-setup ()
      "Set treemacs buffer common settings."
      (setq tab-width 1
            mode-line-format nil
            line-spacing 5)
      (setq-local scroll-step 1)
      (setq-local scroll-conservatively 10000)
      (aorst/treemacs-variable-pitch-labels))
    (defun aorst/treemacs-setup-title ()
      (let ((bg (face-attribute 'default :background))
            (fg (face-attribute 'default :foreground)))
        (face-remap-add-relative 'header-line
                                 :background bg :foreground fg
                                 :box `(:line-width ,(/ (line-pixel-height) 2) :color ,bg)))
      (setq header-line-format
            '((:eval
               (let* ((text (treemacs-workspace->name (treemacs-current-workspace)))
                      (extra-align (+ (/ (length text) 2) 1))
                      (width (- (/ (window-width) 2) extra-align)))
                 (concat (make-string width ?\s) text)))))))
#+end_src

** Uniquify
This package makes files with identical names more distinguishable by adding directory name in the buffer name.

#+begin_src emacs-lisp
  (use-package uniquify
    :straight nil
    :custom (uniquify-buffer-name-style 'forward))
#+end_src

** Tabline
Starting with Emacs 27 native tab support is present.
I want to customize tab appearance to match my theme.

#+begin_src emacs-lisp
  (use-package tab-line
    :straight nil
    :unless (version< emacs-version "27")
    :hook (after-init . global-tab-line-mode)
    :config
    (defun tab-line-close-tab (&optional e)
      "Close the selected tab.

  If tab is presented in another window, close the tab by using
  `bury-buffer` function.  If tab is unique to all existing
  windows, kill the buffer with `kill-buffer` function.  Lastly, if
  no tabs left in the window, it is deleted with `delete-window`
  function."
      (interactive "e")
      (let* ((posnp (event-start e))
             (window (posn-window posnp))
             (buffer (get-pos-property 1 'tab (car (posn-string posnp)))))
        (with-selected-window window
          (let ((tab-list (tab-line-tabs-window-buffers))
                (buffer-list (flatten-list
                              (seq-reduce (lambda (list window)
                                            (select-window window t)
                                            (cons (tab-line-tabs-window-buffers) list))
                                          (window-list) nil))))
            (select-window window)
            (if (> (seq-count (lambda (b) (eq b buffer)) buffer-list) 1)
                (progn
                  (if (eq buffer (current-buffer))
                      (bury-buffer)
                    (set-window-prev-buffers window (assq-delete-all buffer (window-prev-buffers)))
                    (set-window-next-buffers window (delq buffer (window-next-buffers))))
                  (unless (cdr tab-list)
                    (ignore-errors (delete-window window))))
              (and (kill-buffer buffer)
                   (unless (cdr tab-list)
                     (ignore-errors (delete-window window)))))))))


    (defcustom tab-line-tab-min-width 10
      "Minimum width of a tab in characters."
      :type 'integer
      :group 'tab-line)


    (defcustom tab-line-tab-max-width 30
      "Maximum width of a tab in characters."
      :type 'integer
      :group 'tab-line)

    (defcustom tab-line-ellipsis-string "â€¦"
      "String for indicating truncated names"
      :type 'string
      :group 'tab-line)

    (defun aorst/tab-line--tab-width (window-width tab-amount)
      "Calculate width of single tab dividing WINDOW-WIDTH by TAB-AMOUNT."
      (let* ((close-button-size
              (if tab-line-close-button-show
                  (length (substring-no-properties tab-line-close-button)) 0))
             (tab-width (/ window-width tab-amount)))
        (- (cond ((< window-width 0)
                  tab-line-tab-min-width)
                 ((>= tab-width tab-line-tab-max-width)
                  tab-line-tab-max-width)
                 ((< tab-width tab-line-tab-min-width)
                  tab-line-tab-min-width)
                 (t tab-width))
           close-button-size)))

    (defun aorst/tab-line--max-width (window)
      "Calculate free width of the WINDOW.

  Free width means amount of space we can use to display tabs
  without truncation."
      (- (window-width window)
         (length (substring-no-properties tab-line-left-button))
         (length (substring-no-properties tab-line-right-button))
         (if tab-line-new-button-show
             (length (substring-no-properties tab-line-new-button))
           0)))


    (defun aorst/tab-line--make-pad (tab-width name-width)
      "Generate padding string based on TAB-WIDTH and NAME-WIDTH."
      (let* ((width (- tab-width name-width))
             (padding (/ (if (oddp width) (+ width 1) width) 2)))
        (make-string padding ?\s)))


    (defun aorst/tab-line-name-buffer (buffer &rest _buffers)
      "Create name for tab with padding and truncation.

  If buffer name is shorter than `tab-line-tab-max-width' it gets
  centered with spaces, otherwise it is truncated, to preserve
  equal width for all tabs.  This function also tries to fit as
  many tabs in window as possible, so if there are no room for tabs
  with maximum width, it calculates new width for each tab and
  truncates text if needed.  Minimal width can be set with
  `tab-line-tab-min-width' variable."
      (with-current-buffer buffer
        (let* ((amount (length (tab-line-tabs-window-buffers)))
               (width (aorst/tab-line--tab-width
                       (aorst/tab-line--max-width (get-buffer-window buffer))
                       amount))
               (buffer (string-trim (buffer-name)))
               (name-width (length buffer))
               (right-pad (if tab-line-close-button-show "" " "))
               (truncate-width (- width
                                  (length tab-line-ellipsis-string)
                                  (length right-pad))))
          (if (>= name-width truncate-width)
              (concat  " " (truncate-string-to-width buffer truncate-width) tab-line-ellipsis-string right-pad)
            (let* ((padding (aorst/tab-line--make-pad width name-width))
                   (tab-text (concat padding buffer))
                   (text-width (length tab-text)))
              (concat tab-text (make-string (- width text-width) ?\s)))))))


    (setq tab-line-close-button-show t
          tab-line-new-button-show nil
          tab-line-separator ""
          tab-line-tab-name-function #'aorst/tab-line-name-buffer
          tab-line-right-button (propertize (if (char-displayable-p ?â–¶) " â–¶ " " > ")
                                            'keymap tab-line-right-map
                                            'mouse-face 'tab-line-highlight
                                            'help-echo "Click to scroll right")
          tab-line-left-button (propertize (if (char-displayable-p ?â—€) " â—€ " " < ")
                                           'keymap tab-line-left-map
                                           'mouse-face 'tab-line-highlight
                                           'help-echo "Click to scroll left")
          tab-line-close-button (propertize (if (char-displayable-p ?Ã—) " Ã— " " x ")
                                            'keymap tab-line-tab-close-map
                                            'mouse-face 'tab-line-close-highlight
                                            'help-echo "Click to close tab")
          tab-line-exclude-modes '(ediff-mode
                                   process-menu-mode
                                   term-mode
                                   vterm-mode))


    (let ((bg (if (facep 'solaire-default-face)
                  (face-attribute 'solaire-default-face :background)
                (face-attribute 'default :background)))
          (fg (face-attribute 'default :foreground))
          (dark-fg (face-attribute 'shadow :foreground))
          (base (if (facep 'solaire-default-face)
                    (face-attribute 'default :background)
                  (face-attribute 'mode-line :background)))
          (box-width (/ (line-pixel-height) 2)))
      (set-face-attribute 'tab-line nil
                          :background base
                          :foreground dark-fg
                          :height 1.0
                          :inherit nil
                          :box (when (> box-width 0) (list :line-width -1 :color base)))
      (set-face-attribute 'tab-line-tab nil
                          :foreground dark-fg
                          :background bg
                          :weight 'normal
                          :inherit nil
                          :box (when (> box-width 0) (list :line-width box-width :color bg)))
      (set-face-attribute 'tab-line-tab-inactive nil
                          :foreground dark-fg
                          :background base
                          :weight 'normal
                          :inherit nil
                          :box (when (> box-width 0) (list :line-width box-width :color base)))
      (set-face-attribute 'tab-line-tab-current nil
                          :foreground fg
                          :background bg
                          :weight 'normal
                          :inherit nil
                          :box (when (> box-width 0) (list :line-width box-width :color bg))))

    (defun aorst/tab-line-drop-caches ()
      "Drops `tab-line' cache in every window."
      (dolist (window (window-list))
        (set-window-parameter window 'tab-line-cache nil)))

    (add-hook 'window-configuration-change-hook #'aorst/tab-line-drop-caches)

    (define-advice tab-line-select-tab (:after (&optional e))
      (select-window (posn-window (event-start e)))))
#+end_src

** Line Numbers
=display-line-numbers= provides line numbers on the left side of the window, which doesn't lag.
I don't like that it changes width, so let's make it grow only, and calculate maximum width on file open:

#+begin_src emacs-lisp
  (use-package display-line-numbers
    :straight nil
    :custom
    (display-line-numbers-grow-only t)
    (display-line-numbers-width-start t))
#+end_src

* Languages
This section contains various language specific settings and external packages that provide language support.

** Org
Org Mode is a great mode for taking notes, managing to-do lists, writing books, literate programming, and many other things.
I primary use it for taking notes on different programming languages, and manage my Emacs configuration with it.

#+begin_src emacs-lisp
  (use-package org
    :straight (:type built-in)
    :hook ((after-save . aorst/org-tangle-on-config-save)
           (org-babel-after-execute . aorst/org-update-inline-images)
           (ediff-prepare-buffer . outline-show-all)
           ((org-capture-mode org-src-mode) . aorst/discard-history))
    :bind (("C-c a" . org-agenda)
           :map org-mode-map
           ("M-Q" . aorst/split-pararagraph-into-lines)
           ("C-c l" . org-store-link))
    :custom
    (org-startup-with-inline-images nil)
    (org-tags-column -100)
    (org-startup-folded 'content)
    (org-hide-emphasis-markers t)
    (org-adapt-indentation nil)
    (org-hide-leading-stars t)
    (org-highlight-latex-and-related '(latex))
    (revert-without-query '(".*\.pdf"))
    (org-preview-latex-default-process 'dvisvgm)
    (org-src-fontify-natively t)
    (org-preview-latex-image-directory ".ltximg/")
    (org-latex-listings 'minted)
    (org-latex-pdf-process '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")
                            ("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")
                            ("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
    (org-confirm-babel-evaluate nil)
    (org-imenu-depth 8)
    (org-log-done t)
    (org-agenda-files '("~/Tasks"))
    :config
    (when (executable-find "gsettings")
      (let ((font-scaling (string-to-number
                           (shell-command-to-string "gsettings get org.gnome.desktop.interface text-scaling-factor"))))
        (setq org-format-latex-options
              (plist-put org-format-latex-options :scale font-scaling))))
    (use-package ox-latex
      :straight nil)
    (use-package ox-hugo
      :after ox)
    (when (not (version<= org-version "9.1.9"))
      (use-package org-tempo
        :straight nil))
    (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-+]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "â€¢"))))))
    (defun aorst/org-tangle-on-config-save ()
      "Tangle source code blocks when configuration file is saved."
      (when (string= buffer-file-name (file-truename (concat user-emacs-directory "README.org")))
        (org-babel-tangle)))
    (defun aorst/org-update-inline-images ()
      "Update inline images in Org-mode."
      (interactive)
      (when org-inline-image-overlays
        (org-redisplay-inline-images)))
    (defun aorst/discard-history ()
      "Discard undo history of org src and capture blocks."
      (setq buffer-undo-list nil)
      (set-buffer-modified-p nil))
    (defvar minted-cache-dir
      (file-name-as-directory
       (expand-file-name ".minted/\\jobname"
                         temporary-file-directory)))
    (add-to-list 'org-latex-packages-alist
                 `(,(concat "cachedir=" minted-cache-dir)
                   "minted" nil))
    (add-to-list 'org-latex-logfiles-extensions "tex")
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((gnuplot . t)
       (scheme . t)))
    (add-to-list 'org-latex-classes
                 '("article"
                   "\\documentclass{article}"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
    (defun aorst/org-update-latex-preview-background-color (&rest _)
      (setq-default
       org-format-latex-options
       (plist-put org-format-latex-options
                  :background
                  (face-attribute (or (cadr (assq 'default face-remapping-alist))
                                      'default)
                                  :background nil t))))
    (add-hook 'solaire-mode-hook #'aorst/org-update-latex-preview-background-color))
#+end_src

** Prog Mode
This isn't really a configuration of Prog Mode itself, but some hooks that change how programming related modes behave.
One feature that I think is really important, especially when working with lisp code, is ability to see matching bracket when cursor stands near the other bracket.
So I enable it for every programming language.

#+begin_src emacs-lisp
  (use-package prog-mode
    :straight nil
    :hook ((prog-mode . show-paren-mode)
           (prog-mode . display-line-numbers-mode)))
#+end_src

** CC
These settings are for editing C source files.

#+begin_src emacs-lisp
  (use-package cc-mode
    :straight nil
    :config (defun aorst/cc-mode-setup ()
              (c-set-offset 'case-label '+)
              (setq c-basic-offset 4
                    c-default-style "linux"
                    indent-tabs-mode t
                    comment-start "//"
                    comment-end ""
                    tab-width 4))
    :hook ((c-mode-common . aorst/cc-mode-setup)
           (c-mode-common . electric-pair-local-mode)))
#+end_src

** Markdown
Sometimes I need to edit Markdown documents, so this package is handy.
For markdown mode I would like to have automatic spell checking and filling.
Basically the same setup as for Org Mode.
And one of the features of Org mode is ability to edit source code blocks in separate window with appropriate major mode.
This can be achieved with =edit-indirect= package.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :bind (:map markdown-mode-map
           ("M-Q" . aorst/split-pararagraph-into-lines))
    :config
    (defvar markdown-command "multimarkdown")
    (defun aorst/markdown-setup ()
      "Set buffer local variables."
      (setq fill-column 80
            default-justification 'left))
    :hook ((markdown-mode . flyspell-mode)
           (markdown-mode . aorst/markdown-setup)))
#+end_src

** Rust
I'd like to have Rust syntax highlighting and some basic facilities, since I'm planning to write my exercises in org mode.
Since I make notes in Org-mode, and I started to use it for Rust too, I need some settings for Rust mode.

#+begin_src emacs-lisp
  (use-package rust-mode
    :commands (rust-format-buffer)
    :hook (rust-mode . electric-pair-local-mode)
    :bind (:map rust-mode-map
           ("C-c C-M-f" . rust-format-buffer)))
#+end_src

This also means that I could use something to automatically complete Rust language facilities.
Rust ecosystem provides two options for that: [[https://github.com/racer-rust/emacs-racer][Racer]], and [[https://github.com/rust-lang/rls][RLS]].
I'm planning to use Racer when RLS isn't possible to use, like in Org Mode.

#+begin_src emacs-lisp
  (use-package racer
    :if (executable-find "racer")
    :hook (racer-mode . eldoc-mode)
    :init (defun org-babel-edit-prep:rust (&optional _babel-info)
            "Run racer mode for Org Babel."
            (racer-mode 1)))
#+end_src

There's also a package for [[https://github.com/kwrooijen/cargo.el][Cargo]] integration:

#+begin_src emacs-lisp
  (use-package cargo
    :if (executable-find "cargo")
    :hook ((rust-mode toml-mode) . cargo-minor-mode))
#+end_src

** TOML
=toml-mode= helps with highlighting of TOML files, which Rust uses to configure project.

#+begin_src emacs-lisp
  (use-package toml-mode
    :bind (:map toml-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)))
#+end_src

** Geiser
Great REPL support for various Schemes.

#+begin_src emacs-lisp
  (use-package geiser
    :hook (scheme-mode . geiser-mode)
    :custom
    (geiser-active-implementations '(guile))
    (geiser-default-implementation 'guile))
#+end_src

** Racket
Racket is nice LISP/Scheme language that I might to get into.

#+begin_src emacs-lisp
  (use-package racket-mode
    :hook (racket-repl-mode . electric-pair-local-mode)
    :bind (:map racket-mode-map
           ("C-c C-d" . racket-run-with-debugging)
           ("C-c C-M-f" . aorst/indent-buffer)
           (")" . self-insert-command)
           ("]" . self-insert-command)
           ("}" . self-insert-command))
    :config
    (set-face-attribute 'racket-debug-break-face nil :background (face-attribute 'error :foreground) :foreground (face-attribute 'default :background))
    (set-face-attribute 'racket-debug-result-face nil :foreground (face-attribute 'font-lock-comment-face :foreground) :box nil)
    (set-face-attribute 'racket-debug-locals-face nil :foreground (face-attribute 'font-lock-comment-face :foreground) :box nil)
    (set-face-attribute 'racket-selfeval-face nil :foreground (face-attribute 'default :foreground)))
#+end_src

** Cmake
A mode for editing cmake files.

#+begin_src emacs-lisp
  (use-package cmake-mode
    :bind (:map cmake-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)))
#+end_src

** Emacs Lisp
I write some Emacs Lisp and experience is already quite good, I just want to enable some helper modes here.

#+begin_src emacs-lisp
  (use-package elisp-mode
    :straight nil
    :commands (aorst/emacs-lisp-indent-function)
    :hook ((emacs-lisp-mode . eldoc-mode)
           (emacs-lisp-mode . (lambda ()
                                (setq-local lisp-indent-function
                                            #'aorst/emacs-lisp-indent-function))))
    :bind (:map emacs-lisp-mode-map
           ("C-c C-M-f" . aorst/indent-buffer))
    :config
    (defun aorst/emacs-lisp-indent-function (indent-point state)
      "A replacement for `lisp-indent-function'.
  Indents plists more sensibly. Adapted from DOOM Emacs:
  https://github.com/hlissner/doom-emacs/commit/a634e2c8125ed692bb76b2105625fe902b637998"
      (let ((normal-indent (current-column))
            (orig-point (point)))
        (goto-char (1+ (elt state 1)))
        (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
        (cond ((and (elt state 2)
                    (or (not (looking-at-p "\\sw\\|\\s_"))
                        (eq (char-after) ?:)))
               (unless (> (save-excursion (forward-line 1) (point))
                          calculate-lisp-indent-last-sexp)
                 (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t))
               (backward-prefix-chars)
               (current-column))
              ((and (save-excursion
                      (goto-char indent-point)
                      (skip-syntax-forward " ")
                      (not (eq (char-after) ?:)))
                    (save-excursion
                      (goto-char orig-point)
                      (eq (char-after) ?:)))
               (save-excursion
                 (goto-char (+ 2 (elt state 1)))
                 (current-column)))
              ((let* ((function (buffer-substring (point) (progn (forward-sexp 1) (point))))
                      (method (or (function-get (intern-soft function) 'lisp-indent-function)
                                  (get (intern-soft function) 'lisp-indent-hook))))
                 (cond ((or (eq method 'defun)
                            (and (null method)
                                 (> (length function) 3)
                                 (string-match-p "\\`def" function)))
                        (lisp-indent-defform state indent-point))
                       ((integerp method)
                        (lisp-indent-specform method state
                                              indent-point normal-indent))
                       (method
                        (funcall method indent-point state)))))))))
#+end_src

** Yaml
Support for =.yaml= files.

#+begin_src emacs-lisp
  (use-package yaml-mode)
#+end_src

** Shell Script
Some configurations for shell script modes.

#+begin_src emacs-lisp
  (use-package sh-script
    :straight nil
    :bind (:map sh-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)))
#+end_src

** Perl
Perl related configurations.

#+begin_src emacs-lisp
  (use-package perl-mode
    :straight nil
    :hook ((perl-mode . electric-pair-local-mode)
           (perl-mode . flycheck-mode))
    :bind (:map perl-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)))
#+end_src

** Clojure
Clojure is a Lisp dialect for Java Virtual Machine.
It is one of the few modern and refreshing languages, that bring both innovation and reliability.

#+begin_src emacs-lisp
  (use-package clojure-mode
    :hook (((clojure-mode clojurescript-mode) . flycheck-mode))
    :bind (:map clojure-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)
           ("C-x C-M-;" . aorst/clojure-toggle-ignore-form))
    :config
    (defun aorst/clojure-toggle-ignore-form ()
      "Add or remove #_ literal before the current form."
      (interactive)
      (save-excursion
        (condition-case nil
            (progn
              (backward-up-list)
              (if (looking-back "#_")
                  (delete-char -2)
                (insert "#_")))
          (scan-error
           (progn
             (forward-sexp)
             (if (looking-back "#_")
                 (delete-char -2)
               (backward-sexp)
               (insert "#_"))))))))
#+end_src

*** CIDER
Emacs also has a great package called Cider, which is an IDE for Clojure and ClojureScript.

#+begin_src emacs-lisp
  (use-package cider
    :hook (((cider-repl-mode cider-mode) . cider-company-enable-fuzzy-completion)
           ((cider-repl-mode cider-mode) . eldoc-mode))
    :custom
    (nrepl-log-messages nil)
    (cider-repl-display-help-banner nil)
    (cider-repl-tab-command #'company-complete-common-or-cycle)
    (nrepl-hide-special-buffers t)
    :config
    (setq cider-jdk-src-paths nil)
    (when (file-exists-p "/usr/lib/jvm/java-1.8.0-openjdk/src.zip")
      (add-to-list 'cider-jdk-src-paths "/usr/lib/jvm/java-1.8.0-openjdk/src.zip"))
    (when (file-exists-p "/usr/lib/jvm/java-11-openjdk/lib/src.zip")
      (add-to-list 'cider-jdk-src-paths "/usr/lib/jvm/java-11-openjdk/lib/src.zip"))
    (when (file-exists-p "~/.clojure-src/")
      (setq cider-jdk-src-paths
            (append cider-jdk-src-paths
                    (file-expand-wildcards "~/.clojure-src/clojure-*.*.*-sources.jar")))))
#+end_src

*** flycheck-clj-kondo
[[https://github.com/borkdude/clj-kondo][clj-kondo]] is a static analyzer for Clojure(Script), and =flycheck-clj-kondo= is a backend for =flycheck=, that makes these two things understand each other.

#+begin_src emacs-lisp
  (use-package flycheck-clj-kondo
    :if (executable-find "clj-kondo")
    :straight (:host github
               :repo "borkdude/flycheck-clj-kondo"))
#+end_src

*** clj-refactor
=clj-refactor= provides refactoring support for Clojure projects.
It complements the refactoring functionality from =clojure-mode= and CIDER.

#+begin_src emacs-lisp
  (use-package clj-refactor
    :hook ((cider-mode . clj-refactor-mode)
           (cider-mode . yas-minor-mode)))
#+end_src

** Fennel
Fennel is a programming language a lisp dialect, that is being compiled to Lua, which means that it can run anywhere, where Lua can.
It supports compile-time macro system, and full Lua compatibility.

#+begin_src emacs-lisp
  (use-package fennel-mode
    :bind (:map fennel-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)))
#+end_src

** Lua
I'm not into Lua language myself, but in order to view what [[*Fennel][Fennel]] produces I need support for Lua.

#+begin_src emacs-lisp
  (use-package lua-mode
    :bind (:map lua-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)))
#+end_src

** CSS
CSS indentation tweaks.

#+begin_src emacs-lisp
  (use-package css-mode
    :straight nil
    :custom
    (css-indent-offset 2))
#+end_src

** Java
Support for Java is inbuilt, but to use Java Language Server we need this package:

#+begin_src emacs-lisp
  (use-package lsp-java)
#+end_src

** SQL
Syntax based indentation for SQL:

#+begin_src emacs-lisp
  (use-package sql-indent
    :hook (sql-mode . sqlind-minor-mode))
#+end_src

** Elixir
Elixir is a dynamic, functional language designed for building scalable and maintainable applications.
It runs on Erlang VM (BEAM), and has nice macro system, making language core small, yet still very extensible.
And it also has good interop with Erlang itself.

#+begin_src emacs-lisp
  (use-package elixir-mode)
#+end_src

* Tools
Additional packages that change how Emacs works, providing more comfortable user experience.

** Help
I want help window to be selected automatically, so I could close it with =q= after I've finished reading.

#+begin_src emacs-lisp
  (use-package help
    :straight nil
    :custom (help-window-select t))
#+end_src

** Doc View
Default resolution is too low:

#+begin_src emacs-lisp
  (use-package doc-view
    :straight nil
    :custom (doc-view-resolution 192))
#+end_src

** vterm
This package provides a bridge to =libvterm= to display terminal as Emacs buffer.
It works much better than =ansi-term=, though may be buggy and requires compilation.

#+begin_src emacs-lisp
  (setq use-package-hook-name-suffix "-functions")
  (use-package vterm
    :if (bound-and-true-p module-file-suffix)
    :bind (("C-`" . aorst/vterm-toggle)
           ("C-t" . aorst/vterm-focus))
    :hook (vterm-exit . aorst/kill-vterm)
    :config
    (defun aorst/vterm-toggle (&optional arg)
      "Toggle `vterm' window on and off with the same command."
      (interactive "P")
      (let* ((directory (if default-directory
                            default-directory
                          (expand-file-name "~/")))
             (bufname "*vterm*")
             (window (get-buffer-window bufname)))
        (if window
            (ignore-errors (delete-window window))
          (if (window-dedicated-p)
              (let ((windows (seq-drop-while #'window-dedicated-p (window-list))))
                (when (not (null windows))
                  (select-window (car windows)))))
          (let* ((win-side (if (symbolp arg)
                               (cons (split-window-below) 'bot)
                             (cons (split-window-right) 'right)))
                 (window (car win-side))
                 (side (cdr win-side)))
            (select-window window)
            (cond ((get-buffer bufname)
                   (switch-to-buffer bufname))
                  (t (let ((default-directory directory))
                       (vterm bufname))))
            (when (bound-and-true-p global-tab-line-mode)
              (setq tab-line-format nil))
            (set-window-dedicated-p window t)
            (set-window-parameter window 'no-delete-other-windows t)
            (set-window-parameter window 'window-side side)
            (set-window-parameter window 'no-other-window t)))))
    (defun aorst/vterm-focus (&optional arg)
      "Focus `vterm' or open one if there's none."
      (interactive "P")
      (let ((window (get-buffer-window "*vterm*")))
        (if window
            (select-window window)
          (aorst/vterm-toggle arg))))
    (defun aorst/kill-vterm (buf &optional event)
      "Kill the `*vterm*' buffer after shell exits."
      (when buf (kill-buffer buf))))
  (setq use-package-hook-name-suffix "-hook")
#+end_src

** EditorConfig
=.editorconfig= file provides a nice way to synchronize my editor configurations between projects and different editors.

#+begin_src emacs-lisp
  (use-package editorconfig
    :config (editorconfig-mode 1))
#+end_src

** Flycheck
Some languages have better support with =flycheck=.

#+begin_src emacs-lisp
  (use-package flycheck
    :bind (:map flycheck-mode-map
           ("C-c ! C-h" . hydrant/flycheck/body))
    :custom
    (flycheck-indication-mode 'right-fringe)
    :config
    (when (fboundp #'define-fringe-bitmap)
      (define-fringe-bitmap 'flycheck-double-exclamation-mark
        (vector #b00000000
                #b00000000
                #b00000000
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b00000000
                #b01100110
                #b01100110
                #b00000000
                #b00000000
                #b00000000))
      (define-fringe-bitmap 'flycheck-exclamation-mark
        (vector #b00000000
                #b00000000
                #b00000000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00000000
                #b00011000
                #b00011000
                #b00000000
                #b00000000
                #b00000000))
      (define-fringe-bitmap 'flycheck-question-mark
        (vector #b00000000
                #b00000000
                #b00000000
                #b00111100
                #b01111110
                #b01100110
                #b01100110
                #b00000110
                #b00001100
                #b00011000
                #b00011000
                #b00000000
                #b00011000
                #b00011000
                #b00000000
                #b00000000
                #b00000000))
      (flycheck-define-error-level 'error
        :severity 100
        :compilation-level 2
        :overlay-category 'flycheck-error-overlay
        :fringe-bitmap 'flycheck-double-exclamation-mark
        :fringe-face 'flycheck-fringe-error
        :error-list-face 'flycheck-error-list-error)
      (flycheck-define-error-level 'warning
        :severity 100
        :compilation-level 1
        :overlay-category 'flycheck-warning-overlay
        :fringe-bitmap 'flycheck-exclamation-mark
        :fringe-face 'flycheck-fringe-warning
        :error-list-face 'flycheck-error-list-warning)
      (flycheck-define-error-level 'info
        :severity 100
        :compilation-level 0
        :overlay-category 'flycheck-info-overlay
        :fringe-bitmap 'flycheck-question-mark
        :fringe-face 'flycheck-fringe-info
        :error-list-face 'flycheck-error-list-info))

    (when (executable-find "textlint")
      (flycheck-define-checker textlint
        "A linter for textlint."
        :command ("textlint"
                  "--format" "unix"
                  "--rule" "write-good"
                  "--rule" "no-start-duplicated-conjunction"
                  "--rule" "max-comma"
                  "--rule" "terminology"
                  "--rule" "period-in-list-item"
                  "--rule" "abbr-within-parentheses"
                  "--rule" "alex"
                  "--rule" "common-misspellings"
                  "--rule" "en-max-word-count"
                  "--rule" "diacritics"
                  "--rule" "stop-words"
                  source-inplace)
        :error-patterns
        ((warning line-start (file-name) ":" line ":" column ": "
                  (message (one-or-more not-newline)
                           (zero-or-more "\n" (any " ") (one-or-more not-newline)))
                  line-end))
        :modes (text-mode latex-mode org-mode markdown-mode))
      (add-to-list 'flycheck-checkers 'textlint))

   (when (fboundp #'defhydra)
     (defhydra hydrant/flycheck (:color blue :hint nil)
       "
   ^Flycheck^         ^Errors^       ^Checker^
   _q_: quit          _<_: previous  _?_: describe
   _M_: manual        _>_: next      _d_: disable
   _v_: verify setup  _f_: check     _m_: mode
   ^ ^                _l_: list      _s_: select"
       ("q" ignore :exit t)
       ("M" flycheck-manual)
       ("v" flycheck-verify-setup)
       ("<" flycheck-previous-error :color pink)
       (">" flycheck-next-error :color pink)
       ("f" flycheck-buffer)
       ("l" flycheck-list-errors)
       ("?" flycheck-describe-checker)
       ("d" flycheck-disable-checker)
       ("m" flycheck-mode)
       ("s" flycheck-select-checker))))
#+end_src

=flycheck-cask= is a package for using [[https://github.com/cask/cask][Cask]] files with Flycheck.

#+begin_src emacs-lisp
  (use-package flycheck-cask
    :hook (flycheck-mode . flycheck-cask-setup))
#+end_src

** Hydra
This is something like ability to create mappings that sit in it's own mode, like different user modes in Kakoune.
It allows me to press some shortcut and be locked in a mode-like state where keys that are related to this prefix shortcut are behaving in terms of this shortcut.
This package will be used in many other package configurations to provide sane keybindings.

#+begin_src emacs-lisp
  (use-package hydra)
#+end_src

** Parinfer
Parinfer implementation written in Rust language.
Not as strict as Emacs Lisp implementation, because it does not force any formatting rules, and theoretically should be faster, but in very early stages of development.

#+begin_src emacs-lisp
  (use-package parinfer-rust-mode
    :if (and (bound-and-true-p module-file-suffix)
             (not (string-match-p "aarch" system-configuration)))
    :straight (:host github
               :repo "andreyorst/parinfer-rust-mode")
    :hook ((clojure-mode
            emacs-lisp-mode
            common-lisp-mode
            scheme-mode
            lisp-mode
            racket-mode
            fennel-mode) . parinfer-rust-mode)
    :custom (parinfer-rust-check-before-enable 'defer)
    :custom-face (parinfer-rust-dim-parens ((t (:inherit shadow))))
    :config
    (add-to-list 'parinfer-rust-treat-command-as '(aorst/indent-buffer . "indent"))
    :init
    (setq parinfer-rust-auto-download t))
#+end_src

** Flx
Flex matching for Emacs.

#+begin_src emacs-lisp
  (use-package flx)
#+end_src

** Ivy and Counsel
Ivy is a narrowing framework like Helm, but much lighter in my experience.
It integrates with Counsel that handles minibuffer, so let's install it too.

#+begin_src emacs-lisp
  (use-package ivy
    :commands ivy-mode
    :hook ((minibuffer-setup . aorst/minibuffer-defer-garbage-collection)
           (minibuffer-exit . aorst/minibuffer-restore-garbage-collection))
    :bind (("C-x b" . ivy-switch-buffer)
           ("C-x C-b" . ivy-switch-buffer))
    :custom-face
    (ivy-org ((t (:inherit default))))
    :custom
    (ivy-re-builders-alist '((t . ivy--regex-fuzzy)))
    (ivy-count-format "")
    (ivy-ignore-buffers '("\\` " "\\`\\*"))
    (ivy-display-style nil)
    (ivy-minibuffer-faces nil)
    (ivy-minibuffer-faces '(default default default default))
    (ivy-use-virtual-buffers t)
    (enable-recursive-minibuffers t)
    :init
    (defun aorst/minibuffer-defer-garbage-collection ()
      "Defer garbage collection for minibuffer"
      (setq gc-cons-threshold most-positive-fixnum))
    (defun aorst/minibuffer-restore-garbage-collection ()
      "Resotre garbage collection settings."
      (run-at-time
       1 nil (lambda () (setq gc-cons-threshold aorst--gc-cons-threshold))))
    (ivy-mode 1))
#+end_src

I'm using [[https://github.com/sharkdp/fd][fd]] as a great replacement for GNU Find.
It's fast and it takes =.gitignore= into account.
Counsel has nice =counsel-file-fump= command that uses =find-program= variable, so we can advice it in order for it to use =fd=.
The same thing is for =rg=, but counsel actually has it's own variable for it, so we do no need to runtime-patch it.

#+begin_src emacs-lisp
  (use-package counsel
    :commands (counsel-M-x
               counsel-find-file
               counsel-file-jump
               counsel-recentf
               counsel-rg
               counsel-describe-function
               counsel-describe-variable
               counsel-find-library)
    :bind (("M-x" . counsel-M-x)
           ("C-x C-f" . counsel-find-file)
           ("C-x f" . counsel-file-jump)
           ("C-x C-r" . counsel-recentf)
           ("C-x d" . counsel-dired)
           ("C-h f" . counsel-describe-function)
           ("C-h C-f" . counsel-describe-face)
           ("C-h v" . counsel-describe-variable)
           ("C-h l" . counsel-find-library))
    :config
    (when (executable-find "fd")
      (define-advice counsel-file-jump (:around (foo &optional initial-input initial-directory))
        (let ((find-program "fd")
              (counsel-file-jump-args (split-string "-L --type f --hidden")))
          (funcall foo))))
    (when (executable-find "rg")
      (setq counsel-rg-base-command
            "rg -S --no-heading --hidden --line-number --color never %s .")))
#+end_src

** Company
Complete anything framework. Nothing much to say. Does it's job.

#+begin_src emacs-lisp
  (use-package company
    :bind (:map company-active-map
           ("TAB" . company-complete-common-or-cycle)
           ("<tab>" . company-complete-common-or-cycle)
           ("<S-Tab>" . company-select-previous)
           ("<backtab>" . company-select-previous)
           ("C-n" . company-select-next)
           ("C-p" . company-select-previous))
    :hook (after-init . global-company-mode)
    :custom
    (company-require-match 'never)
    (company-minimum-prefix-length 2)
    (company-tooltip-align-annotations t)
    (company-frontends '(company-pseudo-tooltip-unless-just-one-frontend
                         company-preview-frontend
                         company-echo-metadata-frontend))
    (company-backends '(company-capf company-files))
    (company-tooltip-minimum-width 30)
    (company-tooltip-maximum-width 60))
#+end_src

This package also optionally requires these extra dependencies:

- =company-posframe= - provides posframe frontend for company.

#+begin_src emacs-lisp
  (use-package company-posframe
    :after company
    :custom
    (company-posframe-quickhelp-show-header nil)
    (company-posframe-show-indicator nil)
    (company-posframe-show-metadata nil)
    (company-posframe-quickhelp-show-params
     (list :poshandler #'company-posframe-quickhelp-right-poshandler
           :internal-border-width 1
           :timeout 60
           :internal-border-color (face-attribute 'mode-line-inactive :background)
           :no-properties nil
           :poshandler nil))
    :config
    (company-posframe-mode))
#+end_src

** Undo Tree
This is more familiar undo mode.
It adds =C-/= mapping to undo and =C-?= mapping to redo.
I also map convenient =C-z= and =C-S-z= maps, because sometimes when someone else sits at my PC (for pair programming for example), and forgets that this is Emacs, and hits =C-z= thus minimizing the frame, and being frustrated.

#+begin_src emacs-lisp
  (use-package undo-tree
    :commands global-undo-tree-mode
    :bind (("C-z" . undo-tree-undo)
           ("C-S-z" . undo-tree-redo))
    :init (global-undo-tree-mode 1))
#+end_src

** Yasnippet
Another very handy package, that helps insert templates of code.
Now I really need to write some snippets to use.
Also has nice collection as a separate package

#+begin_src emacs-lisp
  (use-package yasnippet
    :config
    (add-to-list 'yas-key-syntaxes 'yas-shortest-key-until-whitespace))
#+end_src

** Magit
Emacs interface to Git.
I've heard that it has many nice features, so I want to try it out.

#+begin_src emacs-lisp
  (use-package magit
    :hook ((git-commit-mode . flyspell-mode))
    :bind (("<f12>" . magit-status))
    :custom
    (magit-ediff-dwim-show-on-hunks t)
    :config
    (advice-add 'magit-set-header-line-format :override #'ignore))
#+end_src

*** Magit TODOs
Display TODO items in Magit buffers.

#+begin_src emacs-lisp
  (use-package magit-todos
    :hook (magit-mode . magit-todos-mode))
#+end_src

** Ediff
This is a built in mode for diffing files in Emacs.
Previously I was using [[https://github.com/justbur/emacs-vdiff][Vdiff]] but I have to say that I've used it so rarely, so I decided to avoid extra dependency and configure Ediff.

#+begin_src emacs-lisp
  (use-package ediff
    :straight nil
    :hook ((ediff-before-setup . aorst/store-pre-ediff-winconfig)
           (ediff-quit . aorst/restore-pre-ediff-winconfig)
           (ediff-keymap-setup . aorst/ediff-setup-keys))
    :config
    (advice-add 'ediff-window-display-p :override #'ignore)
    :custom
    (ediff-split-window-function 'split-window-horizontally)
    :init
    (defvar aorst--ediff-last-windows nil
      "Stores window configuration before `ediff' was invoked.")
    (defun aorst/store-pre-ediff-winconfig ()
      (setq aorst--ediff-last-windows (current-window-configuration)))
    (defun aorst/restore-pre-ediff-winconfig ()
      (set-window-configuration aorst--ediff-last-windows))
    (defun aorst/ediff-copy-both-to-C ()
      (interactive)
      (ediff-copy-diff ediff-current-difference nil 'C nil
                       (concat
                        (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
                        (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))
    (defun aorst/ediff-setup-keys ()
      (define-key ediff-mode-map "d" #'aorst/ediff-copy-both-to-C)))
#+end_src

** Multiple Cursors
This package provides multiple cursors functionality to Emacs.
It isn't much like Kakoune's multiple selections, but anything will do.
I guess I'll figure out best mappings over time.

#+begin_src emacs-lisp
  (use-package phi-search)
  (use-package mc-extras)
  (use-package multiple-cursors
    :commands (mc/cycle-backward
               mc/cycle-forward)
    :bind (("S-<mouse-1>" . mc/add-cursor-on-click)
           ("C-c m" . hydrant/mc/body)
           :map mc/keymap
           ("<return>" . nil)
           ("C-s" . phi-search)
           ("C-r" . phi-search-backward))
    :config
    (when (fboundp #'defhydra)
      (defhydra hydrant/mc (:hint nil :color pink)
        "
   ^Select^                 ^Discard^                      ^Edit^               ^Navigate^
   _M-s_: split lines       _M-SPC_:  discard current      _&_: align           _(_: cycle backward
   _s_:   select regexp     _b_:      discard blank lines  _#_: insert numbers  _)_: cycle forward
   _n_:   select next       _d_:      remove duplicated    ^ ^                  ^ ^
   _p_:   select previous   _q_ or _g_: exit hydrant       ^ ^                  ^ ^
   _C_:   select next line  _G_:      exit mc mode"
        ("M-s" mc/edit-ends-of-lines)
        ("s" mc/mark-all-in-region-regexp)
        ("n" mc/mark-next-like-this-word)
        ("p" mc/mark-previous-like-this-word)
        ("&" mc/vertical-align-with-space)
        ("(" mc/cycle-backward)
        (")" mc/cycle-forward)
        ("M-SPC" mc/remove-current-cursor)
        ("b" mc/remove-cursors-on-blank-lines)
        ("d" mc/remove-duplicated-cursors)
        ("C" mc/mark-next-lines)
        ("#" mc/insert-numbers)
        ("q" mc/remove-duplicated-cursors :exit t)
        ("g" mc/remove-duplicated-cursors :exit t)
        ("G" mc/keyboard-quit :exit t))))
#+end_src

** Expand Region
Expand or reduce region selection semantically.
Supports most languages that I work with inside Emacs.

#+begin_src emacs-lisp
  (use-package expand-region
    :bind (("C-c e" . hydrant/er/body))
    :config
    (when (fboundp #'defhydra)
      (defhydra hydrant/er (:color pink :hint nil)
        "
   ^Expand/Discard^                ^Mark^
   _e_ or _+_: expand region         _(_:      inside pairs
   _r_ or _-_: reduce region         _)_:      around pairs
   _g_:      exit hydrant          _q_ or _'_: inside quotes
   _G_:      discard region, exit  _Q_ or _\"_: around quotes
   ^ ^    ^ ^                        _p_:      paragraph"
        ("e" er/expand-region)
        ("+" er/expand-region)
        ("r" er/contract-region)
        ("-" er/contract-region)
        ("p" er/mark-paragraph)
        ("(" er/mark-inside-pairs)
        (")" er/mark-outside-pairs)
        ("q" er/mark-inside-quotes)
        ("'" er/mark-inside-quotes)
        ("Q" er/mark-outside-quotes)
        ("\"" er/mark-outside-quotes)
        ("g" ignore :exit t)
        ("G" (lambda () (interactive) (deactivate-mark)) :exit t))))
#+end_src

** Iedit Mode
Another package for multiple editing purposes, that is kinda faster than multiple cursors, but can edit only fixed width regions of text and has less abilities regarding to commands.
Still pretty usable though, as multiple cursor some times looses cursors for some reason.

#+begin_src emacs-lisp
  (use-package iedit
    :bind (("M-n" . aorst/iedit-current-or-expand)
           ("C-c i" . aorst/iedit-hydrant))
    :custom
    (iedit-toggle-key-default nil)
    :init
    (defun aorst/iedit-to-mc-hydrant ()
      "Calls `iedit-to-mc-mode' and opens hydra for multiple cursors."
      (interactive)
      (iedit-switch-to-mc-mode)
      (hydrant/mc/body))
    (defun aorst/iedit-current-or-expand (&optional arg)
      "Select only currnent occurrence with `iedit-mode'.  Expand to
    next occurrence if `iedit-mode' is already active."
      (interactive "P")
      (if (bound-and-true-p iedit-mode)
          (if (symbolp arg)
              (iedit-expand-down-to-occurrence)
            (iedit-expand-up-to-occurrence))
        (iedit-mode 1)))
    (when (fboundp #'defhydra)
      (defhydra hydrant/iedit (:hint nil :color pink)
        "
   ^Select^                  ^Discard^                   ^Edit^               ^Navigate^
   _n_: next occurrence      _M-SPC_:  toggle selection  _u_: uppercase       _(_: previous selection
   _p_: previous occurrence  _q_ or _g_: exit hydrant      _d_: downcase        _)_: next selection
   ^ ^                       _G_:      exit iedit-mode   _#_: insert numbers
   ^ ^                       _m_:      switch to mc"
        ("n" iedit-expand-down-to-occurrence)
        ("m" aorst/iedit-to-mc-hydrant :exit t)
        ("p" iedit-expand-up-to-occurrence)
        ("u" iedit-upcase-occurrences)
        ("d" iedit-downcase-occurrences)
        ("#" iedit-number-occurrences)
        ("(" iedit-prev-occurrence)
        (")" iedit-next-occurrence)
        ("M-SPC" iedit-toggle-selection)
        ("q" ignore :exit t)
        ("g" ignore :exit t)
        ("G" (lambda () (interactive) (iedit-mode -1)) :exit t))
      (defun aorst/iedit-hydrant ()
        "toggle iedit mode for item under point, and open `hydrant/iedit'."
        (interactive)
        (ignore-errors
          (iedit-mode 1)
          (hydrant/iedit/body)))))
#+end_src

** LSP Mode
LSP client for Emacs.

#+begin_src emacs-lisp
  (use-package lsp-mode
    :hook (((rust-mode c-mode c++-mode java-mode) . lsp)
           (lsp-mode . yas-minor-mode))
    :custom-face
    (lsp-modeline-code-actions-face ((t (:inherit mode-line))))
    :custom
    (lsp-enable-links nil)
    (lsp-keymap-prefix "C-c l")
    (lsp-rust-clippy-preference "on")
    (lsp-prefer-capf t)
    (lsp-enable-indentation nil)
    ;; (lsp-enable-symbol-highlighting nil)
    (lsp-rust-server 'rust-analyzer)
    (lsp-session-file (expand-file-name "lsp-session" user-emacs-directory)))
#+end_src

#+begin_src emacs-lisp
  (use-package lsp-ui
    :after lsp-mode
    :commands lsp-ui-mode
    :bind (:map lsp-ui-mode-map
           ("M-." . lsp-ui-peek-find-definitions)
           ("M-/" . lsp-ui-peek-find-references))
    :custom
    (lsp-ui-doc-border (face-attribute 'mode-line-inactive :background))
    (lsp-ui-sideline-enable nil)
    (lsp-ui-imenu-enable nil)
    (lsp-ui-doc-delay 1 "higher than eldoc delay")
    :config
    (when (fboundp #'aorst/escape)
      (define-advice lsp-ui-doc--make-request (:around (foo))
        (unless (eq this-command 'aorst/escape)
          (funcall foo))))
    (lsp-ui-mode))
#+end_src

** DAP Mode
Debug Adapter Protocol support for Emacs.

#+begin_src emacs-lisp
  (use-package dap-mode)
#+end_src

** Project
I do not want to use projectile, since Emacs already features =project.el= and many packages use it.
Although I've needed to create my own function that searches for correct project root.
So first we need a list of project root markers, that will hold file names which we will look up recursively.
We need a function that will test current directory for several conditions, like does it have any of project markers, is it root directory, and if everything fails, it will go up one directory and repeat.

#+begin_src emacs-lisp
  (use-package project
    :straight nil
    :bind (("C-c p f" . project-find-file)
           ("C-c p r" . project-find-regexp))
    :config
    (defvar aorst--project-root-markers '("Cargo.toml" "compile_commands.json" "compile_flags.txt")
      "Files or directories that indicate the root of a project.")
    (defun aorst/project-find-root (path)
      "Recursive search in PATH for root markers."
      (let* ((this-dir (file-name-as-directory (file-truename path)))
             (parent-dir (expand-file-name (concat this-dir "../")))
             (system-root-dir (expand-file-name "/")))
        (cond
         ((aorst/project-root-p this-dir) (cons 'transient this-dir))
         ((equal system-root-dir this-dir) nil)
         (t (aorst/project-find-root parent-dir)))))
    (defun aorst/project-root-p (path)
      "Check if current PATH has any of project root markers."
      (let ((results (mapcar (lambda (marker)
                               (file-exists-p (concat path marker)))
                             aorst--project-root-markers)))
        (eval `(or ,@ results))))
    (add-to-list 'project-find-functions #'aorst/project-find-root))
#+end_src

** Clang Format
A package to format C code with Clang Format.

#+begin_src emacs-lisp
  (use-package clang-format
    :after cc-mode
    :bind (:map c-mode-base-map
           ("C-c C-M-f" . clang-format-buffer)))
#+end_src
p
** Server
I'm using =server-start= command not because I do not want to load my Emacs every time, but because I want to have single instance of Emacs running at a time, so all files that I open from GUI will be opened in existing Emacs.
If no Emacs exist, it should start one, start a server and open a file.

#+begin_src emacs-lisp
  (use-package server
    :straight nil
    :config
    (unless (server-running-p)
      (server-start)))
#+end_src

To fully achieve this behavior one needs a =.desktop= file to exist that will decide which kind of Emacs to call: =emacs= or =emacsclient=:

#+begin_src conf-xdefaults :tangle ~/.local/share/applications/emacs.desktop :mkdirp yes :results silent
  [Desktop Entry]
  Name=Emacs
  GenericName=Text Editor
  Comment=Edit text
  MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
  Exec=sh -c "[ $# -gt 0 ] && emacsclient -a emacs -n \"\$@\" || command emacs" dummy %F
  Icon=emacs
  Type=Application
  Terminal=false
  Categories=Development;TextEditor;Utility;
  StartupWMClass=Emacs
#+end_src

This code above automatically creates user local =emacs.desktop= file in =~/.local/share/applications= that will:

- call =emacs= if no arguments provided, or
- call =emacsclient -a emacs= with arguments.
  =emacsclient= will try to connect to a server, and if there's none, it will fire up =emacs= which will create server, and opening new files will be done in this instance of =emacs=.

** Hideshow
This built in mode provides code folding.
I use =transient= to create little interactive menu for easy interaction.

#+begin_src emacs-lisp
  (use-package hideshow
    :straight nil
    :after transient
    :hook (prog-mode . hs-minor-mode)
    :bind (:map prog-mode-map
           ("<f6>" . hydrant/hideshow-menu/body))
    :config
    (when (fboundp #'defhydra)
      (defhydra hydrant/hideshow-menu (:color pink :hint nil)
        "
   ^Hide^       ^Show^       ^Exit^
   _ha_: all    _sa_: all    _qs_: quit show all
   _hb_: block  _sb_: block  _qh_: quit hide all
   ^  ^         ^  ^         _qq_: quit"
        ("ha" hs-hide-all)
        ("hb" hs-hide-block)
        ("sa" hs-show-all)
        ("sb" hs-show-block)
        ("qq" ignore :exit t)
        ("qs" hs-show-all :exit t)
        ("qh" hs-hide-all :exit t))))
#+end_src

** Desktop
This is really nice feature that allows me to save my workspace on disk and do not restore all buffers and windows every time I start Emacs.
It adds some time to the startup though.

#+begin_src emacs-lisp
  (use-package desktop
    :straight nil
    :if window-system
    :hook ((after-init . aorst/desktop-restore))
    :custom
    (desktop-path `(,user-emacs-directory))
    (desktop-dirname user-emacs-directory)
    (desktop-base-file-name "desktop")
    (desktop-base-lock-name "desktop.lock")
    (desktop-save t)
    (desktop-load-locked-desktop t)
    (desktop-locals-to-save nil)
    (desktop-globals-to-save nil)
    (desktop-restore-frames nil)
    :config
    (dolist (mode '(solaire-mode
                    parinfer-rust-mode))
      (add-to-list 'desktop-minor-mode-table `(,mode ,nil)))
    :init
    (defun aorst/desktop-restore ()
      "Restore a saved emacs session."
      (interactive)
      (desktop-save-mode t)
      (when (file-exists-p
             (concat desktop-dirname desktop-base-file-name))
        (desktop-read))))
#+end_src

I wonder if it could store unsaved buffers so all my changes persist through sessions.

** Edit Indirect
This package makes it possible to edit Markdown code blocks in separate buffers.

#+begin_src emacs-lisp
  (use-package edit-indirect
    :hook ((edit-indirect-after-creation . aorst/edit-indirect-header-line-setup))
    :bind (:map edit-indirect-mode-map
           ("C-c C-c" . edit-indirect-commit)
           ("C-c C-k" . edit-indirect-abort)
           ("C-c '" . nil))
    :init
    (defun aorst/edit-indirect-header-line-setup ()
      (setq-local
       header-line-format
       (substitute-command-keys
        "\\<edit-indirect-mode-map>Edit, then exit with `\\[edit-indirect-commit]' or abort with `\\[edit-indirect-abort]'"))))
#+end_src

** Separedit
This package provides a way to edit comments in sources as separate buffers with another major mode, like Markdown.

#+begin_src emacs-lisp
  (use-package separedit
    :hook (separedit-buffer-creation . aorst/separedit-header-line-setup)
    :bind (:map prog-mode-map
           ("C-c '" . separedit)
           :map edit-indirect-mode-map
           ("C-c '" . separedit))
    :custom
    (separedit-default-mode 'markdown-mode)
    :init
    (defun aorst/separedit-header-line-setup ()
      (setq-local
       header-line-format
       (substitute-command-keys
        "Edit, then exit with `\\[separedit-commit]' or abort with `\\[edit-indirect-abort]'"))))
#+end_src

** Recent files
Settings to =recentf= mode.

#+begin_src emacs-lisp
  (use-package recentf
    :straight nil
    :config
    (add-to-list 'recentf-exclude "\\.gpg\\"))
#+end_src

** Smooth Scroll
This minor mode provides a nice way of having fake smooth scrolling that helps seeing where.

#+begin_src emacs-lisp
(use-package smooth-scroll
  :config
  (smooth-scroll-mode)
  (setq smooth-scroll/vscroll-step-size 10)
  (setq smooth-scroll/hscroll-step-size 4))
#+end_src

** Dumb Jump
Dumbest definition jumping that just work.

#+begin_src emacs-lisp
  (use-package dumb-jump
    :custom (dumb-jump-prefer-searcher 'rg)
    :config
    (add-to-list 'xref-backend-functions #'dumb-jump-xref-activate))
#+end_src

** Which Key
A useful package that displays all keybindings available for the chord you're entering after a certain delay.

#+begin_src emacs-lisp
  (use-package which-key
    :config (which-key-mode t))
#+end_src

** GCMH
Garbage Collector Magic Hack.
Runs GC when Emacs is idle, and increases GC treshold during active use.

#+begin_src emacs-lisp
  (use-package gcmh
    :config (gcmh-mode t))
#+end_src

** Indent guides
Indentation guides for Emacs.

#+begin_src emacs-lisp
  (use-package indent-guide
    :hook (prog-mode . indent-guide-mode)
    :custom-face
    (indent-guide-face ((t (:inherit font-lock-comment-face))))
    :custom
    (indent-guide-char "â”Š")) ;; â”Šâ”‚â”†
#+end_src

* Postscript
This Emacs Configuration features various cool E-Lisp hacks somewhere that I've found over the Internet, and I try to keep references to original places, so reader could refer to those, because I alter these pieces of code for my personal needs and thus it may not be compatible with other people tastes, and because I want to credit original author.

If you find any issue with my config feel free to [[https://github.com/andreyorst/dotfiles/issues/new][file an issue]] or contact me via email: [[mailto:andreyorst@gmail.com][andreyorst@gmail.com]].

And as a final step of a proper init file:

#+begin_src emacs-lisp
  (provide 'init)
  ;;; init.el ends here
#+end_src

Thanks for reading!
