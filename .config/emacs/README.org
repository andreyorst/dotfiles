#+title: Emacs configuration with Org Mode
#+author: Andrey Orst
#+email: andreyorst@gmail.com
#+setupfile: ./.org-defaults.org
#+startup: noinlineimages
#+property: header-args :tangle "./init.el" :results silent

[[file:.screenshot.png]]

* About this document

This is my Emacs configuration file written as Org document.  I do all
edits here,  then /compile/ it to  =init.el= file. Emacs is  complex tool,
and  by  having my  configuration  in  Org  Mode,  I can  separate  my
configuration  in sections,  comment  each  configuration, and  toggle
configuration parts on and off with ease.

I  try to  maintain my  Emacs  configuration simple,  fast, and  small
keeping as much  of vanilla Emacs behaviors  as I can, but  I'm a sane
person so  some aspects which  are actually  insane in my  opinion are
changed.

Org Mode has a function  called =org-babel-tangle= that exports all code
blocks accordingly to =header-args= property. Calling this function with
this file as an argument will result in creation of =init.el= located at
=.config/emacs= in  your home directory. This  means that you only  need this
file  in order  to  get my  Emacs configuration  and  compile it  with
=org-babel-tangle= function for the first  time.  After that, every time
this file is saved it gets re-tangled automatically.

Since I'm  trying to  follow Emacs conventions,  good Emacs  Lisp file
starts with commentary:

#+begin_src emacs-lisp
  ;;; init.el --- Emacs main configuration file -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-
  ;;;
  ;;; Commentary:
  ;;; Emacs config by Andrey Orst.
  ;;; This file was automatically generated by `org-babel-tangle'.
  ;;; Do not change this file.  Main config is located in .config/emacs/README.org
  ;;;
  ;;; Code:
#+end_src

At  this point  configurations  will be  split  in different  sections
grouped by something common to them all.

* Initial Setup
Emacs starts fast, but as amount of packages grows it gets slower. The
init time is important  because I like to close it  when I'm not using
it. I'm not  closing and opening it  for every file, or  like every 15
minutes, but still, the faster it starts - the better for me.

** =early-init.el=
:properties:
:header-args+: :tangle "./early-init.el"
:end:

These settings are going into  different init file: =earli-init.el=.  We
are  going to  use some  speedup  technics from  [[https://github.com/hlissner/doom-emacs][doom-emacs]] here.  But
before that, let's add top comment:

#+begin_src emacs-lisp
  ;;; early-init.el --- early configurations -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-
  ;;;
  ;;; Commentary:
  ;;; Emacs confi by Andrey Orst.
  ;;; This file was automatically generated by `org-babel-tangle'.
  ;;; Do not change this file.  Main config is located in .config/emacs/README.org
  ;;;
  ;;; Code:
#+end_src

*** Garbage Collection
The main problem  with Emacs startup is garbage  collection system. It
is invoked so many times on startup that it causes quite big impact on
startup time.   We're talking  /seconds/.  One can  raise limit  when to
trigger garbage collection, but this will end up in unpleasant editing
experience. So I'm  declaring these variables to  store default values
for the GC, to restore them after initialization is finished:

#+begin_src emacs-lisp
  (defvar aorst--gc-cons-threshold gc-cons-threshold)
  (defvar aorst--gc-cons-percentage gc-cons-percentage)
  (defvar aorst--file-name-handler-alist file-name-handler-alist)
#+end_src

Now we can tweak CG. We need to raise threshold to prevent it running:

#+begin_src emacs-lisp
  (setq-default gc-cons-threshold 402653184
                gc-cons-percentage 0.6
                inhibit-compacting-font-caches t
                message-log-max 16384
                file-name-handler-alist nil)
#+end_src

Then we need  a hook that restores initial  values once initialization
done:

#+begin_src emacs-lisp
  (add-hook 'after-init-hook
            (lambda ()
              (setq gc-cons-threshold aorst--gc-cons-threshold
                    gc-cons-percentage aorst--gc-cons-percentage
                    file-name-handler-alist aorst--file-name-handler-alist)))
#+end_src

*** Native Compiled Emacs Lisp
There's a  very interesting project  that I'm currently  using, called
[[https://akrl.sdf.org/gccemacs.html][gccemacs]]. It  provides a way to  compile Emacs Lisp into  native code,
thus making  Emacs much more  robust and  snappy. In order  to compile
everything that Emacs loads asynchronously we can set this variable to
=true=.

#+begin_src emacs-lisp
  (defvar comp-deferred-compilation)
  (setq comp-deferred-compilation t)
#+end_src

This way  I can compile  Emacs from source as  I usually do,  and then
continue using it as normal, and Emacs will do it's native compilation
in background for every loaded package. That's amazing!

*** User Interface
Prevent the glimpse of un-styled  Emacs by disabling these UI elements
early.

#+begin_src emacs-lisp
  (setq default-frame-alist '((width . 190)
                              (height . 68)
                              (tool-bar-lines . 0)
                              (vertical-scroll-bars)))
#+end_src

Resizing frame is also expensive so we inhibit it, and latest patch to
Emacs  introduced =x-gtk-resize-child-frames=  variable  that fixes  the
issue  with  child frames  not  being  resized correctly  under  GNOME
Shell, so let's set it to =resize-mode=.

#+begin_src emacs-lisp
  (setq frame-inhibit-implied-resize t
        x-gtk-resize-child-frames 'resize-mode)
#+end_src

*** =package.el=
=package.el= initialization is expensive so we disable it at startup:

#+begin_src emacs-lisp
  (defvar package--init-file-ensured)
  (setq package-enable-at-startup nil
        package--init-file-ensured t)
#+end_src

*** =(provide 'early-init)=
This concludes the =early-init.el= file.

#+begin_src emacs-lisp
  (provide 'early-init)
  ;;; early-init.el ends here
#+end_src

*** Loading =early-init.el= in Emacs 26 and earlier
:properties:
:header-args+: :tangle "./init.el"
:end:
Before Emacs  27 there were  no such thing  as =eraly-init.el=, so  if I
will use  older Emacs  with this configuration  it will  miss settings
that are done there. This code manually loads this file in such case:

#+begin_src emacs-lisp
  (unless (featurep 'early-init)
    (load (expand-file-name "early-init" user-emacs-directory)))
#+end_src

** =package.el=
To obtain plugins we need =package.el= package. Although this is builtin
and convenient,  it's also slow  and messy.  Instead of  using =package=
directly we will use =use-package= to manage package configurations.

Melpa is a  package repository, that I use to  get packages. Since all
packages that  I need can be  obtained from there, I  did not bothered
with different methods of installation.

#+begin_src emacs-lisp
  (defvar package-archives)
  (setq package-archives
        '(("gnu" . "https://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")))
#+end_src

There's recent bug with downloading from elpa. This line fixes it:

#+begin_src emacs-lisp
  (when (version= emacs-version "26.2")
    (defvar gnutls-algorithm-priority)
    (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3"))
  (package-initialize)
#+end_src

** =use-package=
I use =use-package= to install, load  and configure my packages.  I find
this way very consistent and easy  to understand and maintain.  What I
like  about it  is that  it automatically  installs packages  on Emacs
startup. But unfortunately it can't be installed by itself, so we need
a way  to install  Use Package  in case  I load  this config  on fresh
system.

#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
#+end_src

And =require= the package itself:

#+begin_src emacs-lisp
  (require 'use-package)
  (setq use-package-always-ensure t)
#+end_src

This  way I  can  use =use-package=  automatically  install packages  at
startup, and  to configure  both built in  and external  packages, and
have  all   benefits  provided   by  =use-package=  such   as  deferring
configuration, encapsulating configuration, and so on.

* Defaults
Emacs is  old. I  understand that  back then  it could  be appropriate
decisions,  but as  of today  they are  completely obliterated  by the
passage of time.

** User Credentials
Let's set full name and e-mail address in case I would send e-mail from
Emacs, or some modes can use those automatically, like Org Mode:

#+begin_src emacs-lisp
  (use-package startup
    :no-require t
    :ensure nil
    :custom
    (user-mail-address "andreyorst@gmail.com")
    (user-full-name "Andrey Orst"))
#+end_src

** Bell
I'm not  trying to  insult on anyone,  but usage of  the bell  is just
insane. It's  not 1980's, computers  have their own speakers  and rich
displays, why would anyone want  to use builtin speaker?  Why everyone
should know when I'm mistaken? Disable bell.

#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
#+end_src

** Backups
I don't  know who decided  that having backups  all over the  place is
good idea, but I don't think alike.

#+begin_src emacs-lisp
  (use-package files
    :ensure nil
    :custom
    (backup-by-copying t)
    (create-lockfiles nil)
    (backup-directory-alist '(("." . "~/.cache/emacs-backups")))
    (auto-save-file-name-transforms '((".*" "~/.cache/emacs-backups/" t))))
#+end_src

** Yes or No
For some  reason in some  situations Emacs asks  for typing =yes=  or =no=
explicitly, instead of accepting =y= or =n=. This can be fixed with this.

#+begin_src emacs-lisp
  (use-package subr
    :no-require t
    :ensure nil
    :init
    (fset 'yes-or-no-p 'y-or-n-p))
#+end_src

** Echo Keystrokes
Emacs displays pressed  key after some time but it's  too fast for me,
because I use Emacs on the phone  too, and the keyboard is a bit small
for lightning fast typing.

#+begin_src emacs-lisp
  (add-hook 'after-init-hook (lambda () (setq echo-keystrokes 5)))
#+end_src

** Mouse and Scrolling
I don't want menus on shift clicks:

#+begin_src emacs-lisp
  (global-unset-key (kbd "S-<down-mouse-1>"))
  (global-unset-key (kbd "<mouse-3>"))
  (global-set-key [mouse-3] menu-bar-edit-menu)
  (global-unset-key (kbd "S-<mouse-3>"))
#+end_src

I also  don't like how Emacs  handles scrolling, that it  speeds it up
and automatically scrolls horizontally. Also, changing =mouse-highlight=
to  =nil= value  disables highlighting  of hovered  item when  the point
moves which is kinda convenient when working with =flymake=.

#+begin_src emacs-lisp
  (setq-default mouse-wheel-progressive-speed nil
                auto-window-vscroll nil
                mouse-highlight nil)
#+end_src

** Tab character
Another default  setting that I kinda  dislike. Not that I'm  a fan of
spaces over tabs,  but I find that  there are much more  modes or even
languages that expect spaces, and not  tabs.  For instance, I need tab
characters only when I work with C code and Makefile rules.

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

** Custom File and Disabled Commands
I  don't like  custom,  and  especially would  like  to  stop it  from
interfering to  my configuration  files, so lets  move it  to separate
file.

#+begin_src emacs-lisp
  (use-package cus-edit
    :ensure nil
    :custom
    (custom-file (expand-file-name "custom.el" user-emacs-directory))
    :init
    (load custom-file :noerror))
#+end_src

I also don't like that Emacs  has disabled commands, and enabling them
modifies  my =init.el=  that I  don't  modify myself.   Let's put  those
commands to =disabled.el= instead:

#+begin_src emacs-lisp
  (defvar disabled-commands (expand-file-name ".disabled.el" user-emacs-directory)
    "File to store disabled commands, that were enabled permamently.")
  (defadvice en/disable-command (around put-in-custom-file activate)
    "Put declarations in disabled.el."
    (let ((user-init-file disabled-commands))
      ad-do-it))
  (load disabled-commands :noerror)
#+end_src

** History
Another feature I  want is history between sessions. I'm  not sure why
it isn't default.

#+begin_src emacs-lisp
  (savehist-mode 1)
#+end_src

** Keyboard Layout
I use two keyboard layouts: =qwerty=  and =йцукен=, therefore I need a way
to switch between those without loosing  ability to use such chords as
=C-x=  which will  become  a =C-ч=  if  I select  Cyrillic  layout in  the
OS. Luckily for  me, Emacs provides a method to  switch layouts within
Emacs with =C-\=, so all common shortcuts will still work fine.

#+begin_src emacs-lisp
  (use-package mule-cmds
    :no-require t
    :ensure nil
    :custom
    (default-input-method 'russian-computer))
#+end_src

I'm  not   using  =russian-jcuken=   here  because  it   represents  the
"typewriter" layout with number-line inverted,  so to access numbers I
need to use Shift key. =russian-computer= doesn't have this problem.

** UTF8
Let's use =UTF8= if we can:

#+begin_src emacs-lisp
  (prefer-coding-system 'utf-8)
  (when (display-graphic-p)
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src

** Default Major Mode
I would  like =*scratch*= buffer  to use  =fundamental= mode, so  it loads
faster.  Since  it's no  longer Emacs  Lisp interaction  buffer, let's
also remove initial message:

#+begin_src emacs-lisp
  (use-package startup
    :no-require t
    :ensure nil
    :custom
    (initial-major-mode 'fundamental-mode)
    (initial-scratch-message ""))
#+end_src

** Selection
It is conveinient to delete selection by typing:

#+begin_src emacs-lisp
  (use-package delsel
    :ensure nil
    :init
    (delete-selection-mode t))
#+end_src

** Default Bindings and More
Configurations to built in =simple.el= module.

By default Emacs uses =kill-region= command on =C-w= shortcut. I find thisq
counterintuitiveq. GNU Readline uses =C-w=  to kill word backwards. Otherq
software  uses  this  shortcut  to kill  window.   I  prefer  Readline
approach.   Also I've  missed  =o=  and =O=  commands  from Kakoune.  With
=newline-below=  and  =newline-above= it  is  now  possible to  have  same
shortcuts in Emacs.

Emacs has nice  function, =zap-up-to-char= but for some  reason it's not
bound to any key. I find it more usable than =zap-to-char= so let's swap
those here.

Also,  I don't  want  my  files to  contain  trailing whitespaces,  so
=before-save-hook= hook will get rid of those automatically for me.

#+begin_src emacs-lisp
  (use-package simple
    :ensure nil
    :bind (("C-w" . aorst/kill-region-or-word)
           ("C-o" . aorst/newline-below)
           ("C-S-o" . aorst/newline-above)
           ("M-z" . zap-up-to-char)
           ("M-S-z" . zap-to-char))
    :hook (before-save . delete-trailing-whitespace)
    :init
    (defun aorst/kill-region-or-word (arg)
      (interactive "*p")
      (if (and transient-mark-mode
               mark-active)
          (kill-region (region-beginning) (region-end))
        (backward-kill-word arg)))
    (defun aorst/newline-below ()
      (interactive)
      (end-of-line)
      (newline-and-indent))
    (defun aorst/newline-above ()
      (interactive)
      (back-to-indentation)
      (newline-and-indent)
      (forward-line -1)
      (indent-according-to-mode)))
#+end_src

* Functions
This  section  describes  functions  I have  defined  for  use  inside
configurations  of various  packages, that  are general  enough to  be
placed in particular package  configuration. For example when function
is shared  between configurations  and some  configuration may  not be
loaded.

I prefix my  functions with =aorst/= and variables with  =aorst--= to make
those easier  to browse  with =ivy=  and to  explicitly define  that the
function is not a part of a particular package.

** =real-buffer-p=
This function decides if buffer  should be considered a "real" buffer,
e.g. a file-visiting buffer, or specific buffers that should behave as
file-visiting while not visiting a particular file, like =*scratch*=

#+begin_src emacs-lisp
  (defun aorst/real-buffer-p (&optional buffer)
    "Determines whether buffer is real."
    (let ((buffer-name (buffer-name buffer)))
      (or (and (not (minibufferp))
               (buffer-file-name buffer))
          (string-equal "*scratch*" buffer-name)
          (string-match-p ".~.*~" buffer-name)
          (string-match-p "FILE=/" buffer-name)
          (string-match-p "\*edit-indirect .*\*" buffer-name)
          (string-match-p "\*Org Src .*\*" buffer-name))))
#+end_src

** =real-buffer-setup=
If only  certain buffers  could +be so  grossly incandescent+  *have damn
fringes!* With Solaire Mode Emacs becomes way more like true GUI editor
with actual elements of user interface represented by different color,
but  these fringes  drive me  crazy.  That's  why I  wrote a  function
=aorst/real-buffer-setup=, that enables fringes only in buffers that are
affected by Solaire Mode:

#+begin_src emacs-lisp
  (defun aorst/real-buffer-setup (&rest _)
    "Wrapper around `set-window-fringes' function."
    (when window-system
      (let* ((window (selected-window))
             (buffer (window-buffer window)))
        (when (aorst/real-buffer-p buffer)
          (set-window-fringes window 8 8 t)
          (when (bound-and-true-p desktop-save-mode)
            (setq desktop-save-buffer t))))))
#+end_src

** =kill-when-no-processes=
This function  kills buffer which used  to have active process  but it
was killed. Should be used via hook or advice.

#+begin_src emacs-lisp
  (defun aorst/kill-when-no-processes (&rest _)
    "Kill buffer and its window when there's no processes left."
    (when (null (get-buffer-process (current-buffer)))
      (kill-buffer (current-buffer))))
#+end_src

** =escape=
One thing  that bothered  me is  that =C-g= is  universal way  to cancel
things in Emacs, gut you have to  be in exact window to cancel action.
This  function  intelligently tries  to  cancel  regardless of  active
window:

#+begin_src emacs-lisp
  (defun aorst/escape ()
    "Quit in current context.

  When there is an active minibuffer and we are not inside it close
  it.  When we are inside the minibuffer use the regular
  `minibuffer-keyboard-quit' which quits any active region before
  exiting.  When there is no minibuffer `keyboard-quit' unless we
  are defining or executing a macro."
    (interactive)
    (cond ((active-minibuffer-window)
           (if (minibufferp)
               (minibuffer-keyboard-quit)
             (abort-recursive-edit)))
          ((bound-and-true-p iedit-mode)
           (iedit-quit))
          (t
           (unless (or defining-kbd-macro
                       executing-kbd-macro)
             (keyboard-quit))))
    (message this-command))
  (global-set-key [remap keyboard-quit] #'aorst/escape)
#+end_src

** =font-installed-p=
This function checks if font is available on the system.

#+begin_src emacs-lisp
  (defun aorst/font-installed-p (font-name)
    "Check if font with FONT-NAME is available."
    (find-font (font-spec :name font-name)))
#+end_src

** =indent-buffer=
This function  is kinda  a way  to indent a  buffer by  using language
indentation rules provided by current mode. If there's a tool that can
properly format buffer it should be used instead of this function.

#+begin_src emacs-lisp
  (defun aorst/indent-buffer ()
    (interactive)
    (save-excursion
      (save-restriction
        (indent-region (point-min) (point-max)))))
  (global-set-key (kbd "C-c C-f") #'aorst/indent-buffer)
#+end_src

* User Interface
Packages that affect user interface.

** Splash Screen
Emacs displays splash screen once started  with no files. I don't need
it, so let's disable it.

#+begin_src emacs-lisp
  (use-package startup
    :no-require t
    :ensure nil
    :custom
    (inhibit-splash-screen t))
#+end_src

** Menus and Tooltips
I don't need  all these tooltips, menus and  scrollbars. Emacs enables
all of those by default, so let's disable them as early as possible:

#+begin_src emacs-lisp
  (tooltip-mode -1)
  ; (menu-bar-mode -1)
  (fset 'menu-bar-open nil)

  (when window-system
    (scroll-bar-mode -1)
    (tool-bar-mode -1))
#+end_src

** Cursor Type
Also let's use bar cursor when in window system, which is visible only
in active window:

#+begin_src emacs-lisp
  (when window-system
    (setq-default cursor-type 'bar
                  cursor-in-non-selected-windows nil))
#+end_src

** Font
I'm a  big fan  of [[https://github.com/source-foundry/Hack][Hack]]  font. It  has nice  support of  languages and
styles like *bold*, /italics/ for not only Latin languages. If =Hack= is not
found we try =Source Code Pro= as a fallback option.

#+begin_src emacs-lisp
  (cond ((aorst/font-installed-p "Hack")
         (set-face-attribute 'default nil :font "Hack 10"))
        ((aorst/font-installed-p "Source Code Pro")
         (set-face-attribute 'default nil :font "Source Code Pro 10")))
#+end_src

** Icons
=all-the-icons= package provides nice icons for Emacs via custom fonts.

#+begin_src emacs-lisp
  (use-package all-the-icons
    :config
    (when (and (not (aorst/font-installed-p "all-the-icons"))
               (window-system))
      (all-the-icons-install-fonts t)))
#+end_src

I don't  use this package  directly yet,  but some other  packages do,
like DOOM Modeline or Treemacs.

** Theme
I'm using *doom-themes* package to make my Emacs look modern. This theme
collection  was developed  for [[https://github.com/hlissner/doom-emacs][DOOM  Emacs]],  and I  find these  themes
actually  great on  its own.   This package  contains nice  variant of
Atom-like One theme which I like, but it is also an amazingly well put
package, which defines colors for pretty much everything in Emacs.

#+begin_src emacs-lisp
  (use-package doom-themes
    :custom
    (doom-themes-enable-bold t)
    (doom-themes-enable-italic t)
    :init
    (load-theme 'doom-one t)
    (set-face-attribute 'highlight nil
                        :foreground 'unspecified
                        :distant-foreground 'unspecified
                        :background 'unspecified))
#+end_src

** Fringe
I want fringes  to appear only in certain buffers  where I really need
them, so let's  disable it entirely on startup and  set them with some
hooks later.  But this adds another problem.  Emacs displays =$= sign at
the end of the  window if line is being truncated. Damn,  why it is so
hard  to  make  it  work  how  I want..   And  you  can't  simply  set
=standard-display-table= slot to empty space,  because it isn't ready on
Emacs init.

#+begin_src emacs-lisp
  (when window-system
    (use-package fringe
      :ensure nil
      :hook ((buffer-list-update
              window-configuration-change
              change-major-mode) . aorst/real-buffer-setup)
      :init
      (fringe-mode 0)
      (or standard-display-table
          (setq standard-display-table (make-display-table)))
      (set-display-table-slot standard-display-table 0 ?\ )))
#+end_src

** Solaire Mode
This  package helps  distinguish  buffers that  have  file opened  and
buffers that  are for utilities  like file  browser. Also it  has cool
name! =\[T]/=

I really want  Solaire to treat =*scratch*= buffer as  real.  For that I
need to define my  own function that will decide if  buffer is real or
not. Now we can set up  Solaire Mode and assign =aorst/real-buffer-p= to
=solaire-mode-real-buffer-fn=.

#+begin_src emacs-lisp
  (use-package solaire-mode
    :commands (solaire-global-mode
               solaire-mode-swap-bg
               turn-on-solaire-mode
               solaire-mode-in-minibuffer
               solaire-mode-reset)
    :hook (((after-revert
             change-major-mode
             org-src-mode) . turn-on-solaire-mode)
           (snippet-mode . solaire-mode))
    :config
    (setq solaire-mode-real-buffer-fn #'aorst/real-buffer-p)
    (solaire-mode-swap-bg)
    (with-no-warnings
      (if (boundp 'after-focus-change-function)
          (add-function :after after-focus-change-function #'solaire-mode-reset)
        (add-hook 'focus-in-hook  #'solaire-mode-reset)))
    (defun aorst/create-image-with-background-color (args)
      "Specify background color of Org-mode inline image through modify `ARGS'."
      (let* ((file (car args))
             (type (cadr args))
             (data-p (caddr args))
             (props (cdddr args)))
        ;; get this return result style from `create-image'
        (append (list file type data-p)
                (list :background (face-attribute (or (cadr (assq 'default face-remapping-alist))
                                                      'default)
                                                  :background nil t))
                props)))
    (advice-add 'create-image :filter-args #'aorst/create-image-with-background-color)
    :init (solaire-global-mode +1))
#+end_src

** Modeline
I've tried bunch of different modelines:

- [[https://github.com/TheBB/spaceline][Spaceline]]
  Great modeline, but  I was experiencing slowdowns  in Emacs startup,
  and I like my Emacs to start fast.
- [[https://github.com/dbordak/telephone-line][Telephone Line]]
  Another good modeline, but I was lazy to configure it.
- [[https://github.com/milkypostman/powerline][Powerline]]
  This was first what I tried because I was using something similar in
  Vim. I don't remember why I dropped it.
- [[https://github.com/tarsius/moody][Moody]]
  Really lightweight  configuration for  default modeline,  which I've
  used for quite a some time.

They're all  great, but  I experienced some  troubles with  DOOM Theme
that I use, so  I've decided to try out DOOM  Modeline.  And turns out
it's great!

#+begin_src emacs-lisp
  (use-package doom-modeline
    :config
    (let ((fg (face-attribute 'default :foreground))
          (bg (face-attribute 'mode-line :background))
          (fg-inactive (face-attribute 'font-lock-comment-face :foreground))
          (bg-inactive (face-attribute 'mode-line-inactive :background)))
      (dolist (face '(doom-modeline-buffer-modified
                      doom-modeline-buffer-minor-mode
                      doom-modeline-project-parent-dir
                      doom-modeline-project-dir
                      doom-modeline-project-root-dir
                      doom-modeline-highlight
                      doom-modeline-debug
                      doom-modeline-info
                      doom-modeline-warning
                      doom-modeline-urgent
                      doom-modeline-unread-number
                      doom-modeline-buffer-path
                      doom-modeline-bar
                      doom-modeline-bar-inactive
                      doom-modeline-panel
                      doom-modeline-buffer-major-mode
                      doom-modeline-buffer-file
                      doom-modeline-lsp-success
                      doom-modeline-lsp-warning
                      doom-modeline-lsp-error
                      doom-modeline-lsp-running
                      doom-modeline-persp-name
                      doom-modeline-battery-full
                      doom-modeline-battery-error
                      doom-modeline-battery-charging
                      doom-modeline-battery-critical
                      doom-modeline-battery-normal))
        (set-face-attribute face nil :foreground fg :weight 'normal))
      (set-face-attribute 'doom-modeline-buffer-file nil :weight 'semi-bold)
      (set-face-attribute 'doom-modeline-buffer-major-mode nil :weight 'semi-bold)
      (set-face-attribute 'doom-modeline-panel nil :background bg)
      (set-face-attribute 'doom-modeline-bar nil :background bg)
      (set-face-attribute 'doom-modeline-bar-inactive nil :background bg)
      (set-face-attribute 'mode-line-inactive nil :foreground fg-inactive :background bg-inactive))
    (setq doom-modeline-bar-width 3
          doom-modeline-major-mode-color-icon nil
          doom-modeline-buffer-color-icon nil
          doom-modeline-buffer-file-name-style 'relative-from-project
          doom-modeline-minor-modes t
          find-file-visit-truename t)
    (doom-modeline-mode 1))
#+end_src

I  don't  find displaying  position  in  modeline really  great  idea,
because I need to move my eyes too much on big screen just to see what
line number  I'm currently  on. Also, let's  make modeline  little bit
bigger.  And remove that bevel thing.

#+begin_src emacs-lisp
  (setq column-number-mode nil
        line-number-mode nil
        size-indication-mode nil
        mode-line-position nil
        mode-line-in-non-selected-windows nil)
  (unless (bound-and-true-p doom-modeline-mode)
    (set-face-attribute 'mode-line nil
                        :box (list :line-width 7
                                   :color (face-attribute 'mode-line :background))))
#+end_src

** Frame
Emacs uses  white titlebar, but  since I'm  using dark color  scheme I
want title bar  to be dark as  well. It is quite  difficult to achieve
this in GNOME  Shell, but I found  this code [[https://nicolas.petton.fr/blog/emacs-dark-window-decoration.html][on the internet]].  So if I
use =window-system=  I want this  function to run  during initialization
process, and when new frame is created.

#+begin_src emacs-lisp
  (when window-system
    (use-package frame
      :ensure nil
      :config
      (setq window-divider-default-right-width 1)
      (window-divider-mode 1)
      (set-face-attribute
       'window-divider nil
       :foreground (face-attribute
                    'mode-line-inactive :background))))
#+end_src

** Title
Emacs uses weird method of naming a window, I'd like to see a file I'm
currently working  on in the task  bar in case my  Emacs was minimized
for some reason.

#+begin_src emacs-lisp
  (setq-default frame-title-format '("%b — Emacs"))
#+end_src

** Treemacs
To make Emacs look more like  a traditional modern text editor we need
a file explorer.  Emacs has  builtin package for this, named =speedbar=,
but It uses external frame and has  so many features that I don't know
if I really need. With this package, and its supplement packages I can
have a consistent  filetree inside my Emacs frame. Which  is good. But
there's more:  DOOM Themes support  this package as well,  which means
that Treemacs will look just as great as DOOM themed Emacs!

#+begin_src emacs-lisp
  (when window-system
    (use-package treemacs
      :commands (treemacs-follow-mode
                 treemacs-filewatch-mode
                 treemacs-fringe-indicator-mode
                 treemacs-load-theme)
      :bind (("<f7>" . treemacs)
             ("<f8>" . treemacs-select-window)
             :map
             treemacs-mode-map
             ([C-tab] . aorst/treemacs-expand-all-projects))
      :hook ((after-init . aorst/treemacs-after-init-setup)
             (treemacs-mode . aorst/after-treemacs-setup)
             (treemacs-switch-workspace . aorst/treemacs-expand-all-projects)
             (treemacs-switch-workspace . treemacs-set-fallback-workspace)
             (treemacs-mode . aorst/treemacs-setup-title))
      :config
      (use-package treemacs-magit)
      (setq treemacs-width 34
            treemacs-is-never-other-window t
            treemacs-space-between-root-nodes nil
            treemacs-indentation 2)
      (treemacs-follow-mode t)
      (treemacs-filewatch-mode t)
      (treemacs-fringe-indicator-mode nil)
      (set-face-attribute 'treemacs-root-face nil
                          :foreground (face-attribute 'default :foreground)
                          :height 1.0
                          :weight 'normal)
      (defun aorst/treemacs-ignore (file _)
        (or (s-ends-with? ".elc" file)
            (s-ends-with? ".o" file)
            (s-ends-with? ".a" file)
            (string= file ".svn")))
      (add-to-list 'treemacs-ignored-file-predicates #'aorst/treemacs-ignore)
      (treemacs-create-theme "Atom"
        :config
        (progn
          (treemacs-create-icon
           :icon (format " %s\t"
                         (all-the-icons-octicon
                          "repo"
                          :v-adjust -0.1
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (root))
          (treemacs-create-icon
           :icon (format "%s\t%s\t"
                         (all-the-icons-octicon
                          "chevron-down"
                          :height 0.75
                          :v-adjust 0.1
                          :face '(:inherit font-lock-doc-face :slant normal))
                         (all-the-icons-octicon
                          "file-directory"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (dir-open))
          (treemacs-create-icon
           :icon (format "%s\t%s\t"
                         (all-the-icons-octicon
                          "chevron-right"
                          :height 0.75
                          :v-adjust 0.1
                          :face '(:inherit font-lock-doc-face :slant normal))
                         (all-the-icons-octicon
                          "file-directory"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (dir-closed))
          (treemacs-create-icon
           :icon (format "%s\t%s\t"
                         (all-the-icons-octicon
                          "chevron-down"
                          :height 0.75
                          :v-adjust 0.1
                          :face '(:inherit font-lock-doc-face :slant normal))
                         (all-the-icons-octicon
                          "package"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (tag-open))
          (treemacs-create-icon
           :icon (format "%s\t%s\t"
                         (all-the-icons-octicon
                          "chevron-right"
                          :height 0.75
                          :v-adjust 0.1
                          :face '(:inherit font-lock-doc-face :slant normal))
                         (all-the-icons-octicon
                          "package"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (tag-closed))
          (treemacs-create-icon
           :icon (format "%s\t"
                         (all-the-icons-octicon
                          "tag"
                          :height 0.9
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (tag-leaf))
          (treemacs-create-icon
           :icon (format "%s\t"
                         (all-the-icons-octicon
                          "flame"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (error))
          (treemacs-create-icon
           :icon (format "%s\t"
                         (all-the-icons-octicon
                          "stop"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (warning))
          (treemacs-create-icon
           :icon (format "%s\t"
                         (all-the-icons-octicon
                          "info"
                          :height 0.75
                          :v-adjust 0.1
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (info))
          (treemacs-create-icon
           :icon (format "  %s\t"
                         (all-the-icons-octicon
                          "file-media"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("png" "jpg" "jpeg" "gif" "ico" "tif" "tiff" "svg" "bmp"
                        "psd" "ai" "eps" "indd" "mov" "avi" "mp4" "webm" "mkv"
                        "wav" "mp3" "ogg" "midi"))
          (treemacs-create-icon
           :icon (format "  %s\t"
                         (all-the-icons-octicon
                          "file-code"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("yml" "yaml" "sh" "zsh" "fish" "c" "h" "cpp" "cxx" "hpp"
                        "tpp" "cc" "hh" "hs" "lhs" "cabal" "py" "pyc" "rs" "el"
                        "elc" "clj" "cljs" "cljc" "ts" "tsx" "vue" "css" "html"
                        "htm" "dart" "java" "kt" "scala" "sbt" "go" "js" "jsx"
                        "hy" "json" "jl" "ex" "exs" "eex" "ml" "mli" "pp" "dockerfile"
                        "vagrantfile" "j2" "jinja2" "tex" "racket" "rkt" "rktl" "rktd"
                        "scrbl" "scribble" "plt" "makefile" "elm" "xml" "xsl" "rb"
                        "scss" "lua" "lisp" "scm" "sql" "toml" "nim" "pl" "pm" "perl"
                        "vimrc" "tridactylrc" "vimperatorrc" "ideavimrc" "vrapperrc"
                        "cask" "r" "re" "rei" "bashrc" "zshrc" "inputrc" "editorconfig"
                        "gitconfig"))
          (treemacs-create-icon
           :icon (format "  %s\t"
                         (all-the-icons-octicon
                          "book"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("lrf" "lrx" "cbr" "cbz" "cb7" "cbt" "cba" "chm" "djvu"
                        "doc" "docx" "pdb" "pdb" "fb2" "xeb" "ceb" "inf" "azw"
                        "azw3" "kf8" "kfx" "lit" "prc" "mobi" "pkg" "opf" "txt"
                        "pdb" "ps" "rtf" "pdg" "xml" "tr2" "tr3" "oxps" "xps"))
          (treemacs-create-icon
           :icon (format "  %s\t" (all-the-icons-octicon
                                   "file-text"
                                   :v-adjust 0
                                   :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("md" "markdown" "rst" "log" "org" "txt"
                        "CONTRIBUTE" "LICENSE" "README" "CHANGELOG"))
          (treemacs-create-icon
           :icon (format "  %s\t" (all-the-icons-octicon
                                   "file-binary"
                                   :v-adjust 0
                                   :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("exe" "dll" "obj" "so" "o" "out"))
          (treemacs-create-icon
           :icon (format "  %s\t" (all-the-icons-octicon
                                   "file-pdf"
                                   :v-adjust 0
                                   :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("pdf"))
          (treemacs-create-icon
           :icon (format "  %s\t" (all-the-icons-octicon
                                   "file-zip"
                                   :v-adjust 0
                                   :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("zip" "7z" "tar" "gz" "rar" "tgz"))
          (treemacs-create-icon
           :icon (format "  %s\t" (all-the-icons-octicon
                                   "file-text"
                                   :v-adjust 0
                                   :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (fallback))))
      :init
      (defun aorst/treemacs-expand-all-projects (&optional _)
        "Expand all projects."
        (interactive)
        (save-excursion
          (treemacs--forget-last-highlight)
          (dolist (project (treemacs-workspace->projects (treemacs-current-workspace)))
            (-when-let (pos (treemacs-project->position project))
              (when (eq 'root-node-closed (treemacs-button-get pos :state))
                (goto-char pos)
                (treemacs--expand-root-node pos)))))
        (treemacs--maybe-recenter 'on-distance))
      (defun aorst/treemacs-variable-pitch-labels (&rest _)
        (dolist (face '(treemacs-file-face
                        treemacs-root-face
                        treemacs-tags-face
                        treemacs-directory-face
                        treemacs-directory-collapsed-face
                        treemacs-term-node-face
                        treemacs-help-title-face
                        treemacs-help-column-face
                        treemacs-git-added-face
                        treemacs-git-ignored-face
                        treemacs-git-renamed-face
                        treemacs-git-conflict-face
                        treemacs-git-modified-face
                        treemacs-git-unmodified-face
                        treemacs-git-untracked-face
                        treemacs-root-unreadable-face
                        treemacs-root-remote-face
                        treemacs-root-remote-unreadable-face
                        treemacs-root-remote-disconnected-face
                        treemacs-fringe-indicator-face
                        treemacs-on-failure-pulse-face
                        treemacs-on-success-pulse-face))
          (let ((faces (face-attribute face :inherit nil)))
            (set-face-attribute
             face nil :inherit
             `(variable-pitch ,@(delq 'unspecified (if (listp faces) faces (list faces))))))))
      (defun aorst/treemacs-after-init-setup ()
        "Set treemacs theme, open treemacs, and expand all projects."
        (treemacs-load-theme "Atom")
        (setq treemacs-collapse-dirs 0)
        (treemacs)
        (aorst/treemacs-expand-all-projects)
        (windmove-right))
      (defun aorst/after-treemacs-setup ()
        "Set treemacs buffer common settings."
        (setq tab-width 1
              mode-line-format nil
              line-spacing 5)
        (setq-local scroll-step 1)
        (setq-local scroll-conservatively 10000)
        (set-window-fringes nil 0 0 t)
        (aorst/treemacs-variable-pitch-labels))
      (defun aorst/treemacs-setup-fringes ()
        "Set treemacs buffer fringes."
        (set-window-fringes nil 0 0 t)
        (aorst/treemacs-variable-pitch-labels))
      (advice-add #'treemacs-select-window :after #'aorst/treemacs-setup-fringes)
      (defun aorst/treemacs-setup-title ()
        (let ((format '((:eval (concat
                                (make-string
                                 (let ((width (window-width)))
                                   (- (/ (if (= (% width 2) 0) width (1+ width)) 2) 5))
                                 ?\s)
                                "Treemacs")))))
          (if (version<= emacs-version "27")
              (setq header-line-format format)
            (setq tab-line-format format)))
        (let ((bg (face-attribute 'default :background))
              (fg (face-attribute 'default :foreground))
              (face (if (version<= emacs-version "27")
                        'header-line
                      'tab-line)))
          (face-remap-add-relative face
                                   :box (list :line-width 7 :color bg)
                                   :background bg :foreground fg :height 1.0)))))
#+end_src

This is my Treemacs theme that mimics Atom editor file tree:

** Minions
This  package  implements   a  menu  that  lists   all  enabled  minor
modes. Emacs mode  line can become pretty long, so  this can be handy,
and perhaps I don't need to use =:diminish= everywhere anymore.

#+begin_src emacs-lisp
  (use-package minions
    :commands minions-mode
    :init (minions-mode 1))
#+end_src

** Uniquify
This package makes files with  identical names more distinguishable by
adding directory name in the buffer name.

#+begin_src emacs-lisp
  (use-package uniquify
    :ensure nil
    :config (setq uniquify-buffer-name-style 'forward))
#+end_src

** Tabline
Starting  with Emacs  27  native tab  support is  present.  I want  to
customize tab appearance to match my theme.

#+begin_src emacs-lisp
  (unless (version< emacs-version "27")
    (use-package tab-line
      :ensure nil
      :hook (after-init . global-tab-line-mode)
      :config
      (defun tab-line-close-tab (&optional e)
        "Close the selected tab.
  If tab is presented in another window, close the tab by using `bury-buffer` function.
  If tab is uniq to all existing windows, kill the buffer with `kill-buffer` function.
  Lastly, if no tabs left in the window, it is deleted with `delete-window` function."
        (interactive "e")
        (let* ((posnp (event-start e))
               (window (posn-window posnp))
               (buffer (get-pos-property 1 'tab (car (posn-string posnp)))))
          (with-selected-window window
            (let ((tab-list (tab-line-tabs-window-buffers))
                  (buffer-list (flatten-list
                                (seq-reduce (lambda (list window)
                                              (select-window window t)
                                              (cons (tab-line-tabs-window-buffers) list))
                                            (window-list) nil))))
              (select-window window)
              (if (> (seq-count (lambda (b) (eq b buffer)) buffer-list) 1)
                  (progn
                    (if (eq buffer (current-buffer))
                        (bury-buffer)
                      (set-window-prev-buffers window (assq-delete-all buffer (window-prev-buffers)))
                      (set-window-next-buffers window (delq buffer (window-next-buffers))))
                    (unless (cdr tab-list)
                      (ignore-errors (delete-window window))))
                (and (kill-buffer buffer)
                     (unless (cdr tab-list)
                       (ignore-errors (delete-window window)))))))
          (force-mode-line-update)))
      (setq tab-line-new-tab-choice nil
            tab-line-close-button-show nil
            tab-line-new-button-show nil
            tab-line-separator nil
            tab-line-right-button (propertize (if (char-displayable-p ?▶) " ▶ " " > ")
                                              'keymap tab-line-right-map
                                              'mouse-face 'tab-line-highlight
                                              'help-echo "Click to scroll right")
            tab-line-left-button (propertize (if (char-displayable-p ?◀) " ◀ " " < ")
                                             'keymap tab-line-left-map
                                             'mouse-face 'tab-line-highlight
                                             'help-echo "Click to scroll left"))
      (let ((bg (if (facep 'solaire-default-face)
                    (face-attribute 'solaire-default-face :background)
                  (face-attribute 'default :background)))
            (fg (face-attribute 'default :foreground))
            (base (face-attribute 'mode-line :background))
            (box-width 8))
        (set-face-attribute 'tab-line nil :background base :foreground fg :height 1.0 :inherit nil)
        (set-face-attribute 'tab-line-tab nil :foreground fg :background bg :box (list :line-width box-width :color bg) :weight 'normal :inherit nil)
        (set-face-attribute 'tab-line-tab-inactive nil :foreground fg :background base :box (list :line-width box-width :color base) :weight 'normal :inherit nil)
        (set-face-attribute 'tab-line-tab-current nil :foreground fg :background bg :box (list :line-width box-width :color bg) :weight 'normal :inherit nil))
      (dolist (mode '(ediff-mode
                      process-menu-mode
                      term-mode
                      vterm-mode))
        (add-to-list 'tab-line-exclude-modes mode))))
#+end_src

** Line Numbers
*display-line-numbers* mode is built in and provides line numbers on the
left  side of  the window,  which doesn't  lag. I  don't like  that it
changes width, so let's make it grow only, and calculate maximum width
on file open:

#+begin_src emacs-lisp
  (use-package display-line-numbers
    :ensure nil
    :config
    (setq display-line-numbers-grow-only t
          display-line-numbers-width-start t))
#+end_src

* Languages
This section contains various  language specific settings and external
packages that provide language support.

** Org
Org  Mode is  a great  mode for  taking notes,  managing to-do  lists,
writing books, literate programming, and  many other things. I primary
use it for taking notes on different programming languages, and manage
my Emacs configuration with it.

#+begin_src emacs-lisp
  (use-package org
    :ensure nil
    :defines default-justification
    :hook ((org-mode . flyspell-mode)
           (org-mode . auto-fill-mode)
           (after-save . aorst/org-tangle-on-config-save)
           (org-babel-after-execute . aorst/org-update-inline-images)
           (org-mode . aorst/org-init-setup)
           (ediff-prepare-buffer . outline-show-all)
           ((org-capture-mode org-src-mode) . aorst/discard-history))
    :bind (("C-c a" . org-agenda)
           :map
           org-mode-map
           ("C-c l" . org-store-link))
    :config
    (use-package ox-latex
      :ensure nil)
    (use-package ox-hugo
      :after ox)
    (when (not (version<= org-version "9.1.9"))
      (use-package org-tempo
        :ensure nil))
    (setq org-startup-with-inline-images nil
          org-tags-column -100
          org-startup-folded 'content
          org-hide-emphasis-markers t
          org-adapt-indentation nil
          org-hide-leading-stars t
          org-highlight-latex-and-related '(latex)
          revert-without-query '(".*\.pdf")
          org-preview-latex-default-process 'dvisvgm
          org-src-fontify-natively t
          org-preview-latex-image-directory ".ltximg/"
          org-latex-listings 'minted
          org-latex-pdf-process '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
                                  "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
                                  "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")
          org-confirm-babel-evaluate nil
          org-imenu-depth 8
          org-log-done t
          org-agenda-files '("~/Tasks"))
    (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-+]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
    (defun aorst/org-tangle-on-config-save ()
      "Tangle source code blocks when configuration file is saved."
      (when (string= buffer-file-name (file-truename (concat user-emacs-directory "README.org")))
        (org-babel-tangle)))
    (defun aorst/org-update-inline-images ()
      "Update inline images in Org-mode."
      (interactive)
      (when org-inline-image-overlays
        (org-redisplay-inline-images)))
    (defun aorst/org-init-setup ()
      "Set buffer local values."
      (setq default-justification 'full))
    (defun aorst/discard-history ()
      "Discard undo history of org src and capture blocks."
      (setq buffer-undo-list nil)
      (set-buffer-modified-p nil))
    (defvar minted-cache-dir
      (file-name-as-directory
       (expand-file-name ".minted/\\jombname"
                         temporary-file-directory)))
    (add-to-list 'org-latex-packages-alist
                 `(,(concat "cachedir=" minted-cache-dir)
                   "minted" nil))
    (add-to-list 'org-latex-logfiles-extensions "tex")
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((gnuplot . t)
       (scheme . t)))
    (add-to-list 'org-latex-classes
                 '("article"
                   "\\documentclass{article}"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
    (defun aorst/org-update-latex-preview-background-color (&rest _)
      (setq-default
       org-format-latex-options
       (plist-put org-format-latex-options
                  :background
                  (face-attribute (or (cadr (assq 'default face-remapping-alist))
                                      'default)
                                  :background nil t))))
    (add-hook 'solaire-mode-hook #'aorst/org-update-latex-preview-background-color))
#+end_src

** Prog Mode
This isn't really a configuration of  Prog Mode itself, but some hooks
that change how  programming related modes behave. One  feature that I
think is really important, especially  when working with lisp code, is
ability  to see  matching bracket  when cursor  stands near  the other
bracket. So I enable it for every programming language.

#+begin_src emacs-lisp
    (use-package prog-mode
      :ensure nil
      :hook ((prog-mode . show-paren-mode)
             (prog-mode . display-line-numbers-mode)
             (prog-mode . hl-line-mode)))
#+end_src

** CC
These settings are for editing C source files.

#+begin_src emacs-lisp
  (use-package cc-mode
    :ensure nil
    :config (defun aorst/cc-mode-setup ()
              (c-set-offset 'case-label '+)
              (setq c-basic-offset 4
                    c-default-style "linux"
                    indent-tabs-mode t
                    comment-start "//"
                    comment-end ""
                    tab-width 4))
    :hook ((c-mode-common . aorst/cc-mode-setup)
           (c-mode-common . electric-pair-local-mode)))
#+end_src

** Markdown
Sometimes I need to edit Markdown documents, so this package is handy.
For markdown  mode I would like  to have automatic spell  checking and
filling. Basically  the same setup  as for Org  Mode.  And one  of the
features of Org mode is ability to edit source code blocks in separate
window  with  appropriate  major  mode.  This  can  be  achieved  with
=edit-indirect= package.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :config
    (defvar markdown-command "multimarkdown")
    (defun aorst/markdown-setup ()
      "Set buffer local variables."
      (setq fill-column 80
            default-justification 'left))
    :hook ((markdown-mode . flyspell-mode)
           (markdown-mode . auto-fill-mode)
           (markdown-mode . aorst/markdown-setup)))
#+end_src

** Rust
I'd like to  have Rust syntax highlighting and  some basic facilities,
since I'm  planning to write my  exercises in org mode.   Since I make
notes in Org-mode, and  I started to use it for Rust  too, I need some
settings for Rust mode.

#+begin_src emacs-lisp
  (use-package rust-mode
    :commands (rust-format-buffer)
    :hook (rust-mode . electric-pair-local-mode)
    :bind (:map
           rust-mode-map
           ("C-c C-f" . rust-format-buffer)))
#+end_src

This also means  that I could use something  to automatically complete
Rust  language facilities.   Rust ecosystem  provides two  options for
that:  [[https://github.com/racer-rust/emacs-racer][Racer]], and  [[https://github.com/rust-lang/rls][RLS]].   I'm planning  to use  Racer  when RLS  isn't
possible to use, like in Org Mode.

#+begin_src emacs-lisp
  (when (executable-find "racer")
    (use-package racer
      :hook (racer-mode . eldoc-mode)
      :init (defun org-babel-edit-prep:rust (&optional _babel-info)
              "Run racer mode for Org Babel."
              (racer-mode 1))))
#+end_src

There's also a package for [[https://github.com/kwrooijen/cargo.el][Cargo]] integration:

#+begin_src emacs-lisp
  (when (executable-find "cargo")
    (use-package cargo
      :hook ((rust-mode toml-mode) . cargo-minor-mode)))
#+end_src

** TOML
=toml-mode= helps  with highlighting of  TOML files, which Rust  uses to
configure project.

#+begin_src emacs-lisp
  (use-package toml-mode
    :bind (:map
           toml-mode-map
           ("C-c C-f" . aorst/indent-buffer)))
#+end_src

** Racket
Racket is nice LISP/Scheme language that I might to get into.

#+begin_src emacs-lisp
  (use-package racket-mode
    :mode ("\\.rkt\\'" . racket-mode)
    :hook (racket-repl-mode . electric-pair-local-mode)
    :bind (:map
           racket-mode-map
           ("C-c C-d" . racket-run-with-debugging)
           ("C-c C-f" . aorst/indent-buffer)
           (")" . self-insert-command)
           ("]" . self-insert-command)
           ("}" . self-insert-command))
    :config
    (set-face-attribute 'racket-debug-break-face nil :background (face-attribute 'error :foreground) :foreground (face-attribute 'default :background))
    (set-face-attribute 'racket-debug-result-face nil :foreground (face-attribute 'font-lock-comment-face :foreground) :box nil)
    (set-face-attribute 'racket-debug-locals-face nil :foreground (face-attribute 'font-lock-comment-face :foreground) :box nil)
    (set-face-attribute 'racket-selfeval-face nil :foreground (face-attribute 'default :foreground)))
#+end_src

** Cmake
A mode for editing cmake files.

#+begin_src emacs-lisp
  (use-package cmake-mode
    :bind (:map
           cmake-mode-map
           ("C-c C-f" . aorst/indent-buffer)))
#+end_src

** Emacs Lisp
I write some  Emacs Lisp and experience is already  quite good, I just
want to enable some helper modes here.

#+begin_src emacs-lisp
  (use-package elisp-mode
    :ensure nil
    :hook (emacs-lisp-mode . eldoc-mode)
    :bind (:map
           emacs-lisp-mode-map
           ("C-c C-f" . aorst/indent-buffer)))
#+end_src

** Yaml
Support for =.yaml= files.

#+begin_src emacs-lisp
  (use-package yaml-mode)
#+end_src

** Shell Script
Some configurations for shell script modes.

#+begin_src emacs-lisp
  (use-package sh-script
    :ensure nil
    :bind (:map
           sh-mode-map
           ("C-c C-f" . aorst/indent-buffer)))
#+end_src

** Perl
Perl related configurations.

#+begin_src emacs-lisp
  (use-package perl-mode
    :ensure nil
    :hook ((perl-mode . electric-pair-local-mode)
           (perl-mode . flymake-mode))
    :bind (:map
           perl-mode-map
           ("C-c C-f" . aorst/indent-buffer)))
#+end_src

** Clojure
Clojure is a Lisp dialect for JVM - Java Virtual Machine. It is one of
the few  modern and refreshing  languages, that bring  both innovation
and reliability.

#+begin_src emacs-lisp
  (use-package clojure-mode
    :bind (:map
           clojure-mode-map
           ("C-c C-f" . aorst/indent-buffer)))
#+end_src

Emacs  also has  a great  package called  Cider, which  is an  IDE for
Clojure and ClojureScript.

#+begin_src emacs-lisp
  (use-package cider
    :hook (((cider-repl-mode cider-mode) . cider-company-enable-fuzzy-completion))
    :custom-face
    (cider-error-highlight-face ((t (:inherit flymake-error))))
    (cider-fringe-face ((t (:inherit flymake-warning))))
    (cider-fragile-button-face ((t (:box (:line-width -1 :color nil :style nil)
                                         :inherit (font-lock-warning-face)))))
    (cider-deprecated-face ((t (:inherit smerge-upper))))
    (cider-instrumented-face ((t (:box (:line-width -1 :color "#ff6c6b" :style nil)))))
    :config
    (setq cider-repl-display-help-banner nil
          cider-repl-tab-command nil
          nrepl-hide-special-buffers t))
#+end_src

** Fennel
Fennel  is  a programming  language  a  lisp  dialect, that  is  being
compiled  to Lua,  which means  that it  can run  anywhere, where  Lua
can.   It   supports  compile-time   macro   system,   and  full   Lua
compatibility.

#+begin_src emacs-lisp
  (use-package fennel-mode
    :bind (:map
           fennel-mode-map
           ("C-c C-f" . aorst/indent-buffer)))
#+end_src

** Lua
I'm not  into Lua language  myself, but in  order to view  what [[*Fennel][Fennel]]
produces I need support for Lua.

#+begin_src emacs-lisp
  (use-package lua-mode
    :bind (:map
           lua-mode-map
           ("C-c C-f" . aorst/indent-buffer)))
#+end_src

* Tools
Additional  packages  that  change  how Emacs  works,  providing  more
comfortable user experience.

** Help
I want help  window to be selected automatically, so  I could close it
with =q= after I've finished reading.

#+begin_src emacs-lisp
  (use-package help
    :ensure nil
    :config (setq help-window-select t))
#+end_src

** Doc View
Default resolution is too low:

#+begin_src emacs-lisp
  (use-package doc-view
    :ensure nil
    :config (setq-default doc-view-resolution 192))
#+end_src

** vterm
This  package provides  a bridge  to =libvterm=  to display  terminal as
Emacs buffer. It works much better than =ansi-term=, though may be buggy
and requires compilation.

#+begin_src emacs-lisp
  (setq use-package-hook-name-suffix "-functions")
  (when (bound-and-true-p module-file-suffix)
    (use-package vterm
      :bind (("C-`" . aorst/vterm-toggle)
             ("C-t" . aorst/vterm-focus))
      :hook (vterm-exit . aorst/kill-vterm)
      :config
      (defun aorst/vterm-toggle (&optional arg)
        "Toggle `vterm' window on and off with the same command."
        (interactive "P")
        (let* ((directory (if default-directory
                              default-directory
                            (expand-file-name "~/")))
               (bufname "*vterm*")
               (window (get-buffer-window bufname)))
          (if window
              (ignore-errors (delete-window window))
            (if (window-dedicated-p)
                (let ((windows (seq-drop-while #'window-dedicated-p (window-list))))
                  (when (not (null windows))
                    (select-window (car windows)))))
            (let* ((win-side (if (symbolp arg)
                                 (cons (split-window-below) 'bot)
                               (cons (split-window-right) 'right)))
                   (window (car win-side))
                   (side (cdr win-side)))
              (select-window window)
              (cond ((get-buffer bufname)
                     (switch-to-buffer bufname))
                    (t (let ((default-directory directory))
                         (vterm bufname))))
              (when (bound-and-true-p global-tab-line-mode)
                (setq tab-line-format nil))
              (set-window-dedicated-p window t)
              (set-window-parameter window 'no-delete-other-windows t)
              (set-window-parameter window 'window-side side)
              (set-window-parameter window 'no-other-window t)))))
      (defun aorst/vterm-focus (&optional arg)
        "Focus `vterm' or open one if there's none."
        (interactive "P")
        (let ((window (get-buffer-window "*vterm*")))
          (if window
              (select-window window)
            (aorst/vterm-toggle arg))))
      (defun aorst/kill-vterm (buf &optional event)
        "Kill the `*vterm*' buffer after shell exits."
        (when buf (kill-buffer buf)))))
  (setq use-package-hook-name-suffix "-hook")
#+end_src

** EditorConfig
=.editorconfig=  file  provides a  nice  way  to synchronize  my  editor
configurations between projects and different editors.

#+begin_src emacs-lisp
  (use-package editorconfig
    :commands editorconfig-mode
    :config (editorconfig-mode 1))
#+end_src

** Flymake Mode
This mode allows checking syntax in  the buffer.  I was using [[https://www.flycheck.org/en/latest/][Flycheck]]
package  before,  but  I  don't   see  major  advantages  of  Flycheck
supporting 50  languages versus  4 in Flymake  [[https://www.flycheck.org/en/latest/user/flycheck-versus-flymake.html#supported-languages][(1)]], because  I'm using
language server protocol that integrates with Flymake, so as long as I
have  server for  a  language, I  have support  for  this language  in
Flymake.

Also let's  use right  fringe for indication  of errors  and warnings,
since it's never used, and left fringe is occupied by diff status.

#+begin_src emacs-lisp
  (use-package flymake
    :ensure nil
    :config
    (setq flymake-fringe-indicator-position 'right-fringe)
    (remove-hook 'flymake-diagnostic-functions 'flymake-proc-legacy-flymake))
#+end_src

** Hydra
This is something like ability to create mappings that sit in it's own
mode, like different user modes in Kakoune. It allows me to press some
shortcut  and be  locked  in a  mode-like state  where  keys that  are
related  to  this  prefix  shortcut  are behaving  in  terms  of  this
shortcut.

This  package will  be used  in many  other package  configurations to
provide sane keybindings.

#+begin_src emacs-lisp
  (use-package hydra)
#+end_src

** Geiser
Since I mostly use Emacs for studying LISP, and I'm reading SICP which
uses Scheme as main LISP flavor for explanations and exercises, I need
a tool  to run Scheme,  and Geiser seems  like the most  viable option
here, since it also provides completion for it.

#+begin_src emacs-lisp
  (use-package geiser
    :hook (scheme-mode . geiser-mode)
    :config (setq geiser-active-implementations '(guile)
                  geiser-default-implementation 'guile))
#+end_src

** Parinfer
Now that's a quality package. It makes writing LISP so easy, that I've
never thought it could be.

I'm using a  fork of this package,  located at [[https://github.com/jvshahid/parinfer-mode/tree/master][jvshahid/parinfer-mode]],
and it explicitly requires these two dependencies:

#+begin_src emacs-lisp
  (use-package paredit)
  (use-package selected)
#+end_src

The package itself is located under my local =Git= directory, that I use
to host various projects that I've cloned with =git=.

#+begin_src emacs-lisp
  (use-package parinfer-smart
    :load-path "~/Git/parinfer-mode"
    :hook ((clojure-mode
            emacs-lisp-mode
            common-lisp-mode
            scheme-mode
            lisp-mode
            racket-mode
            fennel-mode) . parinfer-mode)
    :custom-face (parinfer--error-face ((t (:inherit (flymake-error)))))
    :config
    (setq parinfer-extensions '(defaults
                                 pretty-parens
                                 smart-tab
                                 smart-yank)))
#+end_src

Big thanks to [[https://github.com/shaunlebron][@shaunlebron]] for creating original [[https://github.com/shaunlebron/parinfer][Parinfer]].

** Flx
Flex matching for Emacs.

#+begin_src emacs-lisp
  (use-package flx)
#+end_src

** Ivy and Counsel
Ivy  is a  narrowing  framework  like Helm,  but  much  lighter in  my
experience.  It  integrates with  Counsel that handles  minibuffer, so
let's install  it too.  I'm  using [[https://github.com/sharkdp/fd][fd]] as  a great replacement  for GNU
Find. It's fast and it takes =.gitignore= into account.  Let's assign it
to =find-program=.   /I guess there will  be no problems/ /if  a well known
tool  is replaced  by something/  /that  is completely  different, am  I
right?/ Well I hope  that it is used by =grep.el= only  which I don't use
anyways.   Counsel  has  nice   =counsel-file-fump=  command  that  uses
=find-program= variable, so it will be more performant with =fd=.

#+begin_src emacs-lisp
  (use-package ivy
    :commands ivy-mode
    :hook ((minibuffer-setup-hook . aorst/minibuffer-defer-garbage-collection)
           (minibuffer-exit-hook . aorst/minibuffer-restore-garbage-collection))
    :bind (("C-x b" . ivy-switch-buffer))
    :config
    (use-package counsel
      :commands (counsel-M-x
                 counsel-find-file
                 counsel-file-jump
                 counsel-recentf
                 counsel-rg
                 counsel-describe-function
                 counsel-describe-variable
                 counsel-find-library)
      :config
      (when (executable-find "fd")
        (define-advice counsel-file-jump (:around (foo &optional initial-input initial-directory))
          (let ((find-program "fd")
                (counsel-file-jump-args (split-string "-L --type f --hidden")))
            (funcall foo))))
      (when (executable-find "rg")
        (setq counsel-rg-base-command
              "rg -S --no-heading --hidden --line-number --color never %s .")
        (setenv "FZF_DEFAULT_COMMAND"
                "rg --files --hidden --follow --no-ignore --no-messages --glob '!.git/*' --glob '!.svn/*'"))
      :bind (("M-x" . counsel-M-x)
             ("C-x C-f" . counsel-find-file)
             ("C-x f" . counsel-file-jump)
             ("C-x C-r" . counsel-recentf)
             ("C-x d" . counsel-dired)
             ("C-h f" . counsel-describe-function)
             ("C-h C-f" . counsel-describe-face)
             ("C-h v" . counsel-describe-variable)
             ("C-h l" . counsel-find-library)
             ("C-x C-b" . counsel-switch-buffer)))
    (setq ivy-re-builders-alist '((t . ivy--regex-fuzzy))
          ivy-count-format ""
          ivy-ignore-buffers '("\\` " "\\`\\*")
          ivy-display-style nil
          ivy-minibuffer-faces nil
          ivy-minibuffer-faces '(default default default default)
          ivy-use-virtual-buffers t
          enable-recursive-minibuffers t)
    :init
    (defun aorst/minibuffer-defer-garbage-collection ()
      "Defer garbage collection for minibuffer"
      (setq gc-cons-threshold most-positive-fixnum))
    (defun aorst/minibuffer-restore-garbage-collection ()
      "Resotre garbage collection settings."
      (run-at-time
       1 nil (lambda () (setq gc-cons-threshold aorst--gc-cons-threshold))))
    (ivy-mode 1))
#+end_src

** Ivy Posframe
This package displays =ivy= in separate frame on top of Emacs.

#+begin_src emacs-lisp
  (use-package ivy-posframe
    :after ivy
    :config
    (defvar aorst--ivy-posframe-top-padding 42
      "additional padding between top of the frame and posframe.")
    (defun aorst/posframe-position (str)
      (ivy-posframe--display str #'aorst/posframe-under-tabs-center))
    (defun aorst/posframe-under-tabs-center (info)
      "Function that sets center position for ivy posframe."
      (cons (/ (- (plist-get info :parent-frame-width)
                  (plist-get info :posframe-width))
               2)
            0))
    (setq ivy-posframe-display-functions-alist '((t . aorst/posframe-position))
          ivy-posframe-height-alist '((t . 16))
          ivy-posframe-parameters '((internal-border-width . 6))
          ivy-posframe-width 78)
    (set-face-attribute 'ivy-posframe nil :background (face-attribute 'mode-line :background))
    (ivy-posframe-mode +1))

#+end_src

** Company
Complete anything framework. Nothing much to say. Does it's job.

#+begin_src emacs-lisp
  (use-package company
    :commands global-company-mode
    :bind (:map
           company-active-map
           ("TAB" . company-complete-common-or-cycle)
           ("<tab>" . company-complete-common-or-cycle)
           ("<S-Tab>" . company-select-previous)
           ("<backtab>" . company-select-previous)
           ("C-n" . company-select-next)
           ("C-p" . company-select-previous))
    :hook (after-init . global-company-mode)
    :config
    (setq company-require-match 'never
          company-minimum-prefix-length 3
          company-tooltip-align-annotations t
          company-frontends '(company-pseudo-tooltip-unless-just-one-frontend
                              company-preview-frontend
                              company-echo-metadata-frontend)
          company-backends '(company-capf company-files)))
#+end_src

This package also optionally requires these extra dependencies:

- =company-posframe= - provides posframe frontend for company.

#+begin_src emacs-lisp
  (use-package company-posframe
    :after company
    :config
    (setq company-posframe-quickhelp-show-header nil
          company-posframe-show-indicator nil
          company-posframe-show-metadata nil)
    (setq-default company-posframe-quickhelp-show-params
                  (list :poshandler #'company-posframe-quickhelp-right-poshandler
                        :internal-border-width 1
                        :timeout 60
                        :internal-border-color (face-attribute 'mode-line-inactive :background)
                        :no-properties nil
                        :poshandler nil))
    (company-posframe-mode))
#+end_src

** Undo Tree
This is more familiar  undo mode. It adds =C-/= mapping  to undo and =C-?=
mapping to redo.

#+begin_src emacs-lisp
  (use-package undo-tree
    :commands global-undo-tree-mode
    :init (global-undo-tree-mode 1))
#+end_src

** Yasnippet
Another very handy package, that helps insert templates of code. Now I
really need to write some snippets to use. Also has nice collection as
a separate package

#+begin_src emacs-lisp
  (use-package yasnippet
    :commands yas-reload-all
    :hook ((rust-mode
            c-mode-common
            racket-mode). yas-minor-mode)
    :config
    (add-to-list 'yas-key-syntaxes 'yas-shortest-key-until-whitespace)
    (yas-reload-all))
#+end_src

** Magit
Emacs interface to Git.  I've heard that it has many nice features, so
I want to try it out.

#+begin_src emacs-lisp
  (use-package magit
    :hook ((git-commit-mode . flyspell-mode))
    :bind (("<f12>" . magit-status))
    :config (setq magit-ediff-dwim-show-on-hunks t))
#+end_src

** Ediff
This is a built  in mode for diffing files in  Emacs. Previously I was
using  [[https://github.com/justbur/emacs-vdiff][Vdiff]] but  I have  to say  that I've  used it  so rarely,  so I
decided to avoid extra dependency and configure Ediff.

#+begin_src emacs-lisp
  (use-package ediff
    :ensure nil
    :hook ((ediff-before-setup . aorst/store-pre-ediff-winconfig)
           (ediff-quit . aorst/restore-pre-ediff-winconfig)
           (ediff-keymap-setup . aorst/ediff-setup-keys))
    :config
    (advice-add 'ediff-window-display-p :override #'ignore)
    (setq ediff-split-window-function 'split-window-horizontally)
    :init
    (defvar aorst--ediff-last-windows nil
      "Stores window configuration before `ediff' was invoked.")
    (defun aorst/store-pre-ediff-winconfig ()
      (setq aorst--ediff-last-windows (current-window-configuration)))
    (defun aorst/restore-pre-ediff-winconfig ()
      (set-window-configuration aorst--ediff-last-windows))
    (defun aorst/ediff-copy-both-to-C ()
      (interactive)
      (ediff-copy-diff ediff-current-difference nil 'C nil
                       (concat
                        (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
                        (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))
    (defun aorst/ediff-setup-keys ()
      (define-key ediff-mode-map "d" #'aorst/ediff-copy-both-to-C)))
#+end_src

** Multiple Cursors
This  package provides  multiple cursors  functionality to  Emacs.  It
isn't much like Kakoune's multiple selections, but anything will do. I
guess I'll figure out best mappings over time.

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :commands (mc/cycle-backward
               mc/cycle-forward)
    :bind (("S-<mouse-1>" . mc/add-cursor-on-click)
           ("C-c m" . hydrant/mc/body)
           :map
           mc/keymap
           ("<return>" . nil))
    :requires hydra
    :config
    (defhydra hydrant/mc (:hint nil :color pink)
      "
  ^Select^                 ^Discard^                     ^Edit^               ^Navigate^
  ^──────^─────────────────^───────^─────────────────────^────^───────────────^────────^──────────
  _M-s_: split lines       _M-SPC_: discard current      _&_: align           _(_: cycle backward
  _s_:   select regexp     _b_:     discard blank lines  _#_: insert numbers  _)_: cycle forward
  _n_:   select next       _d_:     remove duplicated    ^ ^                  ^ ^
  _p_:   select previous   _q_:     exit                 ^ ^                  ^ ^
  _C_:   select next line"
      ("M-s" mc/edit-ends-of-lines)
      ("s" mc/mark-all-in-region-regexp)
      ("n" mc/mark-next-like-this-word)
      ("p" mc/mark-previous-like-this-word)
      ("&" mc/vertical-align-with-space)
      ("(" mc/cycle-backward)
      (")" mc/cycle-forward)
      ("M-SPC" mc/remove-current-cursor)
      ("b" mc/remove-cursors-on-blank-lines)
      ("d" mc/remove-duplicated-cursors)
      ("C" mc/mark-next-lines)
      ("#" mc/insert-numbers)
      ("q" mc/remove-duplicated-cursors :exit t)))
  (use-package mc-extras)
#+end_src

** Iedit Mode
Another package  for multiple editing  purposes, that is  kinda faster
than multiple cursors,  but can edit only fixed width  regions of text
and  has less  abilities regarding  to commands.  Still pretty  usable
though, as multiple cursor some times looses cursors for some reason.

#+begin_src emacs-lisp
  (use-package iedit
    :bind (("M-n" . aorst/iedit-current-or-expand)
           ("C-c i" . aorst/iedit-hydrant))
    :init
    (setq iedit-toggle-key-default nil)
    (defun aorst/iedit-to-mc-hydrant ()
      "Calls `iedit-to-mc-mode' and opens hydra for multiple cursors."
      (interactive)
      (iedit-switch-to-mc-mode)
      (hydrant/mc/body))
    (defun aorst/iedit-current-or-expand (&optional arg)
      "Select only currnent occurrence with `iedit-mode'.  Expand to
    next occurrence if `iedit-mode' is already active."
      (interactive "P")
      (if (bound-and-true-p iedit-mode)
          (if (symbolp arg)
              (iedit-expand-down-to-occurrence)
            (iedit-expand-up-to-occurrence))
        (iedit-mode 1)))
    (defun aorst/iedit-hydrant ()
      "toggle iedit mode for item under point, and open `hydrant/iedit'."
      (interactive)
      (ignore-errors
        (iedit-mode 1)
        (hydrant/iedit/body)))
    (defhydra hydrant/iedit (:hint nil :color pink)
      "
  ^Select^                  ^Discard^                  ^Edit^               ^Navigate^
  ^──────^──────────────────^───────^──────────────────^────^───────────────^────────^─────────────
  _n_: next occurrence      _M-SPC_: toggle selection  _u_: uppercase       _(_: previous selection
  _p_: previous occurrence  _q_:     exit              _d_: downcase        _)_: next selection
  ^ ^                       _m_:     convert to mc     _#_: insert numbers"
      ("n" iedit-expand-down-to-occurrence)
      ("m" aorst/iedit-to-mc-hydrant :exit t)
      ("p" iedit-expand-up-to-occurrence)
      ("u" iedit-upcase-occurrences)
      ("d" iedit-downcase-occurrences)
      ("#" iedit-number-occurrences)
      ("(" iedit-prev-occurrence)
      (")" iedit-next-occurrence)
      ("M-SPC" iedit-toggle-selection)
      ("q" ignore :exit t)))
#+end_src

** LSP Mode
Another LSP client for Emacs.

#+begin_src emacs-lisp
  (when (or (executable-find "clangd")
            (executable-find "rls"))
    (use-package lsp-mode
      :hook ((rust-mode c-mode c++-mode) . lsp)
      :init (setq lsp-keymap-prefix "C-c l")
      :config
      (setq lsp-rust-clippy-preference "on"
            lsp-prefer-capf t
            lsp-enable-symbol-highlighting nil)
      (use-package lsp-ui
        :commands lsp-ui-mode
        :bind (:map
               lsp-ui-mode-map
               ("M-." . lsp-ui-peek-find-definitions)
               ("M-/" . lsp-ui-peek-find-references))
        :config
        (setq lsp-ui-doc-border (face-attribute 'mode-line-inactive :background)
              lsp-ui-sideline-enable nil
              lsp-ui-imenu-enable nil
              lsp-ui-doc-delay 0.7) ;; higher than eldoc delay
        (when (fboundp 'aorst/escape)
          (define-advice lsp-ui-doc--make-request (:around (foo))
            (unless (eq this-command 'aorst/escape)
              (funcall foo))))
        (lsp-ui-mode))))
#+end_src

** Project
In  order to  migrate  the problem  with  [[Eglot]] I've  used  to have  a
function wrapper over projectile, described in this [[https://github.com/joaotavora/eglot/issues/129#issuecomment-444130367][issue comment]]. But
I do not want to use projectile for that, since Emacs already features
=project.el= and Eglot uses it.  So first we need a list of project root
markers,  that   will  hold   file  names  which   we  will   look  up
recursively. we need  a function that will test  current directory for
several conditions,  like does it have  any of project markers,  is it
root directory, and  if everything fails, it will go  up one directory
and repeat.

#+begin_src emacs-lisp
  (use-package project
    :ensure nil
    :bind (("C-c p f" . project-find-file)
           ("C-c p r" . project-find-regexp))
    :config
    (defvar project-root-markers '("Cargo.toml" "compile_commands.json" "compile_flags.txt")
      "Files or directories that indicate the root of a project.")
    (defun aorst/project-find-root (path)
      "Recursive search in PATH for root markers."
      (let* ((this-dir (file-name-as-directory (file-truename path)))
             (parent-dir (expand-file-name (concat this-dir "../")))
             (system-root-dir (expand-file-name "/")))
        (cond
         ((aorst/project-root-p this-dir) (cons 'transient this-dir))
         ((equal system-root-dir this-dir) nil)
         (t (aorst/project-find-root parent-dir)))))
    (defun aorst/project-root-p (path)
      "Check if current PATH has any of project root markers."
      (let ((results (mapcar (lambda (marker)
                               (file-exists-p (concat path marker)))
                             project-root-markers)))
        (eval `(or ,@ results))))
    (add-to-list 'project-find-functions #'aorst/project-find-root))
#+end_src

** Clang Format
A package to format C code with Clang Format.

#+begin_src emacs-lisp
  (use-package clang-format
    :after cc-mode
    :bind (:map c-mode-base-map
                ("C-c C-f" . clang-format-buffer)
                ("C-c C-S-f" . clang-format-region)))
#+end_src

** Server
I'm using  =server-start= command not because  I do not want  to load my
Emacs every time, but because I  want to have single instance of Emacs
running at a time, so all files that I open from GUI will be opened in
existing Emacs. If no Emacs exist, it should start one, start a server
and open a file.

#+begin_src emacs-lisp
  (use-package server
    :ensure nil
    :config
    (unless (server-running-p)
      (server-start)))
#+end_src

To fully achieve this behavior one needs a =.desktop= file to exist that
will decide which kind of Emacs to call: =emacs= or =emacsclient=:

#+begin_src conf-xdefaults :tangle ~/.local/share/applications/emacs.desktop :mkdirp yes :results silent
  [Desktop Entry]
  Name=Emacs
  GenericName=Text Editor
  Comment=Edit text
  MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
  Exec=sh -c "emacsclient -a emacs -n \"\$@\" || emacs" dummy %F
  Icon=emacs
  Type=Application
  Terminal=false
  Categories=Development;TextEditor;Utility;
  StartupWMClass=Emacs
#+end_src

This code above automatically creates user local =emacs.desktop= file in
=~/.local/share/applications= that will:

- call =emacs= if no arguments provided, or
- call =emacsclient  -a emacs= with  arguments. =emacsclient= will  try to
  connect to  a server,  and if  there's none, it  will fire  up =emacs=
  which will create server, and opening new files will be done in this
  instance of =emacs=.

** COMMENT Eldoc Box
This nice  package displays eldoc in  child frame that can  hover near
the cursor. It is really good for modes that support eldoc and removes
distraction  that happen  every  time when  your  buffer size  changes
because eldoc message appeared at the bottom. This package is affected
by [[https://gitlab.gnome.org/GNOME/mutter/issues/840][this bug]] in Gnome Shell.

#+begin_src emacs-lisp
  (use-package eldoc-box
    :hook ((eldoc-mode . aorst/eldoc-box-enable)
           (eldoc-box-buffer . aorst/eldoc-box-buffer-setup))
    :config
    (setq x-wait-for-event-timeout 0
          eldoc-idle-delay 0.5
          eldoc-box-max-pixel-width 640
          eldoc-box-max-pixel-height 480)
    (set-face-attribute 'eldoc-box-border nil :background (face-attribute 'mode-line-inactive :background))
    :init
    (defun aorst/eldoc-box-enable ()
      "Helper function that enables `eldoc-box-hover-at-point-mode' for real buffers only."
      (interactive)
      (when (aorst/real-buffer-p)
        (eldoc-box-hover-at-point-mode)))
    (defun aorst/eldoc-box-buffer-setup ()
      (unless word-wrap (toggle-word-wrap))))
#+end_src

** Hideshow
This built in mode provides code folding.

#+begin_src emacs-lisp
  (use-package hideshow
    :ensure nil
    :requires transient
    :hook (prog-mode . hs-minor-mode)
    :bind (:map prog-mode-map
                ("<f6>" . aorst/hideshow-menu))
    :config
    (define-transient-command aorst/hideshow-menu ()
      "Hideshow commands."
      [:description
       "Hide"
       ("ha" "all" hs-hide-all)
       ("hb" "block" hs-hide-block)]
      [:description
       "Show"
       ("sa" "all" hs-show-all)
       ("sb" "block" hs-show-block)]
      (interactive)
      (when (bound-and-true-p hs-minor-mode)
        (transient-setup 'aorst/hideshow-menu nil nil))))
#+end_src

** Desktop
This is  really nice feature  that allows me  to save my  workspace on
disk and  do not restore  all buffers and  windows every time  I start
Emacs. It adds some time to the startup though.

#+begin_src emacs-lisp
  (when window-system
    (use-package desktop
      :ensure nil
      :hook ((after-init . aorst/desktop-restore)
             (desktop-after-read . aorst/desktop-remove))
      :init
      (setq desktop-path '("~/.dotfiles/.config/emacs/")
            desktop-dirname "~/.dotfiles/.config/emacs/"
            desktop-base-file-name "emacs-desktop"
            desktop-save t
            desktop-load-locked-desktop t)
      (defun aorst/desktop-remove ()
        "Remove current desktop, but save `desktop-dirname'."
        (let ((desktop desktop-dirname))
          (desktop-remove)
          (setq desktop-dirname desktop)))
      (defun aorst/saved-desktop-p ()
        "Check if desktop exists."
        (file-exists-p (concat desktop-dirname "/" desktop-base-file-name)))
      (defun aorst/desktop-restore ()
        "Restore a saved emacs session."
        (interactive)
        (desktop-save-mode t)
        (if (aorst/saved-desktop-p)
            (desktop-read)
          (message "No desktop found.")))))
#+end_src

I wonder if  it could store unsaved buffers so  all my changes persist
through sessions.

** COMMENT God Mode
God mode is more  like a mode in a sense of a  mode from modal editor,
such as Vim, or Kakoune. It  makes all shortcuts you press be prefixed
by =Ctrl= key by default. Not sure if I'm going to use it much, though.

#+begin_src emacs-lisp
  (use-package god-mode
    :hook ((god-mode-enabled
            god-mode-disabled) . aorst/god-mode-change-cursor-shape)
    :bind (("<escape>" . god-local-mode)
           :map
           god-local-mode-map
           ("i" . god-local-mode)
           ("<backspace>" . ignore)
           ("<escape>" . ignore)
           ("<return>" . ignore)
           ("j" . ignore)
           ("m" . ignore))
    :config
    (advice-add 'aorst/newline-below :after #'(lambda () (god-local-mode -1)))
    (advice-add 'aorst/newline-above :after #'(lambda () (god-local-mode -1)))
    (dolist (mode '(treemacs-mode
                    vterm-mode
                    cider-repl-mode
                    racket-repl-mode
                    geiser-repl-mode))
      (add-to-list 'god-exempt-major-modes mode))
    :init
    (defun aorst/god-mode-change-cursor-shape ()
      (when window-system
        (setq cursor-type (if god-local-mode 'box 'bar))))
    (god-mode))
#+end_src

This package provides more comfortable usage for =isearch= in God mode:

#+begin_src emacs-lisp
  (use-package god-mode-isearch
    :ensure nil
    :bind (:map
           isearch-mode-map
           ("<escape>" . god-mode-isearch-activate)
           :map
           god-mode-isearch-map
           ("<escape>" . god-mode-isearch-disable)))
#+end_src

** Edit Indirect
This  package  makes it  possible  to  edit  Markdown code  blocks  in
separate buffers.

#+begin_src emacs-lisp
  (use-package edit-indirect
    :hook ((edit-indirect-after-creation . aorst/real-buffer-setup)
           (edit-indirect-after-creation . aorst/edit-indirect-header-line-setup))
    :bind (:map
           edit-indirect-mode-map
           ("C-c C-c" . edit-indirect-commit)
           ("C-c C-k" . edit-indirect-abort)
           ("C-c '" . nil))
    :init
    (defun aorst/edit-indirect-header-line-setup ()
      (setq-local
       header-line-format
       (substitute-command-keys
        "\\<edit-indirect-mode-map>Edit, then exit with `\\[edit-indirect-commit]' or abort with `\\[edit-indirect-abort]'"))))
#+end_src

** Separedit
This package  provides a way to  edit comments in sources  as separate
buffers with another major mode, like Markdown.

#+begin_src emacs-lisp
  (use-package separedit
    :hook (separedit-buffer-creation . aorst/separedit-header-line-setup)
    :bind (:map
           prog-mode-map
           ("C-c '" . separedit)
           :map edit-indirect-mode-map
           ("C-c '" . separedit))
    :init
    (setq separedit-default-mode 'markdown-mode)
    (defun aorst/separedit-header-line-setup ()
      (setq-local
       header-line-format
       (substitute-command-keys
        "Edit, then exit with `\\[separedit-commit]' or abort with `\\[edit-indirect-abort]'"))))
#+end_src

* Postscript
This Emacs Configuration features  various cool E-Lisp hacks somewhere
that I've  found over the  Internet, and I  try to keep  references to
original places, so reader could refer to those, because I alter these
pieces of code for my personal needs and thus it may not be compatible
with  other people  tastes,  and  because I  want  to credit  original
author.

If you  find any issue with  my config feel  free to [[https://github.com/andreyorst/dotfiles/issues/new][file an  issue]] or
contact me via email: [[mailto:andreyorst@gmail.com][andreyorst@gmail.com]].

And as a final step of a proper init file:

#+begin_src emacs-lisp
  (provide 'init)
  ;;; init.el ends here
#+end_src

Thanks for reading!
