#+title: Emacs configuration with Org Mode
#+author: Andrey Orst
#+email: andreyorst@gmail.com
#+setupfile: ./.org-defaults.org
#+startup: noinlineimages
#+property: header-args :tangle "./init.el" :results silent

#+attr_org: :width 1366
[[file:.screenshot.png]]

* About this document
This is my Emacs configuration file written as Org document.
I do all edits here, then /compile/ it to initialization files.
Emacs is complex tool, and by having my configuration in Org Mode, I can separate it to different sections.
I also can add short description for packages, and toggle configuration parts on and off with ease.

I try to maintain my Emacs configuration simple, fast, and small, keeping as much of vanilla Emacs as I can.
But I'm a sane person so some aspects, which in my opinion are actually insane, are changed.

This file is self contained Emacs configuration, thus it is the only file you need to bootstrap Emacs 26 and higher.
It will configure itself, although you need [[https://orgmode.org/][Org Mode]] for this to work.
Org mode comes inbuilt with all current versions of Emacs.

If you've downloaded this file, put it to =~/.config/emacs= or =~/.emacs.d/=, and run =org-babel-tangle=, then restart Emacs.
This function exports all code blocks accordingly to =header-args= property at the top of this document, and under some headings.
As a result =init.el= and =early-init.el= files are created, located in the same directory as this file, which should be in =user-emacs-directory=.
This is why I'm using tangle approach, instead of =org-babel-load-file=, as there's no way to provide =early-init= this way.
After first tangle, every time this file is saved it gets re-tangled automatically.
And, because both =init.el= and =early-init.el= are in read only mode, only this file needs to be edited.

Since I'm trying to follow Emacs conventions, good Emacs Lisp file starts with commentary:

#+begin_src emacs-lisp
  ;;; init.el --- Emacs main configuration file -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-
  ;;;
  ;;; Commentary:
  ;;; Emacs config by Andrey Orst.
  ;;; This file was automatically generated by `org-babel-tangle'.
  ;;; Do not change this file.  Main config is located in README.org at `user-emacs-directory'
  ;;;
  ;;; Code:
#+end_src

At this point configurations will be split in different sections grouped by something common to them all.

* Initial Setup
Emacs starts fast, but as amount of packages grows it gets slower.
The init time is important because I like to close Emacs when I'm not using it.
I'm not closing and opening it for every file, or like every 15 minutes, but still.
The faster it starts - the better for me.

** =early-init.el=
:properties:
:header-args+: :tangle "./early-init.el"
:end:
These settings are going into  different init file: =earli-init.el=.
We are going to use some speedup tricks from [[https://github.com/hlissner/doom-emacs][doom-emacs]] here.
But before that, let's add top comment as we did for =init.el=:

#+begin_src emacs-lisp
  ;;; early-init.el --- early configurations -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-
  ;;;
  ;;; Commentary:
  ;;; Emacs confi by Andrey Orst.
  ;;; This file was automatically generated by `org-babel-tangle'.
  ;;; Do not change this file.  Main config is located in README.org at `user-emacs-directory'
  ;;;
  ;;; Code:
#+end_src

*** Garbage Collection
The main problem with Emacs startup is garbage collection system.
It is invoked so many times on startup that it causes quite big impact on startup time.
We're talking /seconds/.
One can raise limit when to trigger garbage collection, but this will end up in unpleasant editing experience.
So I'm declaring these variables to store default values for the GC, to restore them after initialization is finished:

#+begin_src emacs-lisp
  (defvar aorst--gc-cons-threshold gc-cons-threshold)
  (defvar aorst--gc-cons-percentage gc-cons-percentage)
  (defvar aorst--file-name-handler-alist file-name-handler-alist)
#+end_src

Now we can tweak CG.
We need to raise threshold to prevent it running.
And as well we tweak some other slow bits:

#+begin_src emacs-lisp
  (setq-default gc-cons-threshold 402653184
                gc-cons-percentage 0.6
                inhibit-compacting-font-caches t
                message-log-max 16384
                file-name-handler-alist nil)
#+end_src

Then we need a hook that restores initial values once initialization done:

#+begin_src emacs-lisp
  (add-hook 'after-init-hook
            (lambda ()
              (setq gc-cons-threshold aorst--gc-cons-threshold
                    gc-cons-percentage aorst--gc-cons-percentage
                    file-name-handler-alist aorst--file-name-handler-alist)))
#+end_src

*** Native Compiled Emacs Lisp
There's a very interesting project that I'm currently using, called [[http://akrl.sdf.org/gccemacs.html][gccemacs]].
It provides a way to compile Emacs Lisp into native code, thus making Emacs much more robust and snappy.
In order to compile everything that Emacs loads asynchronously we can set this variable to =true=.

#+begin_src emacs-lisp
  (defvar comp-deferred-compilation)
  (setq comp-deferred-compilation t)
#+end_src

This way I can compile Emacs from source as I usually do, and then continue using it as normal.
And Emacs will do it's native compilation in background for every loaded package.
That's amazing!

*** User Interface
Prevent the glimpse of unstyled Emacs by disabling these UI elements early.

#+begin_src emacs-lisp
  (setq initial-frame-alist '((width . 170)
                              (height . 56)
                              (tool-bar-lines . 0)
                              (bottom-divider-width . 0)
                              (right-divider-width . 1))
        default-frame-alist initial-frame-alist)
#+end_src

Resizing frame is also expensive so we inhibit it.
Setting =x-gtk-resize-child-frames= variable to =resize-mode= fixes the [[https://gitlab.gnome.org/GNOME/mutter/-/issues/840][issue]] with child frames not being resized correctly under GNOME Shell.

#+begin_src emacs-lisp
  (setq frame-inhibit-implied-resize t
        x-gtk-resize-child-frames 'resize-mode)
#+end_src

Also, let's disable these arrows that are displayed for truncated lines in fringes.
Usually I can see that line is truncated, and with horizontal scrolling these arrows are a bit annoying.

#+begin_src emacs-lisp
  (setq-default fringe-indicator-alist
                (assq-delete-all 'truncation fringe-indicator-alist))
#+end_src

*** =straight.el=
Straight is an alternative way to manage package installations.
It is a purely functional package manager.
It installs packages from Git repositories listed on ELPA and MELPA, or from Git URL.
First, we have to bootstrap it:

#+begin_src emacs-lisp
  (defvar straight-process-buffer)
  (setq-default straight-process-buffer " *straight-process*")
  (defvar bootstrap-version)
  (defvar straight-repository-branch)
  (setq straight-repository-branch "develop")
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

Now we can install =use-package= with it:

#+begin_src emacs-lisp
  (straight-use-package 'use-package)
  (defvar straight-use-package-by-default)
  (setq straight-use-package-by-default t)
#+end_src

*** early =package.el= settings
=package.el= initialization is expensive so we disable it at startup:

#+begin_src emacs-lisp
  (setq package-enable-at-startup nil)
#+end_src

*** =(provide 'early-init)=
This concludes the =early-init.el= file.

#+begin_src emacs-lisp
  (provide 'early-init)
  ;;; early-init.el ends here
#+end_src

*** Loading =early-init.el= in Emacs 26 and earlier
:properties:
:header-args+: :tangle "./init.el"
:end:
Before Emacs 27 there were no such thing as =eraly-init.el=.
So if I will use older Emacs with this configuration it will miss settings that are done there.
This code manually loads this file in such case:

#+begin_src emacs-lisp
  (unless (featurep 'early-init)
    (load (expand-file-name "early-init" user-emacs-directory)))
#+end_src

We do it as early as possible, as it is important to load these settings before all settings specified in =init.el=.

** COMMENT =package.el=
#+begin_comment
If you're reading this, then you're probably reading the source of this file and not rendered version.
This section is commented because I'm no longer using =package.el= as my package manager.
Instead I'm using =straight.el=, which provides more facilities, and does not have most of =package.el= problems.
However, I still keep this configuration, since I might switch back, and I would not want to configure everything again.
If you want to use =package.el= instead, make sure to uncomment this heading, and comment =straight.el= heading.
You will also need to replace =:straight= with equivalent variant of =:ensure= keywords in =use-package= declarations.
However not all of the packages may be available on ELPA or MELPA.
#+end_comment

To obtain plugins we need =package.el= package.
Although this is builtin and convenient, it's also slow and messy.
Instead of using =package= directly we will use =use-package= to manage package configurations.

MELPA is a package repository, that I use to get packages.
Since all packages that I need can be obtained from there, I did not bothered with different methods of installation.

#+begin_src emacs-lisp
  (defvar package-archives)
  (setq package-archives
        '(("gnu" . "https://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")))
#+end_src

Emacs 26.2 had a bug with downloading from ELPA.
Here's a workaround, although it is dangerous to use this, as it is pretty insecure.
So please upgrade to more recent Emacs, in case you're still using Emacs 26.2.

#+begin_src emacs-lisp
  (when (version= emacs-version "26.2")
    (defvar gnutls-algorithm-priority)
    (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3"))
#+end_src

Found this trick [[https://genehack.blog/2020/04/a-bit-of-emacs-advice/][here]], and adopted the idea.
But instead of using Boolean, I've decided to track time since last package refresh, and use customize to store it.
This variable is going to hold either =nil= or date-time string.

#+begin_src emacs-lisp
  (defcustom package-last-refresh-date nil
    "Date and time when package lists have been refreshed.

  This variable is then used to check whether
  `package-refresh-contents' call is needed before calling
  `package-install'. Value of this varialbe is updated when
  `package-refresh-contents' is called.

  See `package-refresh-hour-threshold' for amount of time needed to
  trigger refresh."
    :type 'string
    :group 'package)
#+end_src

And we need a variable that holds amount of hours that will trigger the refresh:

#+begin_src emacs-lisp
  (defcustom package-automatic-refresh-threshold 24
    "Amount of hours since last `package-refresh-contents' call
  needed to trigger automatic refresh before calling `package-install'."
    :type 'number
    :group 'package)
#+end_src

This advice first checks if our date-time string exists, and then checks if there's more than 24 hours passed since last check.

#+begin_src emacs-lisp
  (define-advice package-install (:before (&rest _) aorst:package-install)
    (let ((seconds-per-hour 3600))
      (when (or (null package-last-refresh-date)
                (> (/ (float-time
                       (time-subtract (date-to-time (format-time-string "%Y-%m-%dT%H:%M"))
                                      (date-to-time package-last-refresh-date)))
                      seconds-per-hour)
                   package-automatic-refresh-threshold))
        (package-refresh-contents))))
#+end_src

Now all packages that use =package-install= should periodically refresh package contents.
In order to update time we also have to advice =package-refresh-contents=:

#+begin_src emacs-lisp
  (define-advice package-refresh-contents (:after (&rest _) aorst:package-refresh-contents)
    (customize-save-variable 'package-last-refresh-date (format-time-string "%Y-%m-%dT%H:%M")))
#+end_src

This way if I refresh packages from package menu, or manually or via that =package-install= advice =package-last-refresh-date= will be updated and persistently saved via =custom=.

Last thing we need to do is to install =use-package=:

#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (defvar use-package-always-ensure)
  (setq use-package-always-ensure t)
#+end_src

** =use-package=
I use =use-package= to install, load and configure my packages.
I find this way very consistent and easy to understand, and maintain.
At this point =use-package= should be already installed by either =package.el= or =straight.el=, depending on what is enabled above.
Only thing left to do is to require =use-package= itself:

#+begin_src emacs-lisp
  (require 'use-package)
#+end_src

* Defaults
Emacs is old.
I understand that back then it could be appropriate decisions, but as of today they are completely obliterated by the passage of time.

** User Credentials
Let's set full name and e-mail address in case I would send e-mail from Emacs, or some modes can use those settings, like Org Mode:

#+begin_src emacs-lisp
  (use-package startup
    :no-require t
    :straight nil
    :custom
    (user-mail-address "andreyorst@gmail.com")
    (user-full-name "Andrey Orst"))
#+end_src

** Bell
I'm not trying to insult on anyone, but usage of the bell is just insane.
It's not 1980's, computers have their own speakers and rich displays, why would anyone want to use builtin speaker?
Why everyone should know when I'm mistaken?
Disable bell.

#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
#+end_src

** Backups
I don't know who decided that having backups all over the place is good idea, but I don't think alike.
Instead let's put backup files in default cache directory:

#+begin_src emacs-lisp
  (use-package files
    :straight nil
    :custom
    (backup-by-copying t)
    (create-lockfiles nil)
    (backup-directory-alist '(("." . "~/.cache/emacs-backups")))
    (auto-save-file-name-transforms '((".*" "~/.cache/emacs-backups/" t))))
#+end_src

** Yes or No
For some reason in some situations Emacs asks for typing =yes= or =no= explicitly, instead of accepting =y= or =n=.
This can be fixed with this.

#+begin_src emacs-lisp
  (use-package subr
    :no-require t
    :straight nil
    :init
    (fset 'yes-or-no-p 'y-or-n-p))
#+end_src

** Echo Keystrokes
Emacs displays pressed key after some time but it's too fast for me, because I use Emacs on the phone too, and the keyboard is a bit small for lightning fast typing.

#+begin_src emacs-lisp
  (add-hook 'after-init-hook (lambda () (setq echo-keystrokes 5)))
#+end_src

** Mouse and Scrolling
I don't want menus on shift clicks.
I also don't like how Emacs handles scrolling, in particular how it speeds it up and automatically.
Changing =mouse-highlight= to =nil= value disables highlighting of hovered item when the point moves which is kinda convenient when working with =flycheck=.
If by chance I would need to use Emacs in terminal, I'd like to keep mouse working.

#+begin_src emacs-lisp
  (use-package mwheel
    :straight nil
    :demand
    :bind (("S-<down-mouse-1>" . nil)
           ("S-<mouse-3>" . nil)
           ("<mouse-4>" . mwheel-scroll)
           ("<mouse-5>" . mwheel-scroll))
    :custom
    (mouse-wheel-flip-direction t)
    (mouse-wheel-tilt-scroll t)
    (mouse-wheel-progressive-speed nil)
    :config
    (global-set-key (kbd "<mouse-3>") menu-bar-edit-menu)
    (defun aorst/truncated-lines-p ()
      "Non-nil if any line is longer than `window-width' + `window-hscroll'.
  Returns t if any line exceeds right border of the window.  Used
  for stopping scrolling scroll from going beyond longest line.
  Based on `so-long-detected-long-line-p'."
      (save-excursion
        (goto-char (point-min))
        (let* ((window-width
                ;; this computes a more accurate width rather than `window-width', and respects
                ;; `text-scale-mode' font width.
                (/ (window-body-width nil t) (window-font-width)))
               (hscroll-offset
                ;; `window-hscroll' returns columns that are not affected by `text-scale-mode'.
                ;; Because of that we have to recompute correct `window-hscroll' by multiplying
                ;; it with a non-scaled value, and divide with scaled width value, and round it
                ;; to upper boundary.  Since there's no way to get unscaled value, we have to
                ;; get width of a face that is not scaled by `text-scale-mode', such as
                ;; `window-divider' face.
                (ceiling (/ (* (window-hscroll) (window-font-width nil 'window-divider))
                            (float (window-font-width)))))
               (line-number-width
                ;; compensate line numbers width
                (if (bound-and-true-p display-line-numbers-mode)
                    (- display-line-numbers-width)
                  0))
               (threshold (+ window-width hscroll-offset line-number-width -4)))
          (catch 'excessive
             (while (not (eobp))
                 (setq start (point))
                 (save-restriction
                     (narrow-to-region start (min (+ start 1 threshold)
                                                  (point-max)))
                     (forward-line 1))
                 (unless (or (bolp)
                             (and (eobp) (<= (- (point) start)
                                             threshold)))
                     (throw 'excessive t)))))))
    (define-advice scroll-left (:around (foo &optional arg set-minimum) aorst:scroll-left)
      (when (and (aorst/truncated-lines-p)
                 (not (memq major-mode '(vterm-mode term-mode))))
        (funcall foo arg set-minimum)))
    (setq-default auto-window-vscroll nil
                  mouse-highlight nil
                  hscroll-step 1
                  hscroll-margin 1
                  scroll-margin 1
                  scroll-step 10)
    (unless (display-graphic-p)
      (xterm-mouse-mode t)))
#+end_src

** Tab character
Another default setting that I kinda dislike.
Not that I'm a fan of spaces over tabs - tabs have their use and spaces do to, but I find that there are much more modes or even languages that expect spaces, and not tabs.
For the record, I need tab characters only when I work with C/C++ code and Makefile rules, and pretty much everything else uses spaces.

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

** Custom File and Disabled Commands
I would like to stop custom from inserting code into my configuration files, so lets move it to separate file.

#+begin_src emacs-lisp
  (use-package cus-edit
    :straight nil
    :custom (custom-file (expand-file-name "custom.el" user-emacs-directory))
    :init (load custom-file :noerror))
#+end_src

I also don't like that Emacs has disabled commands, and enabling them modifies my =init.el= that I don't modify myself.
Let's put those commands to =disabled.el= file instead:

#+begin_src emacs-lisp
  (defvar aorst--disabled-commands (expand-file-name "disabled.el" user-emacs-directory)
    "File to store disabled commands, that were enabled permamently.")

  (define-advice enable-command (:around (foo command) aorst:put-in-custom-file)
    (let ((user-init-file aorst--disabled-commands))
      (funcall foo command)))

  (load aorst--disabled-commands :noerror)
#+end_src

** Custom variables
This section lists some custom variables that I use to toggle some parts of my configuration.
This is rather an experiment, that allows my changing configuration without commenting out headings in this file.
And it allows making machine local setups, since I don't include =custom.el= as a part of Emacs configuration in the repository.
For now I'm unsure if I'll take this approach or not.

#+begin_src emacs-lisp
  (defgroup aorst ()
    "Various customization options that alter Emacs configuration."
    :tag "Andrey Orst customization options")
#+end_src

** History
Another feature I want is history between sessions. I'm not sure why it isn't default.

#+begin_src emacs-lisp
  (use-package savehist
    :straight nil
    :config (savehist-mode 1))
#+end_src

** Keyboard Layout
I use two keyboard layouts: =qwerty= and =йцукен=, therefore I need a way to switch between those.
But there's a problem - such chords as =C-x= which will become a =C-ч= if I select Cyrillic layout in the OS.
Luckily for me, Emacs provides a method to switch layouts within Emacs with =C-\=, so all common shortcuts will still work fine.

#+begin_src emacs-lisp
  (use-package mule-cmds
    :no-require t
    :straight nil
    :custom
    (default-input-method 'russian-computer))
#+end_src

I'm not using =russian-jcuken= here because this layout has inverted number-line, so to access numbers I need to use Shift key.
=russian-computer= doesn't have this problem.

** UTF8
Let's use =UTF8= if we can:

#+begin_src emacs-lisp
  (prefer-coding-system 'utf-8)
  (when (display-graphic-p)
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src

** Default Major Mode
I would like =*scratch*= buffer to use =fundamental= mode, so fully empty Emacs session loads faster.
Since it's no longer Emacs Lisp interaction buffer, let's also remove initial message:

#+begin_src emacs-lisp
  (use-package startup
    :no-require t
    :straight nil
    :custom
    (initial-major-mode 'fundamental-mode)
    (initial-scratch-message ""))
#+end_src

** Selection
It is convenient to delete selection by typing:

#+begin_src emacs-lisp
  (use-package delsel
    :straight nil
    :init
    (delete-selection-mode t))
#+end_src

** Default Bindings and More
Configurations for inbuilt =simple.el= module.
By default Emacs uses =kill-region= command on =C-w= shortcut, and changes region case with =C-x C-l= and =C-x C-u= shortcuts.
I find this counter intuitive, and actually had a lot of problems with the latter one, because Org mode has a similar shortcut =C-x C-l=, and I sometimes used the wrong one resulting in lower-casing a lot of text, and often noticing it only much later.
GNU Readline uses =C-w= to kill word backwards.
Other software uses this shortcut to kill window.
I prefer Readline approach, and I think it also maps well to case changing functions.
Also I've missed =o= and =O= commands from Kakoune.
With =newline-below= and =newline-above= it is now possible to have same shortcuts in Emacs.

Emacs has nice function, =zap-up-to-char= but for some reason it's not bound to any key.
I find it more usable than =zap-to-char= so let's swap those here.

Also, I don't want my files to contain trailing whitespace, so =before-save-hook= hook will get rid of those automatically for me.

#+begin_src emacs-lisp
  (use-package simple
    :straight nil
    :bind (("C-w" . aorst/kill-region-or-word)
           ("C-x C-l" . aorst/downcase-region-or-word)
           ("C-x C-u" . aorst/upcase-region-or-word)
           ("C-x C-x" . aorst/exchange-point-and-mark)
           ("C-o" . aorst/newline-below)
           ("C-S-o" . aorst/newline-above)
           ("M-z" . zap-up-to-char)
           ("C-x k" . kill-this-buffer)
           ("M-S-z" . zap-to-char)
           ("<kp-begin>" . ignore)
           ("<kp-5>" . ignore))
    :hook ((before-save . delete-trailing-whitespace)
           (overwrite-mode . aorst/overwrite-set-cursor-shape))
    :custom
    (yank-excluded-properties t "Disable all text properties when yanking.")
    (blink-matching-delay 0)
    (blink-matching-paren 1)
    :init
    (defun aorst/kill-region-or-word (arg)
      (interactive "*p")
      (if (and transient-mark-mode
               mark-active)
          (kill-region (region-beginning) (region-end))
        (backward-kill-word arg)))
    (defun aorst/downcase-region-or-word (arg)
      (interactive "*p")
      (if (and transient-mark-mode
               mark-active)
          (downcase-region (region-beginning) (region-end))
        (downcase-word (- arg))))
    (defun aorst/upcase-region-or-word (arg)
      (interactive "*p")
      (if (and transient-mark-mode
               mark-active)
          (upcase-region (region-beginning) (region-end))
        (upcase-word (- arg))))
    (defun aorst/exchange-point-and-mark (arg)
     (interactive "*p")
     (when (and transient-mark-mode
                mark-active)
       (exchange-point-and-mark)))
    (defun aorst/newline-below ()
      (interactive)
      (end-of-line)
      (newline-and-indent))
    (defun aorst/newline-above ()
      (interactive)
      (back-to-indentation)
      (newline-and-indent)
      (forward-line -1)
      (indent-according-to-mode))
    (defun aorst/overwrite-set-cursor-shape ()
      (when (display-graphic-p)
        (setq cursor-type (if overwrite-mode 'box 'bar)))))
#+end_src

** Line truncation
Let's disable line wrapping by default, unless I need it:

#+begin_src emacs-lisp
  (setq-default truncate-lines t)
#+end_src

** Minibuffer
Disabling clicks in minibuffer, because opening =*Messages*= buffer by clicking anywhere on the minibuffer is just plain stupid.

#+begin_src emacs-lisp
  (use-package minibuffer
    :straight nil
    :bind (:map minibuffer-inactive-mode-map
           ("<mouse-1>" . ignore)))
#+end_src

** =^L=
…also known as [[https://en.wikipedia.org/wiki/Page_break#Form_feed][form feed character]].
Emacs often uses it to mark sections in files, and in buffers like =*Help*=.
I don't quite enjoy seeing =^L= everywhere, so let's fix this:

#+begin_src emacs-lisp
  (defun aorst/formfeed-line ()
    "Display the formfeed ^L char as comment or as continuous line."
    (unless buffer-display-table
      (setq buffer-display-table (make-display-table)))
    (aset buffer-display-table ?\^L
          (vconcat (make-list (or fill-column 70)
                              (make-glyph-code
                               (string-to-char (or comment-start "─"))
                               'font-lock-comment-face)))))
#+end_src

This function will replace =^L= with a string of =fill-column= width out of =comment-start= character (=;= in Emacs Lisp) or of =─= char.
Let's enable it in modes where it is fequently used.

#+begin_src emacs-lisp
  (dolist (mode-hook '(emacs-lisp-mode-hook
                       help-mode-hook
                       fennel-mode-hook
                       org-mode-hook))
    (add-hook mode-hook 'aorst/formfeed-line))
#+end_src

* Functions
This section describes functions I have defined for use inside configurations of various packages, that are general enough to be placed in particular package configuration.
For example when function is shared between configurations and some configuration may not be loaded.

I prefix my functions with =aorst/= and variables with =aorst--= to make those easier to browse with =ivy= and to explicitly define that the function is not a part of a particular package.

** =real-buffer-p=
This function decides if buffer should be considered a "real" buffer.
Real buffer concept is introduced [[*Solaire Mode][Solaire Mode]] but is actually useful in several other places.
However, wheres Solaire Mode decided if buffer is real by checking if this is a file visiting buffer, I instead decide which buffers are not real, and everything else as real buffers.
This is due to the fact of how I stylize [[*Tabline][Tabline]] package from Emacs 27, and it looks nice when buffers that have tabs are real buffers.

#+begin_src emacs-lisp
  (defun aorst/real-buffer-p (&optional buffer)
    "Determines whether BUFFER is real."
    (not (or (string-match-p
              (regexp-opt '("*Treemacs"
                            "*vterm*"
                            " *Minibuf"
                            " *Echo Area"
                            "*Process List*"
                            "*Ediff"
                            " *LV*"
                            "*Ilist*"))
              (buffer-name buffer))
             (minibufferp))))
#+end_src

** =escape=
One thing that bothered me is that =C-g= is universal way to cancel things in Emacs, but you have to be in exact window to cancel action.
This function intelligently tries to cancel regardless of active window:

#+begin_src emacs-lisp
  (defun aorst/escape ()
    "Quit in current context.

  When there is an active minibuffer and we are not inside it close
  it.  When we are inside the minibuffer use the regular
  `minibuffer-keyboard-quit' which quits any active region before
  exiting.  When there is no minibuffer `keyboard-quit' unless we
  are defining or executing a macro."
    (interactive)
    (cond ((active-minibuffer-window)
           (if (minibufferp)
               (minibuffer-keyboard-quit)
             (abort-recursive-edit)))
          ((bound-and-true-p iedit-mode)
           (iedit-quit))
          (t
           (unless (or defining-kbd-macro
                       executing-kbd-macro)
             (keyboard-quit)))))
  (global-set-key [remap keyboard-quit] #'aorst/escape)
#+end_src

** =font-installed-p=
This function checks if font is available on the system.

#+begin_src emacs-lisp
  (defun aorst/font-installed-p (font-name)
    "Check if font with FONT-NAME is available."
    (find-font (font-spec :name font-name)))
#+end_src

** =indent-buffer=
This function is kinda a way to indent a buffer by using language indentation rules provided by current mode.
If there's a tool that can properly format buffer it should be used instead of this function.

#+begin_src emacs-lisp
  (defun aorst/indent-buffer ()
    "Indent whole buffer."
    (interactive)
    (save-excursion
      (save-restriction
        (indent-region (point-min) (point-max)))))

  (global-set-key (kbd "C-c C-M-f") #'aorst/indent-buffer)
#+end_src

** =split-paragraph-into-lines=
This function helps me follow one sentence per line style of editing.
I can write text as normal, fill it if I feel like it, and then reformat it with a single keybinding.

#+begin_src emacs-lisp
  (defun aorst/split-pararagraph-into-lines ()
    "Split current paragraph into lines with one sentence each."
    (interactive)
    (save-excursion
      (let ((fill-column (point-max)))
        (fill-paragraph))
      (let ((auto-fill-p auto-fill-function)
            (end (progn (end-of-line) (backward-sentence) (point))))
        (back-to-indentation)
        (unless (= (point) end)
          (auto-fill-mode -1)
          (while (< (point) end)
            (forward-sentence)
            (delete-horizontal-space)
            (newline-and-indent))
          (deactivate-mark)
          (when auto-fill-p
            (auto-fill-mode t))
          (when (looking-at "^$")
            (backward-delete-char 1))))))
#+end_src

** =create-accent-face=
Creates a slight variation of a face, by blending =ref-face= background color with foreground color.
It is used to create refine faces for diffs, which is the only purpose I've wrote this function for.
It depends on DOOM's =doom-blend= function, and if it is not available, it fallbacks to =inverse-video= method, which is used by default for refine face anyways.

#+begin_src emacs-lisp
  (defun aorst/create-accent-face (face ref-face)
    "Set FACE background to accent color by blending REF-FACE foreground and background.
  Depends on `doom-blend'."
    (let ((fg (face-attribute ref-face :foreground))
          (bg (face-attribute ref-face :background)))
      (if (and (stringp fg)
               (stringp bg)
               (fboundp #'doom-blend))
          (set-face-attribute face nil
                              :foreground fg
                              :weight 'bold
                              :background (doom-blend bg fg 0.8)
                              :inherit nil
                              :extend t
                              :inverse-video nil)
        (set-face-attribute face nil
                            :foreground nil
                            :background nil
                            :weight 'bold
                            :inherit ref-face
                            :extend t
                            :inverse-video t))))
#+end_src

** =doto=
A macro from Clojure.
Creates an object, and puts as a first argument to forms.
Very useful with =make-sparse-keymap=.

#+begin_src emacs-lisp
  (defmacro doto (x &rest forms)
    "Evaluates x then calls all of the functions with the value of
  x supplied at the front of the given arguments.  The forms are
  evaluated in order.  Returns x."
    (declare (indent defun))
    (let ((gx (gensym)))
      `(let ((,gx ,x))
         ,@(mapcar (lambda (f)
                     (if (listp f)
                         `(,(car f) ,gx ,@(cdr f))
                       `(,f ,gx)))
                   forms)
         ,gx)))
#+end_src

* User Interface
Packages that affect user interface.

** Splash Screen
Emacs displays splash screen once started with no files.
I don't need it, so let's disable it.

#+begin_src emacs-lisp
  (use-package startup
    :no-require t
    :straight nil
    :custom
    (inhibit-splash-screen t))
#+end_src

** Menu bar
I'm fine with menu bar in graphical environment, even though I rarely use it.
It keeps things organized in trees so when I work with new package it's quite handy to discover features.
However in terminal Emacs it is completely useless, so we disable it.

#+begin_src emacs-lisp
  (use-package menu-bar
    :straight nil
    :config
    (when (not (display-graphic-p))
      (menu-bar-mode -1)))
#+end_src

** Line height
When =text-scale-mode= is active it's hard to tell what line height actually is.
This variable helps calulating that reliably.

#+begin_src emacs-lisp
  (defvar aorst--line-pixel-height (line-pixel-height)
    "Line height in pixels.
  Used in various places to avoid getting wrong line height when
  `text-scale-mode' is active.")
#+end_src

** Menus and Tooltips
I don't need all these tooltips, menus and scroll bars.
Emacs enables all of those by default, so let's disable them as early as possible:

#+begin_src emacs-lisp
  (when window-system
    (setq-default x-gtk-use-system-tooltips nil)
    (setq-default tooltip-x-offset 0)
    (setq-default tooltip-y-offset aorst--line-pixel-height)
    (setq-default tooltip-frame-parameters
                  `((name . "tooltip")
                    (internal-border-width . ,(/ aorst--line-pixel-height 2))
                    (border-width . 1)
                    (no-special-glyphs . t)))
    (scroll-bar-mode -1)
    (tool-bar-mode -1))
#+end_src

** Cursor Type
Also let's use bar cursor when in window system, which is visible only
in active window:

#+begin_src emacs-lisp
  (when window-system
    (setq-default cursor-type 'bar
                  cursor-in-non-selected-windows nil))
#+end_src

** Font
Currently I'm using [[https://www.jetbrains.com/lp/mono/][JetBrains Mono]] font, that has nice support for ligatures, and overall looks great.
I'm also a big fan of [[https://github.com/source-foundry/Hack][Hack]] font.
It has nice support of languages and styles like *bold*, /italics/ for not only Latin languages.
If neither =JetBrainsMono=, nor =Hack= are not found, we try =Source Code Pro= as a fallback option.

#+begin_src emacs-lisp
  (cond ((aorst/font-installed-p "JetBrainsMono")
         (set-face-attribute 'default nil :font "JetBrainsMono 10"))
        ((aorst/font-installed-p "Hack")
         (set-face-attribute 'default nil :font "Hack 10"))
        ((aorst/font-installed-p "Source Code Pro")
         (set-face-attribute 'default nil :font "Source Code Pro 10")))
#+end_src

For variable pitched fonts I would like to use DejaVu fonts if available:

#+begin_src emacs-lisp
  (when (aorst/font-installed-p "DejaVu Sans")
    (set-face-attribute 'variable-pitch nil :font "DejaVu Sans 10"))
#+end_src

*** Ligatures
With the inclusion of [[https://github.com/harfbuzz/harfbuzz][HarfBuzz]] support into Emacs 27+, it is now possible to use =auto-composition-mode= to add ligatures.
What's especially cool, is that we can specify which ligatures we want, by defining regular expressions:

#+begin_src emacs-lisp
  (use-package ligature
    :when (aorst/font-installed-p "JetBrainsMono")
    :straight (:host github
               :repo "mickeynp/ligature.el")
    :config
    (ligature-set-ligatures
     '(prog-mode cider-repl-mode inferior-lisp-mode)
     '("--" "---" "==" "===" "!=" "!==" "=!=" "=:=" "=/=" "<=" ">="
       "&&" "&&&" "&=" "++" "+++" ";;" "!!" "??" "?:" "?." "?="
       "<:" ":<" ":>" ">:" "<>" "<<<" ">>>" "<<" ">>" "||" "-|" "_|_"
       "|-" "||-" "|=" "||=" "##" "###" "####" "#{" "#[" "]#" "#(" "#?"
       "#_" "#_(" "#:" "#!" "#=" "^=" "<$>" "<$" "$>" "<+>" "<+" "+>"
       "<*>" "<*" "*>" "</" "</>" "/>" "<!--" "<#--" "-->" "->" "->>"
       "<<-" "<-" "<=<" "=<<" "<<=" "<==" "<=>" "<==>" "==>" "=>" "=>>"
       ">=>" ">>=" ">>-" ">-" ">--" "-<" "-<<" ">->" "<-<" "<-|" "<=|"
       "|=>" "|->" "<->" "<~~" "<~" "<~>" "~~" "~~>" "~>" "~-" "-~" "~@"
       "[||]" "|]" "[|" "|}" "{|" "[<" ">]" "|>" "<|" "||>" "<||" "|||>"
       "<|||" "<|>" "..." ".." ".=" ".-" "..<" ".?" "::" ":::" ":=" "::="
       ":?" ":?>" "//" "///" "/=" "//=" "/==" "@_" "__"))
    (global-ligature-mode t))
#+end_src

** Icons
=all-the-icons= package provides nice icons for Emacs via custom fonts.

#+begin_src emacs-lisp
  (use-package all-the-icons
    :config
    (when (and (not (aorst/font-installed-p "all-the-icons"))
               (window-system))
      (all-the-icons-install-fonts t)))
#+end_src

I don't use this package directly yet, but some other packages do, like Treemacs.

** Solaire Mode
This package helps distinguish buffers that have file opened and buffers that are for utilities like file browser.
Also it has cool name!
=\[T]/=

I really want Solaire to treat =*scratch*= buffer as real.
For that I need to define my own function that will decide if buffer is real or not.
Now we can set up Solaire Mode and assign =aorst/real-buffer-p= to =solaire-mode-real-buffer-fn=.

#+begin_src emacs-lisp
  (use-package solaire-mode
    :straight (:host github
               :repo "hlissner/emacs-solaire-mode")
    :commands (solaire-global-mode
               solaire-mode-swap-bg
               turn-on-solaire-mode
               solaire-mode-in-minibuffer
               solaire-mode-reset)
    :hook (((after-revert
             change-major-mode
             org-src-mode)
            . turn-on-solaire-mode)
           (snippet-mode . solaire-mode))
    :custom
    (solaire-mode-real-buffer-fn #'aorst/real-buffer-p)
    :config
    (solaire-global-mode 1)
    (defun aorst/create-image-with-background-color (args)
      "Specify background color of inline image by modifing ARGS."
      (apply (lambda (file type data-p &rest props)
               (append (list file type data-p)
                       (list :background (face-attribute
                                          (let ((face (cadr (assq 'default face-remapping-alist))))
                                            (if (facep face) face 'default))
                                          :background nil t))
                       props))
             args))
    (advice-add 'create-image :filter-args #'aorst/create-image-with-background-color)
    (defvar aorst--solaire-swap-bg-hook nil
      "Run hooks after solaire swaps backgrounds.")
    (defun aorst/run-solaire-swap-hooks ()
      "Run `aorst--solaire-swap-hook'."
      (run-hooks 'aorst--solaire-swap-bg-hook))
    (advice-add 'solaire-mode--swap-bg-faces-maybe :after #'aorst/run-solaire-swap-hooks))
#+end_src

** Theme
I'm using *doom-themes* package to make my Emacs look modern.
It is a theme collection, originally developed for [[https://github.com/hlissner/doom-emacs][DOOM Emacs]], and I find these themes actually great on its own.
And provided thems define colors for pretty much every popular Emacs package, which helps make Emacs look very consistent.

#+begin_src emacs-lisp
  (use-package doom-themes
    :custom
    (doom-themes-enable-bold t)
    (doom-themes-enable-italic t)
    :custom-face
    (shadow    ((t (:foreground "grey50"))))
    (highlight ((t (:foreground unspecified
                    :distant-foreground unspecified
                    :background unspecified))))
    (org-block-begin-line ((t (:slant unspecified
                               :background unspecified
                               :inherit org-block
                               :extend t))))
    (org-block ((t (:extend t))))
    (org-block-end-line   ((t (:inherit org-block-begin-line :extend t))))
    (secondary-selection  ((t (:foreground unspecified
                               :background unspecified
                               :inherit region
                               :extend t))))
    (org-level-2 ((t (:inherit outline-3))))
    (org-level-3 ((t (:inherit outline-4))))
    (org-level-4 ((t (:inherit outline-2))))
    (org-level-5 ((t (:inherit outline-1))))
    (org-level-6 ((t (:inherit outline-3))))
    (org-level-7 ((t (:inherit outline-4))))
    (org-level-8 ((t (:inherit outline-2))))
    (org-drawer ((t (:foreground nil :inherit font-lock-comment-face))))
    (font-lock-comment-face ((t (:background unspecified))))
    :config
    (if (eq 'dark (frame-parameter nil 'background-mode))
        (load-theme 'doom-spacegrey t)
      (load-theme 'doom-one-light t)))
#+end_src

The following code specifies hooks that will run via advice, which in turn runs after =load-theme= and =disable-theme= functions.
It is useful to update some faces that are out of scope of current theme or dynamically changed by me, therefore have to be recalculated.

#+begin_src emacs-lisp
  (defvar aorst--theme-change-hook nil
    "Hook run after a color theme is loaded using `load-theme'.")

  (define-advice load-theme (:after (&rest _) aorst:load-theme)
    (run-hooks 'aorst--theme-change-hook))
#+end_src

And can you please Emacs treat all themes as safe by default?
Yes, I understand that there's a possibility of malicious code to be stored inside theme, but the same can be said about any package.

#+begin_src emacs-lisp
  (setq-default custom-safe-themes t)
#+end_src

** Mode-line
Mode-line is displayed at the bottom of each buffer, and shows necessary information about buffer state.
There are several packages that can make your mode-line appear differently, but most will reuse mode-line settings.

#+begin_src emacs-lisp
  (setq-default column-number-mode t
                line-number-mode t
                size-indication-mode nil
                mode-line-position nil
                mode-line-percent-position nil
                mode-line-in-non-selected-windows nil)
#+end_src

Also, let's remove that bevel thing.

#+begin_src emacs-lisp
  (dolist (face '(mode-line mode-line-inactive))
    (set-face-attribute face nil
                        :box nil))
#+end_src

*** Mode-line functions
Most of these functions are based on what [[https://github.com/seagle0128/doom-modeline][DOOM Modeline]] does.
Although I want to use more compact mode-line, without many additional settings that DOOM Mode-line provides.

**** =mode-line-buffer-name=
Buffer name module for mode-line.
Returns buffer name or empty string if buffer is special and starts from space.

#+begin_src emacs-lisp
  (defvar-local modeline-project-cache nil)

  (defun aorst/mode-line-buffer-name ()
    (when-let ((name (buffer-file-name)))
      (concat
       "  "
       (if-let ((project (or modeline-project-cache (project-current))))
           (progn (setq-local modeline-project-cache project)
                  (string-trim-left (abbreviate-file-name name)
                                    (car (project-roots project))))
         (abbreviate-file-name name)))))
#+end_src

**** =mode-line-buffer-modified=
Modified state module for mode-line.

#+begin_src emacs-lisp
  (defun aorst/mode-line-buffer-modified ()
    (when (and buffer-file-name (buffer-modified-p))
      (concat
       "  "
       (propertize (if (char-displayable-p ?💾) "💾" "[*]"
                    'help-echo (concat (buffer-name) " has unsaved changes"))))))
#+end_src

**** =mode-line-line-column=
Line-column module for mode-line.

#+begin_src emacs-lisp
  (defun aorst/mode-line-line-column ()
    (concat
     "  "
     (propertize
      "%C:%l"
      'help-echo "goto line"
      'local-map (doto (make-sparse-keymap)
                   (define-key [mode-line mouse-1] #'goto-line)))))
#+end_src

**** =mode-line-line-encoding=
Line encoding module for mode-line.

#+begin_src emacs-lisp
  (defun aorst/mode-line-line-encoding ()
    (when-let ((eol (pcase (coding-system-eol-type buffer-file-coding-system)
                      (0 "LF")
                      (1 "CRLF")
                      (2 "CR")
                      (_ nil))))
      (concat
       "  "
       (propertize
        eol
        'help-echo (format "Line ending style: %s"
                           (pcase eol
                             ("LF" "Unix style LF")
                             ("CRLF" "DOS style CRLF")
                             ("CR" "Mac style CR")
                             (_ "Undecided")))
        'local-map (doto (make-sparse-keymap)
                     (define-key [mode-line mouse-1] 'mode-line-change-eol))))))
#+end_src

**** =mode-line-input-method=
Input method module for mode-line.

#+begin_src emacs-lisp
  (defun aorst/mode-line-input-method ()
    (when current-input-method
      (concat
       "  "
       (propertize
        current-input-method-title
        'help-echo (concat
                    "Current input method: "
                    current-input-method
                    "\nmouse-2: Disable input method\nmouse-3: Describe current input method")
        'local-map mode-line-input-method-map))))
#+end_src

**** =mode-line-buffer-encoding=
Buffer encoding module for mode-line.

#+begin_src emacs-lisp
  (defun aorst/mode-line-buffer-encoding ()
    (concat
     "  "
     (propertize
      (let ((sys (coding-system-plist buffer-file-coding-system)))
        (if (memq (plist-get sys :category)
                  '(coding-category-undecided coding-category-utf-8))
            "UTF-8"
          (upcase (symbol-name (plist-get sys :name)))))
      'help-echo 'mode-line-mule-info-help-echo
      'local-map mode-line-coding-system-map)))
#+end_src

**** =mode-line-indent-mode=
Indentation info module for mode-line.

#+begin_src emacs-lisp
  (defvar-local aorst--mode-line--current-major-mode nil
    "Holds current major mode.
  Used for quicker check if `aorst/mode-line-indent-mode' need to
  do any meaningful stuff.")

  (defvar-local aorst--mode-line--indent-var nil
    "Holds variable that is used for setting indent offset in current major mode.
  Used for both checking if we need to do meaningful work in
  `aorst/mode-line-indent-mode', and for getting updated value.")

  (defvar-local aorst--mode-line--indent-var-value nil
    "Holds indent offset value, that was gathered before.
  Used to check if we need to preform meaningful work in
  `aorst/mode-line-indent-mode'.")

  (defvar-local aorst--mode-line--indent-mode-string nil)

  (defun aorst/mode-line-indent-mode ()
    "Compute mode-line string with current indent mode.
  Does heavy work only if major-mode has changed since last call,
  or if current indent offset has changed since last call, or if
  there's no previous result of this function stored."
    (unless (and (eq major-mode aorst--mode-line--current-major-mode)
                 (eq aorst--mode-line--indent-var-value
                     (symbol-value aorst--mode-line--indent-var))
                 aorst--mode-line--indent-mode-string)
      (setq-local aorst--mode-line--current-major-mode major-mode)
      (setq-local aorst--mode-line--indent-var (aorst/mode-line--get-indent-var))
      (setq-local aorst--mode-line--indent-var-value (symbol-value aorst--mode-line--indent-var))
      (let ((indent-mode-str (concat (when (and (not indent-tabs-mode)
                                                aorst--mode-line--indent-var-value)
                                       (format "%d " aorst--mode-line--indent-var-value))
                                     (if indent-tabs-mode "Tabs" "Spaces"))))
        (setq-local aorst--mode-line--indent-mode-string
                    (concat
                     "  "
                     (propertize
                      indent-mode-str
                      'help-echo (concat "Indent mode: "
                                         indent-mode-str
                                         (when aorst--mode-line--indent-var
                                           (format "\nindent var: %S" aorst--mode-line--indent-var))
                                         "\nmouse-1: toggle indent-"
                                         (if indent-tabs-mode "spaces" "tabs")
                                         "-mode")
                      'local-map (doto (make-sparse-keymap)
                                   (define-key [mode-line mouse-1] 'aorst/toggle-indent-mode)))))))
    aorst--mode-line--indent-mode-string)

  (defun aorst/mode-line--get-indent-var ()
    "Get variable that holds indent offset for current major mode.
  Uses `editorconfig-indentation-alist' variable as a source for
  all relationshipts between major modes and their respective
  offset variables."
    (when (boundp 'editorconfig-indentation-alist)
      (car (assoc-default
            major-mode
            editorconfig-indentation-alist
            (lambda (car key)
              (provided-mode-derived-p key car))))))

  (defun aorst/toggle-indent-mode ()
    "Toggle `indent-tabs-mode' on and off."
    (interactive)
    (setq-local indent-tabs-mode (not indent-tabs-mode)))
#+end_src

**** =mode-line-mode-name=
Major mode module for mode-line

#+begin_src emacs-lisp
  (defvar-local aorst--mode-line--major-mode-string nil)

  (defun aorst/mode-line-mode-name ()
    (unless (and (eq aorst--mode-line--current-major-mode
                     major-mode)
                 aorst--mode-line--major-mode-string)
      (setq-local aorst--mode-line--major-mode-string
                  (concat
                   "  "
                   (propertize
                    (format-mode-line mode-name)
                    'help-echo (format "Major mode: %s" (format-mode-line mode-name))))))
    aorst--mode-line--major-mode-string)
#+end_src

**** =mode-line-git-branch=
Git branch module for mode-line.

#+begin_src emacs-lisp
  (defun aorst/mode-line-git-branch ()
    (when (and vc-mode buffer-file-name)
      (let* ((str (when vc-display-status
                    (substring
                     vc-mode
                     (+ (if (eq (vc-backend buffer-file-name) 'Hg) 2 3)
                        2)))))
        (when str
          (concat (if (char-displayable-p ?) "   " "  @") str)))))
#+end_src

**** =mode-line-readonly=
Read only state module for mode-line.

#+begin_src emacs-lisp
  (defun aorst/mode-line-readonly ()
    (when (and buffer-read-only
               (not (memq major-mode '(vterm-mode
                                       treemacs-mode
                                       xref--xref-buffer-mode
                                       magit-status-mode))))
      (concat
       "  "
       (propertize
        (if (char-displayable-p ?🔒) "🔒" "RO")
        'help-echo "Make file writable"
        'local-map (doto (make-sparse-keymap)
                     (define-key [mode-line mouse-1] 'mode-line-toggle-read-only))))))
#+end_src

**** =mode-line-flycheck=
Flycheck module for mode-line.

#+begin_src emacs-lisp
  (defun aorst/mode-line-flycheck ()
    (when (bound-and-true-p flycheck-mode)
      (concat
       "  "
       (pcase flycheck-last-status-change
         (`not-checked (propertize "-/-" 'help-echo "Flycheck: not checked"))
         (`no-checker (propertize "-" 'help-echo "Flycheck: no checker"))
         (`running (propertize "*/*" 'help-echo "Flycheck: checking"))
         (`errored (propertize "!" 'help-echo "Flycheck: error"))
         (`finished
          (let-alist (flycheck-count-errors flycheck-current-errors)
            (propertize (format "%s/%s" (or .error 0) (or .warning 0))
                        'help-echo (if (or .error .warning)
                                       (concat "Flycheck: "
                                               (when .error (format "%d errors%s" .error (if .warning ", " "")))
                                               (when .warning (format "%d warnings" .warning))
                                               "\nmouse-1: list errors")
                                     "Flycheck: no errors or warnings")
                        'local-map 'flycheck-error-list-mode-line-map)))
         (`interrupted (propertize "x" 'help-echo "Flycheck: interrupted"))
         (`suspicious (propertize "?" 'help-echo "Flycheck: suspicious"))))))
#+end_src

**** =mode-line-structural=
Support for various structural editing modes in mode-line.

#+begin_src emacs-lisp
  (defun aorst/mode-line-structural ()
    (when-let ((structural
                (cond ((bound-and-true-p parinfer-rust-mode)
                       (propertize (concat "Parinfer: " parinfer-rust--mode)
                                   'help-echo (concat "Parinfer " parinfer-rust--mode
                                                      " mode is enabled for current buffer\nmouse-1: toggle Parinfer mode")
                                   'local-map (doto (make-sparse-keymap)
                                                (define-key [mode-line mouse-1] #'parinfer-rust-toggle-paren-mode))))
                      ((bound-and-true-p parinfer-mode)
                       (propertize "Parinfer"
                                   'help-echo "Parinfer smart mode is enabled for current buffer"))
                      ((bound-and-true-p paredit-mode)
                       (propertize "Paredit" 'help-echo "Paredit mode is enabled for current buffer"))
                      ((bound-and-true-p smartparens-strict-mode)
                       (propertize "SP (Strict)" 'help-echo "Smartparens mode is enabled for current buffer"))
                      ((bound-and-true-p smartparens-mode)
                       (propertize "SP" 'help-echo "Smartparens mode is enabled for current buffer"))
                      ((bound-and-true-p lispy-mode)
                       (propertize "Lispy" 'help-echo "Lispy mode is enabled for current buffer"))
                      ((bound-and-true-p electric-pair-mode)
                       (propertize "EPM" 'help-echo "Electric Pair mode is enabled for current buffer")))))
      (concat "  " structural)))
#+end_src

*** Mode-line format
Fallback format for modeline.

#+begin_src emacs-lisp
  (setq-default
   mode-line-format
   '(:eval
     (let ((l-format (concat " " (aorst/mode-line-buffer-name)))
           (r-format (concat
                      (aorst/mode-line-buffer-modified)
                      (aorst/mode-line-readonly)
                      (aorst/mode-line-line-column)
                      (aorst/mode-line-input-method)
                      (aorst/mode-line-line-encoding)
                      (aorst/mode-line-buffer-encoding)
                      (aorst/mode-line-indent-mode)
                      (aorst/mode-line-mode-name)
                      (aorst/mode-line-git-branch)
                      (aorst/mode-line-flycheck)
                      (aorst/mode-line-structural))))
       (concat l-format
               (make-string (- (window-width)
                               (string-width (format-mode-line l-format))
                               (string-width (format-mode-line r-format)))
                            ?\s)
               r-format))))
#+end_src

*** Mini Modeline
A very interesting package that displays mode-line in the echo area (minibuffer).
Currently it uses default format, and I'm looking forward to integrate DOOM mode-line with it.

#+begin_src emacs-lisp
  (use-package mini-modeline
    :straight (:host github
               :repo "kiennq/emacs-mini-modeline")
    :hook (((aorst--theme-change
             aorst--solaire-swap-bg)
            . aorst/mini-modeline-setup-faces)
           (after-init . mini-modeline-mode))
    :custom
    (mini-modeline-right-padding 2)
    (mini-modeline-display-gui-line nil)
    (mini-modeline-l-format
     '(:eval (string-trim-left (or (aorst/mode-line-buffer-name) ""))))
    (mini-modeline-r-format
     '(:eval (concat
              (aorst/mode-line-buffer-modified)
              (aorst/mode-line-readonly)
              (aorst/mode-line-line-column)
              (aorst/mode-line-input-method)
              (aorst/mode-line-line-encoding)
              (aorst/mode-line-buffer-encoding)
              (aorst/mode-line-indent-mode)
              (aorst/mode-line-mode-name)
              (aorst/mode-line-git-branch)
              (aorst/mode-line-flycheck)
              (aorst/mode-line-structural))))
    :config
    (defun aorst/mini-modeline-setup-faces ()
      (setq mini-modeline-face-attr
            (plist-put mini-modeline-face-attr
                       :background (face-attribute 'mode-line :background)))))
#+end_src

** Frame
Some tweaks to window divider colors.

#+begin_src emacs-lisp
  (when window-system
    (use-package frame
      :straight nil
      :hook ((aorst--theme-change
              aorst--solaire-swap-bg)
             . aorst/window-divider-setup-faces)
      :custom
      (window-divider-default-bottom-width 1)
      (window-divider-default-right-width 1)
      (window-divider-default-places t)
      :config
      (window-divider-mode t)
      (defun aorst/window-divider-setup-faces ()
        (let* ((color (face-attribute 'mode-line-inactive :background))
               (color (if (fboundp #'doom-darken)
                          (pcase (frame-parameter nil 'background-mode)
                            ('light (doom-lighten color 0.10))
                            ('dark (doom-darken color 0.15))))))
          (set-face-attribute 'window-divider nil :foreground color)))
      (aorst/window-divider-setup-faces)))
#+end_src

** Title
Emacs uses weird method of naming a frame.
I'd like to see a file I'm currently working on in the task bar in case my Emacs was minimized for some reason.
But I don't really need all these special buffers in the frame title.
We can avoid this with this little check for space and asterisk at the beginning of buffer name.

#+begin_src emacs-lisp
  (setq-default frame-title-format
                '(:eval (let ((match (string-match "[ *]" (buffer-name))))
                          (if (and match (= match 0)) "Emacs" "%b — Emacs"))))
#+end_src

** Treemacs
To make Emacs look more like a modern text editor we need a file explorer.
Emacs has builtin package for this, named =speedbar=, but It uses external frame and has so many features that I don't know if I really need.
With this package, and its supplement packages I can have a consistent filetree inside my Emacs frame.
Which is good.

#+begin_src emacs-lisp
  (use-package treemacs
    :when window-system
    :commands (treemacs-follow-mode
               treemacs-filewatch-mode
               treemacs-load-theme)
    :bind (("<f7>" . treemacs)
           ("<f8>" . treemacs-select-window)
           :map treemacs-mode-map
           ([C-tab] . aorst/treemacs-expand-all-projects))
    :hook ((after-init . aorst/treemacs-after-init-setup)
           (treemacs-mode . aorst/after-treemacs-setup)
           (treemacs-switch-workspace . aorst/treemacs-expand-all-projects)
           (treemacs-switch-workspace . treemacs-set-fallback-workspace)
           (treemacs-mode . aorst/treemacs-setup-title)
           ((aorst--theme-change
             aorst--solaire-swap-bg)
            . aorst/treemacs-setup-title)
           ((aorst--theme-change
             aorst--solaire-swap-bg)
            . aorst/treemacs-setup-faces))
    :custom-face
    (treemacs-fringe-indicator-face ((t (:inherit font-lock-doc-face))))
    :custom
    (treemacs-width 32)
    (treemacs-is-never-other-window t)
    (treemacs-space-between-root-nodes nil)
    (treemacs-indentation 2)
    (treemacs-collapse-dirs 0)
    :config
    (use-package treemacs-magit)
    (treemacs-follow-mode t)
    (treemacs-filewatch-mode t)
    (defun aorst/treemacs-setup-faces ()
      (set-face-attribute 'treemacs-root-face nil
                          :foreground (face-attribute 'default :foreground)
                          :height 1.0
                          :weight 'normal))
    (aorst/treemacs-setup-faces)
    :init
    (defun aorst/treemacs-expand-all-projects (&optional _)
      "Expand all projects."
      (interactive)
      (save-excursion
        (treemacs--forget-last-highlight)
        (dolist (project (treemacs-workspace->projects (treemacs-current-workspace)))
          (-when-let (pos (treemacs-project->position project))
            (when (eq 'root-node-closed (treemacs-button-get pos :state))
              (goto-char pos)
              (treemacs--expand-root-node pos)))))
      (treemacs--maybe-recenter 'on-distance))
    (defun aorst/treemacs-variable-pitch-labels (&rest _)
      (dolist (face '(treemacs-file-face
                      treemacs-root-face
                      treemacs-tags-face
                      treemacs-directory-face
                      treemacs-directory-collapsed-face
                      treemacs-term-node-face
                      treemacs-help-title-face
                      treemacs-help-column-face
                      treemacs-git-added-face
                      treemacs-git-ignored-face
                      treemacs-git-renamed-face
                      treemacs-git-conflict-face
                      treemacs-git-modified-face
                      treemacs-git-unmodified-face
                      treemacs-git-untracked-face
                      treemacs-root-unreadable-face
                      treemacs-root-remote-face
                      treemacs-root-remote-unreadable-face
                      treemacs-root-remote-disconnected-face
                      treemacs-fringe-indicator-face
                      treemacs-on-failure-pulse-face
                      treemacs-on-success-pulse-face))
        (let ((faces (face-attribute face :inherit nil)))
          (set-face-attribute
           face nil :inherit
           `(variable-pitch ,@(delq 'unspecified (if (listp faces) faces (list faces))))))))
    (defun aorst/treemacs-after-init-setup ()
      "Set treemacs theme, open treemacs, and expand all projects."
      (load-file (expand-file-name "treemacs-atom-theme.el" user-emacs-directory))
      (treemacs-load-theme "Atom")
      (treemacs)
      (treemacs-fringe-indicator-mode -1)
      (aorst/treemacs-expand-all-projects)
      (windmove-right))
    (defun aorst/after-treemacs-setup ()
      "Set treemacs buffer common settings."
      (setq tab-width 1
            mode-line-format nil
            line-spacing 5)
      (setq-local scroll-step 1)
      (setq-local scroll-conservatively 10000)
      (set-window-fringes nil 0 1 nil)
      (aorst/treemacs-variable-pitch-labels))
    (define-advice treemacs-select-window (:after () aorst:treemacs-setup-fringes)
      "Set treemacs buffer fringes."
      (set-window-fringes nil 0 1 t))
    (defun aorst/treemacs-setup-title ()
      (when-let ((treemacs-buffer (treemacs-get-local-buffer)))
        (with-current-buffer treemacs-buffer
          (let ((bg (face-attribute 'default :background))
                (fg (face-attribute 'default :foreground)))
            (face-remap-add-relative 'header-line
                                     :background bg :foreground fg
                                     :box `(:line-width ,(/ aorst--line-pixel-height 4) :color ,bg)))
          (setq header-line-format
                '((:eval
                   (let* ((text (treemacs-workspace->name (treemacs-current-workspace)))
                          (extra-align (+ (/ (length text) 2) 1))
                          (width (- (/ (window-width) 2) extra-align)))
                     (concat (make-string width ?\s) text)))))))))
#+end_src

*** Treemacs Atom theme
Here's a Atom inspired theme for Treemacs, that I'm tangling to separate file, to reduce Treemacs config size a bit:

#+begin_src emacs-lisp :tangle ./treemacs-atom-theme.el
  ;;; treemacs-atom-theme.el --- Atom inspired theme for Treemacs -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-
  ;;;
  ;;; Commentary:
  ;;; Simple Atom inspired theme for Treemacs package.
  ;;; Does not provide different kinds of icons for different file extensions.
  ;;; This file was automatically generated by `org-babel-tangle'.
  ;;; Do not change this file.  Treemacs theme config is located in README.org at `user-emacs-directory'
  ;;;
  ;;; Code:

  (require 'treemacs)
  (require 'all-the-icons)

  (treemacs-create-theme "Atom"
    :config
    (progn
      (treemacs-create-icon
       :icon (format " %s\t%s\t"
                     (all-the-icons-octicon
                      "chevron-down"
                      :height 0.75
                      :v-adjust 0.1
                      :face '(:inherit font-lock-doc-face :slant normal :weight normal))
                     (all-the-icons-octicon
                      "file-directory"
                      :v-adjust 0
                      :face '(:inherit font-lock-doc-face :slant normal :weight normal)))
       :fallback (propertize "- " 'face 'font-lock-doc-face)
       :extensions (root-open))
      (treemacs-create-icon
       :icon (format " %s\t%s\t"
                     (all-the-icons-octicon
                      "chevron-right"
                      :height 0.75
                      :v-adjust 0.1
                      :face '(:inherit font-lock-doc-face :slant normal :weight normal))
                     (all-the-icons-octicon
                      "file-directory"
                      :v-adjust 0
                      :face '(:inherit font-lock-doc-face :slant normal :weight normal)))
       :fallback (propertize "+ " 'face 'font-lock-doc-face)
       :extensions (root-closed))
      (treemacs-create-icon
       :icon (format " %s\t%s\t"
                     (all-the-icons-octicon
                      "chevron-down"
                      :height 0.75
                      :v-adjust 0.1
                      :face '(:inherit font-lock-doc-face :slant normal :weight normal))
                     (all-the-icons-octicon
                      "file-directory"
                      :v-adjust 0
                      :face '(:inherit font-lock-doc-face :slant normal :weight normal)))
       :fallback (propertize "- " 'face 'font-lock-doc-face)
       :extensions (dir-open))
      (treemacs-create-icon
       :icon (format " %s\t%s\t"
                     (all-the-icons-octicon
                      "chevron-right"
                      :height 0.75
                      :v-adjust 0.1
                      :face '(:inherit font-lock-doc-face :slant normal :weight normal))
                     (all-the-icons-octicon
                      "file-directory"
                      :v-adjust 0
                      :face '(:inherit font-lock-doc-face :slant normal :weight normal)))
       :fallback (propertize "+ " 'face 'font-lock-doc-face)
       :extensions (dir-closed))
      (treemacs-create-icon
       :icon (format " %s\t%s\t"
                     (all-the-icons-octicon
                      "chevron-down"
                      :height 0.75
                      :v-adjust 0.1
                      :face '(:inherit font-lock-doc-face :slant normal :weight normal))
                     (all-the-icons-octicon
                      "package"
                      :v-adjust 0
                      :face '(:inherit font-lock-doc-face :slant normal :weight normal)))
       :fallback (propertize "▾ " 'face 'font-lock-string-face)
       :extensions (tag-open))
      (treemacs-create-icon
       :icon (format " %s\t%s\t"
                     (all-the-icons-octicon
                      "chevron-right"
                      :height 0.75
                      :v-adjust 0.1
                      :face '(:inherit font-lock-doc-face :slant normal :weight normal))
                     (all-the-icons-octicon
                      "package"
                      :v-adjust 0
                      :face '(:inherit font-lock-doc-face :slant normal :weight normal)))
       :fallback (propertize "▸ " 'face 'font-lock-string-face)
       :extensions (tag-closed))
      (treemacs-create-icon
       :icon (format " %s\t"
                     (all-the-icons-octicon
                      "tag"
                      :height 0.9
                      :v-adjust 0
                      :face '(:inherit font-lock-doc-face :slant normal :weight normal)))
       :fallback ""
       :extensions (tag-leaf))
      (treemacs-create-icon
       :icon (format " %s\t"
                     (all-the-icons-octicon
                      "flame"
                      :v-adjust 0
                      :face '(:inherit font-lock-doc-face :slant normal :weight normal)))
       :fallback ""
       :extensions (error))
      (treemacs-create-icon
       :icon (format " %s\t"
                     (all-the-icons-octicon
                      "stop"
                      :v-adjust 0
                      :face '(:inherit font-lock-doc-face :slant normal :weight normal)))
       :fallback ""
       :extensions (warning))
      (treemacs-create-icon
       :icon (format " %s\t"
                     (all-the-icons-octicon
                      "info"
                      :height 0.75
                      :v-adjust 0.1
                      :face '(:inherit font-lock-doc-face :slant normal :weight normal)))
       :fallback ""
       :extensions (info))
      (treemacs-create-icon
       :icon (format "   %s\t"
                     (all-the-icons-octicon
                      "file-media"
                      :v-adjust 0
                      :face '(:inherit font-lock-doc-face :slant normal :weight normal)))
       :fallback ""
       :extensions ("png" "jpg" "jpeg" "gif" "ico" "tif" "tiff" "svg" "bmp"
                    "psd" "ai" "eps" "indd" "mov" "avi" "mp4" "webm" "mkv"
                    "wav" "mp3" "ogg" "midi"))
      (treemacs-create-icon
       :icon (format "   %s\t"
                     (all-the-icons-octicon
                      "file-code"
                      :v-adjust 0
                      :face '(:inherit font-lock-doc-face :slant normal :weight normal)))
       :fallback ""
       :extensions ("yml" "yaml" "sh" "zsh" "fish" "c" "h" "cpp" "cxx" "hpp"
                    "tpp" "cc" "hh" "hs" "lhs" "cabal" "py" "pyc" "rs" "el" "erl"
                    "elc" "clj" "cljs" "cljc" "ts" "tsx" "vue" "css" "html"
                    "htm" "dart" "java" "kt" "scala" "sbt" "go" "js" "jsx"
                    "hy" "json" "jl" "ex" "exs" "eex" "ml" "mli" "pp" "dockerfile"
                    "vagrantfile" "j2" "jinja2" "tex" "racket" "rkt" "rktl" "rktd"
                    "scrbl" "scribble" "plt" "makefile" "elm" "xml" "xsl" "rb"
                    "scss" "lua" "lisp" "scm" "sql" "toml" "nim" "pl" "pm" "perl"
                    "vimrc" "tridactylrc" "vimperatorrc" "ideavimrc" "vrapperrc"
                    "cask" "r" "re" "rei" "bashrc" "zshrc" "inputrc" "editorconfig"
                    "gitconfig" "gitignore" "gitmodules" "conf" "lock" "project" "fnl"
                    "config"))
      (treemacs-create-icon
       :icon (format "   %s\t"
                     (all-the-icons-octicon
                      "book"
                      :v-adjust 0
                      :face '(:inherit font-lock-doc-face :slant normal :weight normal)))
       :fallback ""
       :extensions ("lrf" "lrx" "cbr" "cbz" "cb7" "cbt" "cba" "chm" "djvu"
                    "doc" "docx" "pdb" "pdb" "fb2" "xeb" "ceb" "inf" "azw"
                    "azw3" "kf8" "kfx" "lit" "prc" "mobi" "pkg" "opf" "txt"
                    "pdb" "ps" "rtf" "pdg" "xml" "tr2" "tr3" "oxps" "xps"))
      (treemacs-create-icon
       :icon (format "   %s\t" (all-the-icons-octicon
                               "file-text"
                               :v-adjust 0
                               :face '(:inherit font-lock-doc-face :slant normal :weight normal)))
       :fallback ""
       :extensions ("md" "markdown" "rst" "log" "org" "txt"
                    "contribute" "license" "readme" "changelog"))
      (treemacs-create-icon
       :icon (format "   %s\t" (all-the-icons-octicon
                               "file-binary"
                               :v-adjust 0
                               :face '(:inherit font-lock-doc-face :slant normal :weight normal)))
       :fallback ""
       :extensions ("exe" "dll" "obj" "so" "o" "out"))
      (treemacs-create-icon
       :icon (format "   %s\t" (all-the-icons-octicon
                               "file-pdf"
                               :v-adjust 0
                               :face '(:inherit font-lock-doc-face :slant normal :weight normal)))
       :fallback ""
       :extensions ("pdf"))
      (treemacs-create-icon
       :icon (format "   %s\t" (all-the-icons-octicon
                               "file-zip"
                               :v-adjust 0
                               :face '(:inherit font-lock-doc-face :slant normal :weight normal)))
       :fallback ""
       :extensions ("zip" "7z" "tar" "gz" "rar" "tgz"))
      (treemacs-create-icon
       :icon (format "   %s\t" (all-the-icons-octicon
                               "file-text"
                               :v-adjust 0
                               :face '(:inherit font-lock-doc-face :slant normal :weight normal)))
       :fallback ""
       :extensions (fallback))))

  (provide 'treemacs-atom-theme)
  ;; treemacs-atom-theme.el ends here
#+end_src

** Uniquify
This package makes files with identical names more distinguishable by adding directory name in the buffer name.

#+begin_src emacs-lisp
  (use-package uniquify
    :straight nil
    :custom (uniquify-buffer-name-style 'forward))
#+end_src

** Tabline
Starting with Emacs 27 native tab support is present.
I want to customize tab appearance to match my theme.

#+begin_src emacs-lisp
  (use-package tab-line
    :straight nil
    :when window-system
    :hook ((after-init . global-tab-line-mode)
           ((aorst--theme-change
             aorst--solaire-swap-bg)
            . aorst/tabline-setup-faces))
    :config
    (defun tab-line-close-tab (&optional e)
      "Close the selected tab.

  If tab is presented in another window, close the tab by using
  `bury-buffer` function.  If tab is unique to all existing
  windows, kill the buffer with `kill-buffer` function.  Lastly, if
  no tabs left in the window, it is deleted with `delete-window`
  function."
      (interactive "e")
      (let* ((posnp (event-start e))
             (window (posn-window posnp))
             (buffer (get-pos-property 1 'tab (car (posn-string posnp)))))
        (with-selected-window window
          (let ((tab-list (tab-line-tabs-window-buffers))
                (buffer-list (flatten-list
                              (seq-reduce (lambda (list window)
                                            (select-window window t)
                                            (cons (tab-line-tabs-window-buffers) list))
                                          (window-list) nil))))
            (select-window window)
            (if (> (seq-count (lambda (b) (eq b buffer)) buffer-list) 1)
                (progn
                  (if (eq buffer (current-buffer))
                      (bury-buffer)
                    (set-window-prev-buffers window (assq-delete-all buffer (window-prev-buffers)))
                    (set-window-next-buffers window (delq buffer (window-next-buffers))))
                  (unless (cdr tab-list)
                    (ignore-errors (delete-window window))))
              (and (kill-buffer buffer)
                   (unless (cdr tab-list)
                     (ignore-errors (delete-window window)))))))))


    (defun aorst/tab-line-name-buffer (buffer &rest _buffers)
      "Create name for tab with padding and truncation.

  If buffer name is shorter than `tab-line-tab-max-width' it gets
  centered with spaces, otherwise it is truncated, to preserve
  equal width for all tabs.  This function also tries to fit as
  many tabs in window as possible, so if there are no room for tabs
  with maximum width, it calculates new width for each tab and
  truncates text if needed.  Minimal width can be set with
  `tab-line-tab-min-width' variable."
      (with-current-buffer buffer
        (let ((buffer (string-trim (buffer-name)))
              (right-pad (if tab-line-close-button-show "" " ")))
          (propertize (concat " " buffer right-pad)
                      'help-echo (when-let ((name (buffer-file-name)))
                                   (abbreviate-file-name name))))))


    (setq tab-line-close-button-show t
          tab-line-new-button-show nil
          tab-line-separator ""
          tab-line-tab-name-function #'aorst/tab-line-name-buffer
          tab-line-right-button (propertize (if (char-displayable-p ?▶) " ▶ " " > ")
                                            'keymap tab-line-right-map
                                            'mouse-face 'tab-line-highlight
                                            'help-echo "Click to scroll right")
          tab-line-left-button (propertize (if (char-displayable-p ?◀) " ◀ " " < ")
                                           'keymap tab-line-left-map
                                           'mouse-face 'tab-line-highlight
                                           'help-echo "Click to scroll left")
          tab-line-close-button (propertize (if (char-displayable-p ?×) " × " " x ")
                                            'keymap tab-line-tab-close-map
                                            'mouse-face 'tab-line-close-highlight
                                            'help-echo "Click to close tab")
          tab-line-exclude-modes '(ediff-mode
                                   process-menu-mode
                                   term-mode
                                   vterm-mode
                                   treemacs-mode
                                   imenu-list-major-mode))


    (defun aorst/tabline-setup-faces ()
      (let ((bg (if (and (facep 'solaire-default-face)
                         (not (eq (face-attribute 'solaire-default-face :background)
                                  'unspecified)))
                    (face-attribute 'solaire-default-face :background)
                  (face-attribute 'default :background)))
            (fg (face-attribute 'default :foreground))
            (dark-fg (face-attribute 'shadow :foreground))
            (overline (face-attribute 'font-lock-keyword-face :foreground))
            (base (if (and (facep 'solaire-default-face)
                           (not (eq (face-attribute 'solaire-default-face :background)
                                    'unspecified)))
                      (face-attribute 'default :background)
                    (face-attribute 'mode-line :background)))
            (box-width (/ aorst--line-pixel-height 5)))
        (set-face-attribute 'tab-line nil
                            :background base
                            :foreground dark-fg
                            :height 1.0
                            :inherit nil
                            :overline base
                            :box  (when (> box-width 0)
                                    (list :line-width box-width :color base)))
        (set-face-attribute 'tab-line-tab nil
                            :foreground dark-fg
                            :background bg
                            :inherit nil
                            :box nil)
        (set-face-attribute 'tab-line-tab-inactive nil
                            :foreground dark-fg
                            :background base
                            :inherit nil
                            :box nil)
        (set-face-attribute 'tab-line-tab-current nil
                            :foreground fg
                            :background bg
                            :inherit nil
                            :overline overline
                            :box nil)))

    (aorst/tabline-setup-faces)

    (define-advice tab-line-select-tab (:after (&optional e) aorst:tab-line-select-tab)
      (select-window (posn-window (event-start e)))))
#+end_src

** Line Numbers
=display-line-numbers= provides line numbers on the left side of the window, which doesn't lag.
I don't like that it changes width, so let's make it grow only, and calculate maximum width on file open:

#+begin_src emacs-lisp
  (use-package display-line-numbers
    :straight nil
    :hook (prog-mode . display-line-numbers-mode)
    :custom
    (display-line-numbers-width 4)
    (display-line-numbers-grow-only t)
    (display-line-numbers-width-start t))
#+end_src

* Languages
This section contains various language specific settings and external packages that provide language support.

** Org
Org Mode is a great mode for taking notes, managing to-do lists, writing books, literate programming, and many other things.
I primary use it for taking notes on different programming languages, and manage my Emacs configuration with it.

#+begin_src emacs-lisp
  (use-package org
    :straight (:type built-in)
    :hook ((after-save . aorst/org-tangle-on-config-save)
           (org-babel-after-execute . aorst/org-update-inline-images)
           (ediff-prepare-buffer . outline-show-all)
           ((org-capture-mode org-src-mode) . aorst/discard-history)
           (text-scale-mode . aorst/update-latex-preview-scale))
    :bind (("C-c a" . org-agenda)
           :map org-mode-map
           ("M-Q" . aorst/split-pararagraph-into-lines)
           ("C-c l" . org-store-link))
    :custom
    (org-startup-with-inline-images nil)
    (org-tags-column -100)
    (org-startup-folded 'content)
    (org-hide-emphasis-markers t)
    (org-adapt-indentation nil)
    (org-hide-leading-stars t)
    (org-highlight-latex-and-related '(latex))
    (revert-without-query '(".*\.pdf"))
    (org-preview-latex-default-process 'dvisvgm)
    (org-src-fontify-natively t)
    (org-preview-latex-image-directory ".ltximg/")
    (org-latex-listings 'minted)
    (org-latex-pdf-process '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
                             "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
                             "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
    (org-confirm-babel-evaluate nil)
    (org-imenu-depth 8)
    (org-log-done t)
    (org-agenda-files '("~/Tasks"))
    (org-image-actual-width nil)
    :config
    (defun aorst/get-system-font-scale ()
      (if (executable-find "gsettings")
          (string-to-number
           (shell-command-to-string
            "gsettings get org.gnome.desktop.interface text-scaling-factor"))
        1.0))
    (setq org-format-latex-options
          (plist-put org-format-latex-options
                     :scale
                     (aorst/get-system-font-scale)))
    (use-package ox-latex
      :straight nil)
    (use-package ox-hugo
      :after ox)
    (when (not (version<= org-version "9.1.9"))
      (use-package org-tempo
        :straight nil))
    (font-lock-add-keywords 'org-mode
                            '(("^ *\\([-+]\\) "
                               (0 (prog1 nil (compose-region (match-beginning 1)
                                                             (match-end 1)
                                                             "•"))))))
    (defun aorst/org-tangle-on-config-save ()
      "Tangle source code blocks when configuration file is saved."
      (when (string= buffer-file-name (file-truename (concat user-emacs-directory "README.org")))
        (org-babel-tangle)))
    (defun aorst/org-update-inline-images ()
      "Update inline images in Org-mode."
      (interactive)
      (when org-inline-image-overlays
        (org-redisplay-inline-images)))
    (defun aorst/discard-history ()
      "Discard undo history of org src and capture blocks."
      (setq buffer-undo-list nil)
      (set-buffer-modified-p nil))
    (defun aorst/update-latex-preview-scale ()
      (let ((scale (or (plist-get org-format-latex-options :scale) 0)))
        (setq org-format-latex-options
              (plist-put org-format-latex-options
                         :scale (if-let ((scale (aorst/get-system-font-scale)))
                                    (if (= text-scale-mode-amount 0)
                                        scale
                                      (let ((height (cadr (cadr (assq 'default face-remapping-alist)))))
                                        (if (numberp height)
                                            (+ (- scale 1) height)
                                          scale)))
                                  1.0)))))
    (defvar minted-cache-dir
      (file-name-as-directory
       (expand-file-name ".minted/\\jobname"
                         temporary-file-directory)))
    (add-to-list 'org-latex-packages-alist
                 `(,(concat "cachedir=" minted-cache-dir)
                   "minted" nil))
    (add-to-list 'org-latex-logfiles-extensions "tex")
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((gnuplot . t)
       (scheme . t)))
    (add-to-list 'org-latex-classes
                 '("article"
                   "\\documentclass{article}"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
    (defun aorst/org-update-latex-preview-background-color (&rest _)
      (setq-default
       org-format-latex-options
       (plist-put org-format-latex-options
                  :background
                  (face-attribute (let ((face (cadr (assq 'default face-remapping-alist))))
                                    (if (facep face) face 'default))
                                  :background nil t))))
    (add-hook 'solaire-mode-hook #'aorst/org-update-latex-preview-background-color))
#+end_src

** Prog Mode
This isn't really a configuration of Prog Mode itself, but some hooks that change how programming related modes behave.
One feature that I think is really important, especially when working with lisp code, is ability to see matching bracket when cursor stands near the other bracket.
So I enable it for every programming language.

#+begin_src emacs-lisp
  (use-package prog-mode
    :straight nil
    :hook (prog-mode . hl-line-mode))
#+end_src

** CC
These settings are for editing C source files.

#+begin_src emacs-lisp
  (use-package cc-mode
    :straight nil
    :config (defun aorst/cc-mode-setup ()
              (c-set-offset 'case-label '+)
              (setq c-basic-offset 4
                    c-default-style "linux"
                    indent-tabs-mode t
                    comment-start "//"
                    comment-end ""
                    tab-width 4))
    :hook ((c-mode-common . aorst/cc-mode-setup)))
#+end_src

** Markdown
Sometimes I need to edit Markdown documents, so this package is handy.
For markdown mode I would like to have automatic spell checking and filling.
Basically the same setup as for Org Mode.
And one of the features of Org mode is ability to edit source code blocks in separate window with appropriate major mode.
This can be achieved with =edit-indirect= package.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :bind (:map markdown-mode-map
           ("M-Q" . aorst/split-pararagraph-into-lines))
    :custom
    (markdown-fontify-code-blocks-natively t)
    (markdown-command "pandoc")
    :hook ((markdown-mode . flyspell-mode)))
#+end_src

** Rust
I'd like to have Rust syntax highlighting and some basic facilities, since I'm planning to write my exercises in org mode.
Since I make notes in Org-mode, and I started to use it for Rust too, I need some settings for Rust mode.

#+begin_src emacs-lisp
  (use-package rust-mode
    :commands (rust-format-buffer)
    :bind (:map rust-mode-map
           ("C-c C-M-f" . rust-format-buffer)))
#+end_src

This also means that I could use something to automatically complete Rust language facilities.
Rust ecosystem provides two options for that: [[https://github.com/racer-rust/emacs-racer][Racer]], and [[https://github.com/rust-lang/rls][RLS]].
I'm planning to use Racer when RLS isn't possible to use, like in Org Mode.

#+begin_src emacs-lisp
  (use-package racer
    :if (executable-find "racer")
    :hook (racer-mode . eldoc-mode)
    :init (defun org-babel-edit-prep:rust (&optional _babel-info)
            "Run racer mode for Org Babel."
            (racer-mode 1)))
#+end_src

There's also a package for [[https://github.com/kwrooijen/cargo.el][Cargo]] integration:

#+begin_src emacs-lisp
  (use-package cargo
    :if (executable-find "cargo")
    :hook ((rust-mode toml-mode) . cargo-minor-mode))
#+end_src

** TOML
=toml-mode= helps with highlighting of TOML files, which Rust uses to configure project.

#+begin_src emacs-lisp
  (use-package toml-mode
    :bind (:map toml-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)))
#+end_src

** Geiser
Great REPL support for various Schemes.

#+begin_src emacs-lisp
  (use-package geiser
    :hook (scheme-mode . geiser-mode)
    :custom
    (geiser-active-implementations '(guile))
    (geiser-default-implementation 'guile))
#+end_src

** Racket
Racket is nice LISP/Scheme language that I might to get into.

#+begin_src emacs-lisp
  (use-package racket-mode
    :bind (:map racket-mode-map
           ("C-c C-d" . racket-run-with-debugging)
           ("C-c C-M-f" . aorst/indent-buffer)
           (")" . self-insert-command)
           ("]" . self-insert-command)
           ("}" . self-insert-command))
    :config
    (set-face-attribute 'racket-debug-break-face nil :background (face-attribute 'error :foreground) :foreground (face-attribute 'default :background))
    (set-face-attribute 'racket-debug-result-face nil :foreground (face-attribute 'font-lock-comment-face :foreground) :box nil)
    (set-face-attribute 'racket-debug-locals-face nil :foreground (face-attribute 'font-lock-comment-face :foreground) :box nil)
    (set-face-attribute 'racket-selfeval-face nil :foreground (face-attribute 'default :foreground)))
#+end_src

** Cmake
A mode for editing cmake files.

#+begin_src emacs-lisp
  (use-package cmake-mode
    :bind (:map cmake-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)))
#+end_src

** Emacs Lisp
I write some Emacs Lisp and experience is already quite good, I just want to enable some helper modes here.

#+begin_src emacs-lisp
  (use-package elisp-mode
    :straight nil
    :commands (aorst/emacs-lisp-indent-function)
    :hook ((emacs-lisp-mode . eldoc-mode)
           (emacs-lisp-mode . (lambda ()
                                (setq-local lisp-indent-function
                                            #'aorst/emacs-lisp-indent-function))))
    :bind (:map emacs-lisp-mode-map
           ("C-c C-M-f" . aorst/indent-buffer))
    :config
    (defun aorst/emacs-lisp-indent-function (indent-point state)
      "A replacement for `lisp-indent-function'.
  Indents plists more sensibly. Adapted from DOOM Emacs:
  https://github.com/hlissner/doom-emacs/commit/a634e2c8125ed692bb76b2105625fe902b637998"
      (let ((normal-indent (current-column))
            (orig-point (point)))
        (goto-char (1+ (elt state 1)))
        (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
        (cond ((and (elt state 2)
                    (or (not (looking-at-p "\\sw\\|\\s_"))
                        (eq (char-after) ?:)))
               (unless (> (save-excursion (forward-line 1) (point))
                          calculate-lisp-indent-last-sexp)
                 (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t))
               (backward-prefix-chars)
               (current-column))
              ((and (save-excursion
                      (goto-char indent-point)
                      (skip-syntax-forward " ")
                      (not (eq (char-after) ?:)))
                    (save-excursion
                      (goto-char orig-point)
                      (eq (char-after) ?:)))
               (save-excursion
                 (goto-char (+ 2 (elt state 1)))
                 (current-column)))
              ((let* ((function (buffer-substring (point) (progn (forward-sexp 1) (point))))
                      (method (or (function-get (intern-soft function) 'lisp-indent-function)
                                  (get (intern-soft function) 'lisp-indent-hook))))
                 (cond ((or (eq method 'defun)
                            (and (null method)
                                 (> (length function) 3)
                                 (string-match-p "\\`def" function)))
                        (lisp-indent-defform state indent-point))
                       ((integerp method)
                        (lisp-indent-specform method state
                                              indent-point normal-indent))
                       (method
                        (funcall method indent-point state))))))))
    (defun org-babel-edit-prep:emacs-lisp (&optional _babel-info)
      "Setup Emacs Lisp buffer for Org Babel."
      (setq lexical-binding t)
      (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc))))
#+end_src

** Yaml
Support for =.yaml= files.

#+begin_src emacs-lisp
  (use-package yaml-mode
    :custom (yaml-indent-offset 4))
#+end_src

*** flycheck-yamllint
Yaml linter integration with Flycheck.

#+begin_src emacs-lisp
  (use-package flycheck-yamllint
    :when (executable-find "yamllint")
    :hook ((yaml-mode . flycheck-yamllint-setup)
           (yaml-mode . flycheck-mode)))
#+end_src

** Shell Script
Some configurations for shell script modes.

#+begin_src emacs-lisp
  (use-package sh-script
    :straight nil
    :bind (:map sh-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)))
#+end_src

** Perl
Perl related configurations.

#+begin_src emacs-lisp
  (use-package perl-mode
    :straight nil
    :hook ((perl-mode . flycheck-mode))
    :bind (:map perl-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)))
#+end_src

** Clojure
Clojure is a Lisp dialect for Java Virtual Machine.
It is one of the few modern and refreshing languages, that bring both innovation and reliability.

#+begin_src emacs-lisp
  (use-package clojure-mode
    :hook (((clojure-mode
             clojurec-mode
             clojurescript-mode)
            . flycheck-mode))
    :bind (:map clojure-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)))
#+end_src

*** CIDER
Emacs also has a great package called Cider, which is an IDE for Clojure and ClojureScript.

#+begin_src emacs-lisp
  (use-package cider
    :hook (((cider-repl-mode cider-mode) . cider-company-enable-fuzzy-completion)
           ((cider-repl-mode cider-mode) . eldoc-mode))
    :custom-face
    (cider-result-overlay-face ((t (:box (:line-width -1 :color "grey50")))))
    (cider-error-highlight-face ((t (:inherit flymake-error))))
    (cider-warning-highlight-face ((t (:inherit flymake-warning))))
    :custom
    (nrepl-log-messages nil)
    (cider-repl-display-help-banner nil)
    (cider-repl-tab-command #'company-complete-common-or-cycle)
    (nrepl-hide-special-buffers t)
    (cider-test-show-report-on-success t)
    (cider-allow-jack-in-without-project t)
    (cider-use-fringe-indicators nil)
    (cider-font-lock-dynamically '(macro var))
    :config
    (setq cider-jdk-src-paths nil)
    (when (file-exists-p "/usr/lib/jvm/java-1.8.0-openjdk/src.zip")
      (add-to-list 'cider-jdk-src-paths "/usr/lib/jvm/java-1.8.0-openjdk/src.zip"))
    (when (file-exists-p "/usr/lib/jvm/java-11-openjdk/lib/src.zip")
      (add-to-list 'cider-jdk-src-paths "/usr/lib/jvm/java-11-openjdk/lib/src.zip"))
    (when (file-exists-p "~/.clojure-src/")
      (setq cider-jdk-src-paths
            (append cider-jdk-src-paths
                    (file-expand-wildcards "~/.clojure-src/clojure-*.*.*-sources.jar")))))
#+end_src

*** flycheck-clj-kondo
[[https://github.com/borkdude/clj-kondo][clj-kondo]] is a static analyzer for Clojure(Script), and =flycheck-clj-kondo= is a backend for =flycheck=, that makes these two things understand each other.

#+begin_src emacs-lisp
  (use-package flycheck-clj-kondo
    :when (executable-find "clj-kondo")
    :straight (:host github
               :repo "borkdude/flycheck-clj-kondo"))
#+end_src

*** clj-refactor
=clj-refactor= provides refactoring support for Clojure projects.
It complements the refactoring functionality from =clojure-mode= and CIDER.

#+begin_src emacs-lisp
  (use-package clj-refactor
    :hook ((cider-mode . clj-refactor-mode)
           (cider-mode . yas-minor-mode))
    :custom (cljr-suppress-no-project-warning t)
            (cljr-warn-on-eval nil))
#+end_src

** Fennel
Fennel is a programming language a lisp dialect, that is being compiled to Lua, which means that it can run anywhere, where Lua can.
It supports compile-time macro system, and full Lua compatibility.

#+begin_src emacs-lisp
  (use-package fennel-mode
    :straight (:host gitlab
               :repo "technomancy/fennel-mode")
    :bind (:map fennel-mode-map
           ("C-c C-M-f" . aorst/indent-buffer))
    :config
    (put 'time 'fennel-indent-function 0)
    (put 'dotimes 'fennel-indent-function 1)
    (put 'when-let 'fennel-indent-function 1)
    (put 'if-let 'fennel-indent-function 1)
    (put 'try 'fennel-indent-function 0)
    (put 'catch 'fennel-indent-function 1)
    (put 'finally 'fennel-indent-function 0)

    (defvar org-babel-default-header-args:fennel '((:results . "silent")))
    (defun org-babel-execute:fennel (body params)
      "Evaluate a block of Fennel code with Babel."
      (lisp-eval-string body))
    (define-advice fennel-repl (:after (&rest _) aorst:fennel-repl-indent-function)
      (setq-local lisp-indent-function 'fennel-indent-function)))
#+end_src

** Lua
I'm not into Lua language myself, but in order to view what [[*Fennel][Fennel]] produces I need support for Lua.

#+begin_src emacs-lisp
  (use-package lua-mode
    :bind (:map lua-mode-map
           ("C-c C-M-f" . aorst/indent-buffer)))
#+end_src

** CSS
CSS indentation tweaks.

#+begin_src emacs-lisp
  (use-package css-mode
    :straight nil
    :custom
    (css-indent-offset 2))
#+end_src

** Erlang
Erlang is a great concurrency oriented functional language.
It is mostly used to build massively scalable soft real-time systems with requirements on high availability.
It runs on BEAM - an Erlang VM, and can also be used as a general purpose language.

#+begin_src emacs-lisp
  (use-package erlang
    :hook (erlang-mode . (lambda ()
                           (add-hook 'xref-backend-functions
                                     #'dumb-jump-xref-activate
                                     nil t))))
#+end_src

** Elixir
Elixir is a dynamic, functional language designed for building scalable and maintainable applications.
It runs on Erlang VM (BEAM), and has nice macro system, making language core small, yet still very extendable.
And it also has good interop with Erlang itself.

#+begin_src emacs-lisp
  (use-package elixir-mode
    :hook (elixir-mode . flycheck-mode)
    :custom-face
    (elixir-atom-face ((t (:foreground unspecified
                           :inherit elixir-attribute-face)))))
#+end_src

*** Mix
=Mix= is a build tool for Elixir.

#+begin_src emacs-lisp
  (use-package mix
    :hook (elixir-mode . mix-minor-mode))
#+end_src

*** Inferior IEx
Allows to interact with IEx from Emacs.

#+begin_src emacs-lisp
  (use-package inf-elixir
    :straight (:host github
               :repo "J3RN/inf-elixir"))
#+end_src

** JSON
Json support for Emacs.

#+begin_src emacs-lisp
  (use-package json-mode
    :hook (json-mode . flycheck-mode)
    :custom (js-indent-level 2))
#+end_src

** Shell script

#+begin_src emacs-lisp
  (use-package sh-script
    :straight nil
    :hook (sh-mode . flycheck-mode))
#+end_src

** Scala
Scala language support.

#+begin_src emacs-lisp
  (use-package scala-mode)
#+end_src

** SQL
SQL mode does not provide inbuilt support for indentation handling, and instead uses this package.

#+begin_src emacs-lisp
  (use-package sql-indent)
#+end_src

* Tools
Additional packages that change how Emacs works, providing more comfortable user experience.

** Help
I want help window to be selected automatically, so I could close it with =q= after I've finished reading.

#+begin_src emacs-lisp
  (use-package help
    :straight nil
    :custom (help-window-select t))
#+end_src

** Doc View
Default resolution is too low:

#+begin_src emacs-lisp
  (use-package doc-view
    :straight nil
    :custom (doc-view-resolution 192))
#+end_src

** vterm
This package provides a bridge to =libvterm= to display terminal as Emacs buffer.
It works much better than =ansi-term=, though may be buggy and requires compilation.

#+begin_src emacs-lisp
  (setq use-package-hook-name-suffix "-functions")
  (use-package vterm
    :if (bound-and-true-p module-file-suffix)
    :bind (("C-`" . aorst/vterm-toggle)
           ("C-t" . aorst/vterm-focus)
           :map vterm-mode-map
           ("<insert>" . ignore))
    :hook (vterm-exit . aorst/kill-vterm)
    :config
    (defun aorst/vterm-toggle (&optional arg)
      "Toggle `vterm' window on and off with the same command."
      (interactive "P")
      (let* ((directory (if default-directory
                            default-directory
                          (expand-file-name "~/")))
             (bufname " *vterm*")
             (window (get-buffer-window bufname)))
        (if window
            (ignore-errors (delete-window window))
          (if (window-dedicated-p)
              (let ((windows (seq-drop-while #'window-dedicated-p (window-list))))
                (when (not (null windows))
                  (select-window (car windows)))))
          (let* ((win-side (unless (string= (buffer-name) " *Install vterm* ")
                             (if (symbolp arg)
                                 (cons (split-window-below (floor (* (window-height) 0.65))) 'bot)
                               (cons (split-window-right) 'right))))
                 (window (car win-side))
                 (side (cdr win-side)))
            (when window
              (select-window window))
            (cond ((get-buffer bufname)
                   (switch-to-buffer bufname)
                   ;; for `bury-buffer' to work we need a non-hidden buffer
                   (rename-buffer "*vterm*"))
                  (t (let ((default-directory directory))
                       (vterm "*vterm*"))))
            (when (bound-and-true-p global-tab-line-mode)
              (previous-buffer)
              (bury-buffer))
            (rename-buffer " *vterm*")
            (set-window-dedicated-p window t)
            (set-window-parameter window 'no-delete-other-windows t)
            (when side
              (set-window-parameter window 'window-side side))
            (set-window-parameter window 'no-other-window t)))))
    (defun aorst/vterm-focus (&optional arg)
      "Focus `vterm' or open one if there's none."
      (interactive "P")
      (let ((window (get-buffer-window " *vterm*")))
        (if window
            (select-window window)
          (aorst/vterm-toggle arg))))
    (defun aorst/kill-vterm (buf &optional event)
      "Kill the `*vterm*' buffer after shell exits."
      (when buf (kill-buffer buf))))
  (setq use-package-hook-name-suffix "-hook")
#+end_src

** EditorConfig
=.editorconfig= file provides a nice way to synchronize my editor configurations between projects and different editors.

#+begin_src emacs-lisp
  (use-package editorconfig
    :config (editorconfig-mode 1))
#+end_src

** Flymake
Flymake is an inbuilt package for checking various programming languages.
I load it mostly for its faces, since I use =flycheck= instead.

#+begin_src emacs-lisp
  (use-package flymake :straight nil)
#+end_src

** Flycheck
Some languages have better support with =flycheck=.

#+begin_src emacs-lisp
  (use-package flycheck
    :bind (:map flycheck-mode-map
           ("C-c ! C-h" . hydrant/flycheck/body))
    :custom
    (flycheck-indication-mode 'right-fringe)
    (flycheck-display-errors-delay 86400 "86400 seconds is 1 day")
    :config
    (when (fboundp #'define-fringe-bitmap)
      (define-fringe-bitmap 'flycheck-double-exclamation-mark
        (vector #b00000000
                #b00000000
                #b00000000
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b01100110
                #b00000000
                #b01100110
                #b01100110
                #b00000000
                #b00000000
                #b00000000))
      (define-fringe-bitmap 'flycheck-exclamation-mark
        (vector #b00000000
                #b00000000
                #b00000000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00011000
                #b00000000
                #b00011000
                #b00011000
                #b00000000
                #b00000000
                #b00000000))
      (define-fringe-bitmap 'flycheck-question-mark
        (vector #b00000000
                #b00000000
                #b00000000
                #b00111100
                #b01111110
                #b01100110
                #b01100110
                #b00000110
                #b00001100
                #b00011000
                #b00011000
                #b00000000
                #b00011000
                #b00011000
                #b00000000
                #b00000000
                #b00000000))
      (flycheck-define-error-level 'error
        :severity 100
        :compilation-level 2
        :overlay-category 'flycheck-error-overlay
        :fringe-bitmap 'flycheck-double-exclamation-mark
        :fringe-face 'flycheck-fringe-error
        :error-list-face 'flycheck-error-list-error)
      (flycheck-define-error-level 'warning
        :severity 100
        :compilation-level 1
        :overlay-category 'flycheck-warning-overlay
        :fringe-bitmap 'flycheck-exclamation-mark
        :fringe-face 'flycheck-fringe-warning
        :error-list-face 'flycheck-error-list-warning)
      (flycheck-define-error-level 'info
        :severity 100
        :compilation-level 0
        :overlay-category 'flycheck-info-overlay
        :fringe-bitmap 'flycheck-question-mark
        :fringe-face 'flycheck-fringe-info
        :error-list-face 'flycheck-error-list-info))

   (when (fboundp #'defhydra)
     (defhydra hydrant/flycheck (:color blue :hint nil)
       "
   ^Flycheck^         ^Errors^       ^Checker^
   _q_: quit          _<_: previous  _?_: describe
   _M_: manual        _>_: next      _d_: disable
   _v_: verify setup  _f_: check     _m_: mode
   ^ ^                _l_: list      _s_: select"
       ("q" ignore :exit t)
       ("M" flycheck-manual)
       ("v" flycheck-verify-setup)
       ("<" flycheck-previous-error :color pink)
       (">" flycheck-next-error :color pink)
       ("f" flycheck-buffer)
       ("l" flycheck-list-errors)
       ("?" flycheck-describe-checker)
       ("d" flycheck-disable-checker)
       ("m" flycheck-mode)
       ("s" flycheck-select-checker))))
#+end_src

*** Flycheck Cask
=flycheck-cask= is a package for using [[https://github.com/cask/cask][Cask]] files with Flycheck.

#+begin_src emacs-lisp
  (use-package flycheck-cask
    :hook (flycheck-mode . flycheck-cask-setup))
#+end_src

** Hydra
This is something like ability to create mappings that sit in it's own mode, like different user modes in Kakoune.
It allows me to press some shortcut and be locked in a mode-like state where keys that are related to this prefix shortcut are behaving in terms of this shortcut.
This package will be used in many other package configurations to provide sane keybindings.

#+begin_src emacs-lisp
  (use-package hydra)
#+end_src

** Smartparens
Smartparens is a package that enables structural editing in many different languages.
Basically, for all Lisp related modes I use =smartparens-strict-mode= while for other modes I use =smartparens-mode=.
There's also a reason I don't want to use =smart-parens-strict-mode= with something other than Lisp related modes, and it is the =;= key.
I've kinda liked in Paredit and Parinfer that when you simply type ";", your parentheses will remain balanced.
Smartparens also has such feature via =sp-comment= function.
Unfortunately it is not bound by default in Lisp related configs, that are provided with Smartparens, and I don't really know if there is a clean way of binding it in this =use-package= declaration that will work for autoloaded mode-maps.
Another problem is that not all Lisp related modes have such mode map, e.g. Racket's REPL mode doesn't have one, and I don't really know what mode map to use in this case, so binding this to strict mode map is fine by me.

#+begin_src emacs-lisp
  (use-package smartparens
    :straight (:host github
               :repo "andreyorst/smartparens"
               :branch "elixir-better-search")
    :hook (((clojure-mode
             emacs-lisp-mode
             common-lisp-mode
             scheme-mode
             lisp-mode
             racket-mode
             fennel-mode
             cider-repl-mode
             racket-repl-mode
             geiser-repl-mode
             inferior-lisp-mode
             inferior-emacs-lisp-mode)
            . aorst/enable-smartparens-strict)
           (eval-expression-minibuffer-setup . aorst/minibuffer-enable-sp)
           ((org-mode
            markdown-mode
            prog-mode)
           . aorst/enable-smartparens))
    :bind (:map smartparens-strict-mode-map
           (";" . sp-comment))
    :custom
    (sp-highlight-pair-overlay nil)
    (sp-highlight-wrap-overlay nil)
    (sp-highlight-wrap-tag-overlay nil)
    (sp-wrap-respect-direction t)
    (sp-show-pair-delay 0)
    :config
    (defun aorst/minibuffer-enable-sp ()
      "Enable `smartparens-strict-mode' in the minibuffer, during `eval-expression'."
      (setq-local comment-start ";")
      (sp-local-pair 'minibuffer-pairs "'" nil :actions nil)
      (sp-local-pair 'minibuffer-pairs "`" nil :actions nil)
      (sp-update-local-pairs 'minibuffer-pairs)
      (smartparens-strict-mode 1))
    (add-to-list 'sp-lisp-modes 'fennel-mode t)
    (require 'smartparens-config)
    (defun aorst/enable-smartparens ()
      (smartparens-mode 1)
      (show-smartparens-mode 1))
    (defun aorst/enable-smartparens-strict ()
      (smartparens-strict-mode 1)
      (show-smartparens-mode 1))
    (sp-with-modes '(fennel-mode)
      (sp-local-pair "`" "`"
                     :when '(sp-in-string-p
                             sp-in-comment-p)
                     :unless '(sp-lisp-invalid-hyperlink-p)))
    (sp-use-paredit-bindings)
    (defun aorst/wrap-fix-cursor-position (_ action _)
      "Set cursor position inside expression when wrapping."
      (when (and (eq action 'wrap)
                 (eq (point)
                     (marker-position (sp-get sp-last-wrapped-region :beg))))
        (goto-char (sp-get sp-last-wrapped-region :beg-in))))
    (dolist (paren '("(" "[" "{"))
      (sp-pair paren nil :post-handlers '(:add aorst/wrap-fix-cursor-position))))
#+end_src

** Flx
Flex matching for Emacs.

#+begin_src emacs-lisp
  (use-package flx)
#+end_src

** Ivy and Counsel
Ivy is a narrowing framework like Helm, but much lighter in my experience.
It integrates with Counsel that handles minibuffer, so let's install it too.

#+begin_src emacs-lisp
  (use-package ivy
    :commands ivy-mode
    :hook ((minibuffer-setup . aorst/minibuffer-defer-garbage-collection)
           (minibuffer-exit . aorst/minibuffer-restore-garbage-collection))
    :bind (("C-x b" . ivy-switch-buffer)
           ("C-x C-b" . ivy-switch-buffer))
    :custom-face
    (ivy-org ((t (:inherit default))))
    :custom
    (ivy-count-format "")
    (ivy-ignore-buffers '("\\` " "\\`\\*"))
    (ivy-display-style nil)
    (ivy-minibuffer-faces nil)
    (ivy-minibuffer-faces '(default default default default))
    (ivy-use-virtual-buffers t)
    (enable-recursive-minibuffers t)
    :init
    (setq ivy-re-builders-alist '((t . ivy--regex-fuzzy)))
    (defun aorst/minibuffer-defer-garbage-collection ()
      "Defer garbage collection for minibuffer"
      (setq gc-cons-threshold most-positive-fixnum))
    (defun aorst/minibuffer-restore-garbage-collection ()
      "Resotre garbage collection settings."
      (run-at-time
       1 nil (lambda () (setq gc-cons-threshold aorst--gc-cons-threshold))))
    (ivy-mode 1))
#+end_src

I'm using [[https://github.com/sharkdp/fd][fd]] as a great replacement for GNU Find.
It's fast and it takes =.gitignore= into account.
Counsel has nice =counsel-file-fump= command that uses =find-program= variable, so we can advice it in order for it to use =fd=.
The same thing is for =rg=, but counsel actually has it's own variable for it, so we do no need to runtime-patch it.

#+begin_src emacs-lisp
  (use-package counsel
    :commands (counsel-M-x
               counsel-find-file
               counsel-file-jump
               counsel-recentf
               counsel-rg
               counsel-describe-function
               counsel-describe-variable
               counsel-faces
               counsel-find-library)
    :bind (("M-x" . counsel-M-x)
           ("C-x C-f" . counsel-find-file)
           ("C-x f" . counsel-file-jump)
           ("C-x C-r" . counsel-recentf)
           ("C-x d" . counsel-dired)
           ("C-h f" . counsel-describe-function)
           ("C-h C-f" . counsel-faces)
           ("C-h v" . counsel-describe-variable)
           ("C-h l" . counsel-find-library))
    :config
    (when (executable-find "fd")
      (define-advice counsel-file-jump (:around (foo &optional initial-input initial-directory) aorst:counsel-fd)
        (let ((find-program "fd")
              (counsel-file-jump-args (split-string "-L --type f --hidden")))
          (funcall foo initial-input initial-directory))))
    (when (executable-find "rg")
      (setq counsel-rg-base-command
            "rg -S --no-heading --hidden --line-number --color never %s .")))
#+end_src

** Company
Complete anything framework. Nothing much to say. Does it's job.

#+begin_src emacs-lisp
  (use-package company
    :bind (:map company-active-map
           ("TAB" . company-complete-common-or-cycle)
           ("<tab>" . company-complete-common-or-cycle)
           ("<S-Tab>" . company-select-previous)
           ("<backtab>" . company-select-previous)
           ("C-n" . company-select-next)
           ("C-p" . company-select-previous))
    :hook (after-init . global-company-mode)
    :custom
    (company-require-match 'never)
    (company-minimum-prefix-length 2)
    (company-tooltip-align-annotations t)
    (company-frontends '(company-pseudo-tooltip-unless-just-one-frontend
                         company-preview-frontend
                         company-echo-metadata-frontend))
    (company-backends '(company-capf company-files))
    (company-tooltip-minimum-width 30)
    (company-tooltip-maximum-width 60))
#+end_src

This package also optionally requires these extra dependencies:

*** Company Posframe
Provides posframe frontend for company.

#+begin_src emacs-lisp
  (use-package company-posframe
    :after company
    :custom
    (company-posframe-quickhelp-show-header nil)
    (company-posframe-show-indicator nil)
    (company-posframe-show-metadata nil)
    (company-posframe-quickhelp-show-params
     (list :poshandler #'company-posframe-quickhelp-right-poshandler
           :internal-border-width 1
           :timeout 60
           :internal-border-color (face-attribute 'mode-line :background)
           :no-properties nil))
    (company-posframe-show-params
     (list :poshandler #'company-posframe-quickhelp-right-poshandler
           :internal-border-width 1
           :timeout 60
           :internal-border-color (face-attribute 'mode-line :background)
           :no-properties nil))
    :config
    (company-posframe-mode))
#+end_src

** Undo Tree
This is more familiar undo mode.
It adds =C-/= mapping to undo and =C-?= mapping to redo.
I also map convenient =C-z= and =C-S-z= maps, because sometimes when someone else sits at my PC (for pair programming for example), and forgets that this is Emacs, and hits =C-z= thus minimizing the frame, and being frustrated.

#+begin_src emacs-lisp
  (use-package undo-tree
    :commands global-undo-tree-mode
    :bind (("C-z" . undo-tree-undo)
           ("C-S-z" . undo-tree-redo))
    :init (global-undo-tree-mode 1))
#+end_src

** Yasnippet
Another very handy package, that helps insert templates of code.
Now I really need to write some snippets to use.
Also has nice collection as a separate package

#+begin_src emacs-lisp
  (use-package yasnippet
    :config
    (add-to-list 'yas-key-syntaxes 'yas-shortest-key-until-whitespace))
#+end_src

** Magit
Emacs interface to Git.
I've heard that it has many nice features, so I want to try it out.

#+begin_src emacs-lisp
  (use-package with-editor)
  (use-package magit
    :hook (git-commit-mode . flyspell-mode)
    :bind (("<f12>" . magit-status))
    :custom
    (magit-ediff-dwim-show-on-hunks t)
    (magit-diff-refine-ignore-whitespace nil)
    (magit-diff-refine-hunk 'all)
    (magit-blame-styles
     '((headings
        (heading-format . "%-20a %C %s\n"))
       (margin
        (margin-format " %s%f" " %C %a" " %H")
        (margin-width . 42)
        (margin-face . magit-blame-margin)
        (margin-body-face magit-blame-dimmed))
       (highlight
        (highlight-face . magit-blame-highlight))
       (lines
        (show-lines . nil)
        (show-message . t))))
    :config
    (advice-add 'magit-set-header-line-format :override #'ignore))
#+end_src

*** Magit TODOs
Display TODO items in Magit buffers.

#+begin_src emacs-lisp
  (use-package magit-todos
    :after magit
    :init
    ;; don't break Magit on systems that don't have `nice'
    (unless (executable-find "nice")
      (setq magit-todos-nice nil))
    :config
    (let ((inhibit-message t))
      (magit-todos-mode 1))
    (transient-append-suffix 'magit-status-jump '(0 0 -1)
      '("T " "Todos" magit-todos-jump-to-todos)))
#+end_src

** Ediff
This is a built in mode for diffing files in Emacs.

#+begin_src emacs-lisp
  (use-package ediff
    :straight nil
    :hook ((ediff-before-setup . aorst/store-pre-ediff-winconfig)
           (ediff-quit . aorst/restore-pre-ediff-winconfig)
           (ediff-keymap-setup . aorst/ediff-setup-keys))
    :config
    (advice-add 'ediff-window-display-p :override #'ignore)
    :custom
    (ediff-split-window-function 'split-window-horizontally)
    :init
    (defvar aorst--ediff-last-windows nil
      "Stores window configuration before `ediff' was invoked.")
    (defun aorst/store-pre-ediff-winconfig ()
      (setq aorst--ediff-last-windows (current-window-configuration)))
    (defun aorst/restore-pre-ediff-winconfig ()
      (set-window-configuration aorst--ediff-last-windows))
    (defun aorst/ediff-copy-both-to-C ()
      (interactive)
      (ediff-copy-diff ediff-current-difference nil 'C nil
                       (concat
                        (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
                        (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))
    (defun aorst/ediff-setup-keys ()
      (define-key ediff-mode-map "d" #'aorst/ediff-copy-both-to-C)))
#+end_src

** Diff
Some tweaks to inbuilt diff mode.

#+begin_src emacs-lisp
  (use-package diff
    :straight nil
    :after magit
    :hook (aorst--theme-change . aorst/diff-setup-faces)
    :custom-face
    (diff-added ((t (:foreground unspecified
                     :background unspecified
                     :inherit magit-diff-added-highlight))))
    (diff-removed ((t (:foreground unspecified
                       :background unspecified
                       :inherit magit-diff-removed-highlight))))
    :config
    (defun aorst/diff-setup-faces ()
      (dolist (face-reference '((diff-refine-added magit-diff-added-highlight)
                                (diff-refine-removed magit-diff-removed-highlight)))
        (apply #'aorst/create-accent-face face-reference)))
    (aorst/diff-setup-faces))
#+end_src

** Smerge
Some tweaks to inbuilt merge tool:

#+begin_src emacs-lisp
  (use-package smerge-mode
    :straight nil
    :after magit
    :hook (aorst--theme-change . aorst/smerge-setup-faces)
    :custom-face
    (smerge-refined-added ((t (:foreground unspecified
                               :distant-foreground unspecified
                               :background unspecified
                               :inherit magit-diff-added-highlight))))
    (smerge-refined-removed ((t (:foreground unspecified
                                 :distant-foreground unspecified
                                 :background unspecified
                                 :inherit magit-diff-removed-highlight))))
    (smerge-lower ((t (:foreground unspecified
                       :distant-foreground unspecified
                       :background unspecified
                       :inherit magit-diff-added-highlight))))
    (smerge-upper ((t (:foreground unspecified
                       :distant-foreground unspecified
                       :background unspecified
                       :inherit magit-diff-removed-highlight))))
    (smerge-markers ((t (:foreground unspecified
                         :distant-foreground unspecified
                         :background unspecified
                         :weight bold
                         :extend t
                         :inherit font-lock-comment-face))))
    :config
    (defun aorst/smerge-setup-faces ()
      (dolist (face-reference '((smerge-refined-added magit-diff-added-highlight)
                                (smerge-refined-removed magit-diff-removed-highlight)))
        (apply #'aorst/create-accent-face face-reference)))
    (aorst/smerge-setup-faces))
#+end_src

** Multiple Cursors
This package provides multiple cursors functionality to Emacs.
It isn't much like Kakoune's multiple selections, but anything will do.
I guess I'll figure out best mappings over time.

#+begin_src emacs-lisp
  (use-package phi-search)
  (use-package mc-extras)
  (use-package multiple-cursors
    :commands (mc/cycle-backward
               mc/cycle-forward)
    :bind (("S-<mouse-1>" . mc/add-cursor-on-click)
           ("C-c m" . hydrant/mc/body)
           :map mc/keymap
           ("<return>" . nil)
           ("C-s" . phi-search)
           ("C-r" . phi-search-backward))
    :config
    (when (fboundp #'defhydra)
      (defhydra hydrant/mc (:hint nil :color pink)
        "
   ^Select^                 ^Discard^                      ^Edit^               ^Navigate^
   _M-s_: split lines       _M-SPC_:  discard current      _&_: align           _(_: cycle backward
   _s_:   select regexp     _b_:      discard blank lines  _#_: insert numbers  _)_: cycle forward
   _n_:   select next       _d_:      remove duplicated    ^ ^                  ^ ^
   _p_:   select previous   _q_ or _g_: exit hydrant       ^ ^                  ^ ^
   _C_:   select next line  _G_:      exit mc mode"
        ("M-s" mc/edit-ends-of-lines)
        ("s" mc/mark-all-in-region-regexp)
        ("n" mc/mark-next-like-this-word)
        ("p" mc/mark-previous-like-this-word)
        ("&" mc/vertical-align-with-space)
        ("(" mc/cycle-backward)
        (")" mc/cycle-forward)
        ("M-SPC" mc/remove-current-cursor)
        ("b" mc/remove-cursors-on-blank-lines)
        ("d" mc/remove-duplicated-cursors)
        ("C" mc/mark-next-lines)
        ("#" mc/insert-numbers)
        ("q" mc/remove-duplicated-cursors :exit t)
        ("g" mc/remove-duplicated-cursors :exit t)
        ("G" mc/keyboard-quit :exit t))))
#+end_src

** Expand Region
Expand or reduce region selection semantically.
Supports most languages that I work with inside Emacs.

#+begin_src emacs-lisp
  (use-package expand-region
    :bind (("C-c e" . hydrant/er/body))
    :config
    (when (fboundp #'defhydra)
      (defhydra hydrant/er (:color pink :hint nil)
        "
   ^Expand/Discard^                ^Mark^
   _e_:      expand region         _(_: inside pairs
   _r_:      reduce region         _)_: around pairs
   _g_ or _q_: exit hydrant          _'_: inside quotes
   _G_:      discard region, exit  _\"_: around quotes
   ^ ^  ^ ^                          _p_: paragraph"
        ("e" er/expand-region)
        ("r" er/contract-region)
        ("p" er/mark-paragraph)
        ("(" er/mark-inside-pairs)
        (")" er/mark-outside-pairs)
        ("'" er/mark-inside-quotes)
        ("\"" er/mark-outside-quotes)
        ("g" ignore :exit t)
        ("q" ignore :exit t)
        ("G" (lambda () (interactive) (deactivate-mark t)) :exit t)
        ("Q" (lambda () (interactive) (deactivate-mark t)) :exit t))))
#+end_src

** Iedit Mode
Another package for multiple editing purposes, that is kinda faster than multiple cursors, but can edit only fixed width regions of text and has less abilities regarding to commands.
Still pretty usable though, as multiple cursor some times looses cursors for some reason.

#+begin_src emacs-lisp
  (use-package iedit
    :bind (("M-n" . aorst/iedit-current-or-expand)
           ("C-c i" . aorst/iedit-hydrant))
    :custom
    (iedit-toggle-key-default nil)
    :custom-face
    (iedit-occurrence ((t (:background unspecified
                           :foreground unspecified
                           :inverse-video unspecified
                           :inherit region))))
    :init
    (defun aorst/iedit-to-mc-hydrant ()
      "Calls `iedit-to-mc-mode' and opens hydra for multiple cursors."
      (interactive)
      (iedit-switch-to-mc-mode)
      (hydrant/mc/body))
    (defun aorst/iedit-current-or-expand (&optional arg)
      "Select only currnent occurrence with `iedit-mode'.  Expand to
    next occurrence if `iedit-mode' is already active."
      (interactive "P")
      (if (bound-and-true-p iedit-mode)
          (if (symbolp arg)
              (iedit-expand-down-to-occurrence)
            (iedit-expand-up-to-occurrence))
        (iedit-mode 1)))
    (when (fboundp #'defhydra)
      (defhydra hydrant/iedit (:hint nil :color pink)
        "
   ^Select^                  ^Discard^                   ^Edit^               ^Navigate^
   _n_: next occurrence      _M-SPC_:  toggle selection  _u_: uppercase       _(_: previous selection
   _p_: previous occurrence  _q_ or _g_: exit hydrant      _d_: downcase        _)_: next selection
   ^ ^                       _G_:      exit iedit-mode   _#_: insert numbers
   ^ ^                       _m_:      switch to mc"
        ("n" iedit-expand-down-to-occurrence)
        ("m" aorst/iedit-to-mc-hydrant :exit t)
        ("p" iedit-expand-up-to-occurrence)
        ("u" iedit-upcase-occurrences)
        ("d" iedit-downcase-occurrences)
        ("#" iedit-number-occurrences)
        ("(" iedit-prev-occurrence)
        (")" iedit-next-occurrence)
        ("M-SPC" iedit-toggle-selection)
        ("q" ignore :exit t)
        ("g" ignore :exit t)
        ("G" (lambda () (interactive) (iedit-mode -1)) :exit t))
      (defun aorst/iedit-hydrant ()
        "toggle iedit mode for item under point, and open `hydrant/iedit'."
        (interactive)
        (ignore-errors
          (unless (bound-and-true-p iedit-mode)
            (iedit-mode 1))
          (hydrant/iedit/body)))))
#+end_src

** LSP
Packages providing integration with Language Server Protocol.

*** LSP Mode
LSP client for Emacs.

#+begin_src emacs-lisp
  (use-package lsp-mode
    :hook (((rust-mode c-mode c++-mode java-mode elixir-mode) . lsp)
           (lsp-mode . yas-minor-mode))
    :custom-face
    (lsp-modeline-code-actions-face ((t (:inherit mode-line))))
    :custom
    (lsp-enable-links nil)
    (lsp-keymap-prefix "C-c l")
    (lsp-rust-clippy-preference "on")
    (lsp-prefer-capf t)
    (lsp-enable-indentation nil)
    (lsp-enable-symbol-highlighting t)
    (lsp-rust-server 'rust-analyzer)
    (lsp-session-file (expand-file-name ".lsp-session" user-emacs-directory))
    (lsp-headerline-breadcrumb-enable nil))
#+end_src

*** LSP UI
User interface package for LSP.
This package provides documentation popup, definitions in split-view, imenu list, e.t.c.

#+begin_src emacs-lisp
  (use-package lsp-ui
    :after lsp-mode
    :commands lsp-ui-mode
    :bind (:map lsp-ui-mode-map
           ("M-." . lsp-ui-peek-find-definitions)
           ("M-/" . lsp-ui-peek-find-references))
    :custom
    (lsp-ui-doc-border (face-attribute 'mode-line-inactive :background))
    (lsp-ui-sideline-enable nil)
    (lsp-ui-imenu-enable nil)
    (lsp-ui-doc-delay 1 "higher than eldoc delay")
    (lsp-ui-doc-position 'at-point)
    :config
    (when (fboundp #'aorst/escape)
      (define-advice lsp-ui-doc--make-request (:around (foo) aorst:hide-lsp-ui-doc)
        (unless (eq this-command 'aorst/escape)
          (funcall foo))))
    (lsp-ui-mode))
#+end_src

*** LSP Java
In order to use Java Language Server we need this package.
However, language server requires JDK 11 to run, so we only load it when JDK 11 is available.

#+begin_src emacs-lisp
  (use-package lsp-java
    :when (file-exists-p "/usr/lib/jvm/java-11-openjdk/bin/java")
    :custom (lsp-java-java-path "/usr/lib/jvm/java-11-openjdk/bin/java"))
#+end_src

*** DAP Mode
Debug Adapter Protocol support for Emacs.

#+begin_src emacs-lisp
  (use-package dap-mode
    :hook (lsp-mode . dap-mode))
#+end_src

** Project
I do not want to use projectile, since Emacs already features =project.el= and many packages use it.
Although I've needed to create my own function that searches for correct project root.
So first we need a list of project root markers, that will hold file names which we will look up recursively.
We need a function that will test current directory for several conditions, like does it have any of project markers, is it root directory, and if everything fails, it will go up one directory and repeat.

#+begin_src emacs-lisp
  (use-package project
    :straight nil
    :bind (("C-c p f" . project-find-file)
           ("C-c p r" . project-find-regexp))
    :config
    (defvar aorst--project-root-markers
      '("Cargo.toml" "compile_commands.json" "compile_flags.txt" "project.clj")
      "Files or directories that indicate the root of a project.")
    (defun aorst/project-find-root (path)
      "Recursive search in PATH for root markers."
      (let ((this-dir (file-name-as-directory (file-truename path))))
        (cond
         ((aorst/project-root-p this-dir) (cons 'transient this-dir))
         ((equal "/" this-dir) nil)
         (t (aorst/project-find-root (concat this-dir "../"))))))
    (defun aorst/project-root-p (path)
      "Check if current PATH has any of project root markers."
      (memq t (mapcar (lambda (file)
                        (file-exists-p (concat path file)))
                      aorst--project-root-markers)))
    (add-to-list 'project-find-functions #'aorst/project-find-root))
#+end_src

** Clang Format
A package to format C code with Clang Format.

#+begin_src emacs-lisp
  (use-package clang-format
    :after cc-mode
    :bind (:map c-mode-base-map
           ("C-c C-M-f" . clang-format-buffer)))
#+end_src
p
** Server
I'm using =server-start= command not because I do not want to load my Emacs every time, but because I want to have single instance of Emacs running at a time, so all files that I open from GUI will be opened in existing Emacs.
If no Emacs exist, it should start one, start a server and open a file.

#+begin_src emacs-lisp
  (use-package server
    :straight nil
    :config
    (unless (server-running-p)
      (server-start)))
#+end_src

We also need a launcher for Emacs, that will decide what to run - a client, or a server:

#+begin_src sh :tangle ~/.local/bin/emacs-launcher :mkdirp yes :shebang #!/bin/sh
if [ $# -gt 0 ]; then
    exec emacsclient -a emacs -n "$@"
else
    exec command emacs
fi
#+end_src

This will allow us to open files with =emacs-launcher=, and it will automatically reuse existing window if present.
Precisely what it does is:

- call =emacs= if no arguments provided, or
- call =emacsclient -a emacs= with arguments.
  =emacsclient= will try to connect to a server, and if there's none, it will fire up =emacs= which will create server, and opening new files will be done in this instance of =emacs=.

However it is clumsy to do this from the shell, and I want this to be available in file managers.
So to fully achieve this behavior we need a =.desktop= file, that will call our =emacs-launcher= and pass arguments to it:

#+begin_src conf-xdefaults :tangle ~/.local/share/applications/emacs.desktop :mkdirp yes
  [Desktop Entry]
  Name=Emacs
  GenericName=Text Editor
  Comment=Edit text
  MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
  Exec=emacs-launcher %F
  Icon=emacs
  Type=Application
  Terminal=false
  Categories=Development;TextEditor;Utility;
  StartupWMClass=Emacs
#+end_src

With this file we should be able to launch Emacs from the file context menu, or whit "open with" sub menu, and it will reuse existing window if present.

** Hideshow
This built in mode provides code folding.
I use =transient= to create little interactive menu for easy interaction.

#+begin_src emacs-lisp
  (use-package hideshow
    :straight nil
    :after transient
    :hook (prog-mode . hs-minor-mode)
    :bind (:map prog-mode-map
           ("<f6>" . hydrant/hideshow-menu/body))
    :config
    (when (fboundp #'defhydra)
      (defhydra hydrant/hideshow-menu (:color pink :hint nil)
        "
   ^Hide^       ^Show^       ^Exit^
   _ha_: all    _sa_: all    _qs_: quit show all
   _hb_: block  _sb_: block  _qh_: quit hide all
   ^  ^         ^  ^         _qq_: quit"
        ("ha" hs-hide-all)
        ("hb" hs-hide-block)
        ("sa" hs-show-all)
        ("sb" hs-show-block)
        ("qq" ignore :exit t)
        ("qs" hs-show-all :exit t)
        ("qh" hs-hide-all :exit t))))
#+end_src

** COMMENT Desktop
This is really nice feature that allows me to save my workspace on disk and do not restore all buffers and windows every time I start Emacs.
It adds some time to the startup though.

#+begin_src emacs-lisp
  (use-package desktop
    :straight nil
    :if window-system
    :hook ((after-init . aorst/desktop-restore))
    :custom
    (desktop-path `(,user-emacs-directory))
    (desktop-dirname user-emacs-directory)
    (desktop-base-file-name "desktop")
    (desktop-base-lock-name "desktop.lock")
    (desktop-save t)
    (desktop-load-locked-desktop t)
    (desktop-locals-to-save nil)
    (desktop-globals-to-save nil)
    (desktop-restore-frames nil)
    :config
    (dolist (mode '(solaire-mode
                    parinfer-rust-mode
                    global-diff-hl-mode
                    diff-hl-mode
                    diff-hl-flydiff-mode
                    diff-hl-margin-mode))
      (add-to-list 'desktop-minor-mode-table `(,mode ,nil)))
    :init
    (defun aorst/desktop-restore ()
      "Restore a saved emacs session."
      (interactive)
      (desktop-save-mode t)
      (when (file-exists-p
             (concat desktop-dirname desktop-base-file-name))
        (desktop-read))))
#+end_src

I wonder if it could store unsaved buffers so all my changes persist through sessions.

** Edit Indirect
This package makes it possible to edit Markdown code blocks in separate buffers.

#+begin_src emacs-lisp
  (use-package edit-indirect
    :hook ((edit-indirect-after-creation . aorst/edit-indirect-header-line-setup))
    :bind (:map edit-indirect-mode-map
           ("C-c C-c" . edit-indirect-commit)
           ("C-c C-k" . edit-indirect-abort)
           ("C-c '" . nil))
    :config
    (defun aorst/edit-indirect-header-line-setup ()
      (setq-local
       header-line-format
       (substitute-command-keys
        "\\<edit-indirect-mode-map>Edit, then exit with `\\[edit-indirect-commit]' or abort with `\\[edit-indirect-abort]'"))))
#+end_src

** Separedit
This package provides a way to edit comments in sources as separate buffers with another major mode, like Markdown.

#+begin_src emacs-lisp
  (use-package separedit
    :hook (separedit-buffer-creation . aorst/separedit-header-line-setup)
    :bind (:map prog-mode-map
           ("C-c '" . separedit)
           :map edit-indirect-mode-map
           ("C-c '" . separedit))
    :custom
    (separedit-default-mode 'gfm-mode)
    :config
    (defun aorst/separedit-header-line-setup ()
      (setq-local
       header-line-format
       (substitute-command-keys
        "\\<edit-indirect-mode-map>Edit, then exit with `\\[separedit-commit]' or abort with `\\[edit-indirect-abort]'"))))
#+end_src

** Recent files
Settings to =recentf= mode.

#+begin_src emacs-lisp
  (use-package recentf
    :straight nil
    :config
    (add-to-list 'recentf-exclude "\\.gpg\\"))
#+end_src

** Dumb Jump
Dumbest definition jumping that just work.

#+begin_src emacs-lisp
  (use-package dumb-jump
    :custom (dumb-jump-prefer-searcher 'rg)
    :config
    (add-to-list 'xref-backend-functions #'dumb-jump-xref-activate))
#+end_src

** Which Key
A useful package that displays all keybindings available for the chord you're entering after a certain delay.

#+begin_src emacs-lisp
  (use-package which-key
    :config (which-key-mode t))
#+end_src

** GCMH
Garbage Collector Magic Hack.
Runs GC when Emacs is idle, and increases GC threshold during active use.

#+begin_src emacs-lisp
  (use-package gcmh
    :config (gcmh-mode t))
#+end_src

** COMMENT Indent Guides
Indentation guides for Emacs.

#+begin_src emacs-lisp
  (use-package highlight-indent-guides
    :hook ((prog-mode . highlight-indent-guides-mode)
           (aorst--theme-change . aorst/indent-guides-setup-faces))
    :custom
    (highlight-indent-guides-method 'character)
    (highlight-indent-guides-character ?▏) ;; ┊│┆▏
    (highlight-indent-guides-bitmap-function #'aorst/indent-guides-thin-line)
    (highlight-indent-guides-responsive 'top)
    (highlight-indent-guides-delay 0)
    :config
    (defun aorst/indent-guides-setup-faces ()
      (mapc (lambda (buffer)
              (with-current-buffer buffer
                (when highlight-indent-guides-mode
                  (highlight-indent-guides-mode -1)
                  (highlight-indent-guides-mode 1))))
            (buffer-list)))
    (defun aorst/indent-guides-thin-line (width height crep zrep)
      "Defines a solid guide line, one pixel wide."
      (let* ((right (- width 2))
             (row (append (make-list 1 zrep) (make-list 1 crep) (make-list right zrep)))
             rows)
        (dotimes (i height rows)
          (setq rows (cons row rows))))))
#+end_src

** Parens
Some tweaks to inbuilt parenthesis highlighting mode.

#+begin_src emacs-lisp
  (use-package paren
    :straight nil
    :custom
    (show-paren-when-point-in-periphery t)
    (show-paren-delay 0))
#+end_src

** COMMENT Fill column indicator
Emacs 27 added direct support for fill column indicator, which displays thin line at the desired column.

#+begin_src emacs-lisp
  (use-package display-fill-column-indicator
    :straight nil
    :hook ((aorst--theme-change . aorst/display-fill-column-indicator-setup-faces)
           (prog-mode . display-fill-column-indicator-mode))
    :custom
    (display-fill-column-indicator-character ?▏)
    (display-fill-column-indicator-column 120)
    :config
    (defun aorst/display-fill-column-indicator-setup-faces ()
      (if (eq (frame-parameter nil 'background-mode) 'dark)
          (set-face-attribute 'fill-column-indicator nil
                              :foreground "gray30"
                              :distant-foreground "gray30"
                              :inherit nil)
        (set-face-attribute 'fill-column-indicator nil
                            :foreground "gray80"
                            :distant-foreground "gray80"
                            :inherit nil)))
    (aorst/display-fill-column-indicator-setup-faces))
#+end_src

** Writable Grep
This package provides a way of editing grep buffer and applying edits to the files.
Extremely useful with ivy-occur.

#+begin_src emacs-lisp
  (use-package wgrep)
#+end_src

** Xref
Workaround for a problem with Treemacs and marker stack: [[https://github.com/Alexander-Miller/treemacs/issues/734][Alexander-Miller/treemacs#734]].

#+begin_src emacs-lisp
  (use-package xref
    :straight nil
    :config
    (define-advice xref-push-marker-stack (:around (fn &optional m) aorst:remove-treemacs-from-xref-marker-stack)
      (let ((m (or m (point-marker))))
        (when (buffer-local-value 'treemacs--in-this-buffer (marker-buffer m))
          (with-current-buffer (window-buffer (next-window (selected-window) nil nil))
            (setf m (point-marker))))
        (funcall fn m))))
#+end_src

** VC mode
Tweaks for inbuild VC mode.

#+begin_src emacs-lisp
(use-package vc-hooks
  :straight nil
  :custom (vc-follow-symlinks t))
#+end_src

** Quail
I don't know what this thing is, but the completion buffer drives me crazy.

#+begin_src emacs-lisp
  (use-package quail
    :straight nil
    :config
    (defun aorst/hide-quail-buffer ()
      "Hide Quail buffer."
      (with-current-buffer quail-completion-buf
        (when (string= "*Quail Completions*" (buffer-name))
          (rename-buffer " *Quail Completions*"))))
    (define-advice quail-setup-completion-buf (:after () aorst:hide-quail-buffer)
      (aorst/hide-quail-buffer)))
#+end_src

** Ripgrep
Nice integration for [[https://github.com/BurntSushi/ripgrep][ripgrep]] tool.

#+begin_src emacs-lisp
  (use-package rg
    :bind ("C-c r" . rg))
#+end_src

* Postscript
This Emacs Configuration features various cool E-Lisp hacks that I've found over the Internet.
I try to keep references to original places because I want to credit original author, and because I alter these pieces of code for my personal needs, and it is good to have the original source.

If you find any issue with my config feel free to [[https://github.com/andreyorst/dotfiles/issues/new][file an issue]] or contact me via email: [[mailto:andreyorst@gmail.com][andreyorst@gmail.com]].

And as a final step of a proper init file:

#+begin_src emacs-lisp
  (provide 'init)
  ;;; init.el ends here
#+end_src

Thanks for reading!

#  LocalWords:  init el startup GC unstyled UI Resizing resized ELPA
#  LocalWords:  MELPA uncomment Makefile Readline Kakoune whitespace
#  LocalWords:  Solaire DOOM's fallbacks doto Clojure Tooltips DejaVu
#  LocalWords:  tooltips Treemacs Flycheck modeline minibuffer config
#  LocalWords:  filetree Uniquify Tabline Prog TOML Geiser REPL Cmake
#  LocalWords:  cmake Yaml IDE ClojureScript flycheck clj kondo Kibit
#  LocalWords:  backend refactor refactoring linter Lua CSS Erlang VM
#  LocalWords:  scalable interop JSON Json vterm EditorConfig Paredit
#  LocalWords:  Smartparens Parinfer configs Flx runtime Posframe LSP
#  LocalWords:  posframe frontend Yasnippet Magit TODOs TODO Ediff
#  LocalWords:  Kakoune's Iedit DAP Hideshow workspace Separedit GCMH
#  LocalWords:  Parens readonly
