#+title: Emacs configuration with Org Mode
#+author: Andrey Orst
#+email: andreyorst@gmail.com
#+setupfile: ~/.emacs.d/.org-defaults.org
#+startup: noinlineimages
#+property: header-args :tangle "~/.emacs.d/init.el"

[[file:.screenshot.png]]

* About this document
This is my Emacs configuration file written as Org document.  I do all
edits here,  then /compile/ it to  =init.el= file. Emacs is  complex tool,
and  by  having my  configuration  in  Org  Mode,  I can  separate  my
configuration  in sections,  comment  each  configuration, and  toggle
configuration parts on and off with ease.

I  try to  maintain my  Emacs  configuration simple,  fast, and  small
keeping as much  of vanilla Emacs behaviors  as I can, but  I'm a sane
person so  some aspects which  are actually  insane in my  opinion are
changed.

Org Mode has a function  called =org-babel-tangle= that exports all code
blocks accordingly to =header-args= property. Calling this function with
this file as an argument will result in creation of =init.el= located at
=.emacs.d= in  your home directory. This  means that you only  need this
file  in order  to  get my  Emacs configuration  and  compile it  with
=org-babel-tangle= function for the first  time.  After that, every time
this file is saved it gets re-tangled automatically.

Since I'm  trying to  follow Emacs conventions,  good Emacs  Lisp file
starts with commentary:

#+BEGIN_SRC emacs-lisp
  ;;; init.el --- Emacs main configuration file -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-
  ;;;
  ;;; Commentary:
  ;;; Emacs config by Andrey Orst.
  ;;; This file was automatically generated by `org-babel-tangle'.
  ;;; Do not change this file.  Main config is located in .emacs.d/config.org
  ;;;
  ;;; Code:
#+END_SRC

After this  point configurations will  be split in  different sections
grouped by something common to them all.

* Startup
Emacs starts fast, but as amount of packages grows it gets slower. The
init time is important  because I like to close it  when I'm not using
it. I'm not  closing and opening it  for every file, or  like every 15
minutes, but still, the faster it starts - the better for me.

Once I switch  to Emacs 27 most  of these settings will  be tangled to
=early-init.el=.

** Garbage collection and file handler
The  main  problem  with  Emacs startup  file  is  garbage  collection
system. It invoked  so many times on startup that  it causes quite big
impact on startup  time.  We're talking /seconds/.  One  can raise limit
when to trigger garbage collection, but this will end up in unpleasant
editing experience. So I'm declaring  these variables to store default
values for the GC, to restore them after initialization is finished:

#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/early-init.el"
  (defvar my--gc-cons-threshold gc-cons-threshold)
  (defvar my--gc-cons-percentage gc-cons-percentage)
  (defvar my--file-name-handler-alist file-name-handler-alist)
#+END_SRC

Now we can tweak GC. We need to raise threshold to prevent it running:

#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/early-init.el"
  (setq gc-cons-threshold 402653184
        gc-cons-percentage 0.6
        inhibit-compacting-font-caches t
        message-log-max 16384
        file-name-handler-alist nil)
#+END_SRC

Then we need  a hook that restores initial  values once initialization
done:

#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/early-init.el"
  (add-hook 'after-init-hook
            (lambda ()
              (setq gc-cons-threshold my--gc-cons-threshold
                    gc-cons-percentage my--gc-cons-percentage
                    file-name-handler-alist my--file-name-handler-alist)))
#+END_SRC

Prevent the glimpse of un-styled  Emacs by disabling these UI elements
early.

#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/early-init.el"
  (push '(menu-bar-lines . 0) default-frame-alist)
  (push '(tool-bar-lines . 0) default-frame-alist)
  (push '(vertical-scroll-bars) default-frame-alist)
#+END_SRC
=package.el= initialization is expensive so we disable it at startup:

#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/early-init.el"
  (defvar package--init-file-ensured)
  (setq package-enable-at-startup nil
        package--init-file-ensured t)
#+END_SRC

* Default Behavior Fixes
Emacs is  old. I  understand that  back then  it could  be appropriate
decisions,  but as  of today  they are  completely obliterated  by the
passage of time.

** Bell
I'm not  trying to  insult on anyone,  but usage of  the bell  is just
insane. It's  not 1980's, computers  have their own speakers  and rich
displays, why would anyone want  to use builtin speaker?  Why everyone
should know when I'm mistaken? Disable bell.

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

** Backups
I don't  know who decided  that having backups  all over the  place is
good idea, but I don't think alike.

#+BEGIN_SRC emacs-lisp
  (setq backup-by-copying t
        create-lockfiles nil
        backup-directory-alist '(("." . "~/.cache/emacs-backups"))
        auto-save-file-name-transforms '((".*" "~/.cache/emacs-backups" t)))
#+END_SRC

** Yes Or No
For some  reason in some  situations Emacs asks  for typing =yes=  or =no=
explicitly, instead of accepting =y= or =n=. This can be fixed with this.

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Echo Keystrokes
Emacs displays pressed  key after some time but it's  too fast for me,
because I use Emacs on the phone  too, and the keyboard is a bit small
for lightning fast typing.

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook (lambda () (setq echo-keystrokes 5)))
#+END_SRC

** Mouse and Scrolling
I don't want menus on shift clicks:

#+BEGIN_SRC emacs-lisp
  (global-unset-key (kbd "S-<down-mouse-1>"))
  (global-unset-key (kbd "<mouse-3>"))
  (global-unset-key (kbd "S-<mouse-3>"))
#+END_SRC

I  don't like  how  Emacs  handles scrolling,  and  that  it uses  tab
characters by default.  I need tab  characters only when I work with C
code and Makefile rules.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil
                scroll-step 1
                mouse-wheel-progressive-speed nil
                auto-window-vscroll nil)
#+END_SRC

** Custom File
I  don't like  custom,  and  especially would  like  to  stop it  from
interfering to  my configuration  files, so lets  move it  to separate
file.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file :noerror)
#+END_SRC

I also don't like that Emacs  has disabled commands, and enabling them
modifies  my =init.el=  that I  don't  modify myself.   Let's put  those
commands to =custom-file= instead:

#+BEGIN_SRC emacs-lisp
  (defvar disabled-commands (expand-file-name ".disabled.el" user-emacs-directory)
    "File to store disabled commands, that were enabled permamently.")
  (defadvice en/disable-command (around put-in-custom-file activate)
    "Put declarations in disabled.el."
    (let ((user-init-file disabled-commands))
      ad-do-it))
  (load disabled-commands :noerror)
#+END_SRC

** History
Another feature I  want is history between sessions. I'm  not sure why
it isn't default.

#+BEGIN_SRC emacs-lisp
  (savehist-mode 1)
#+END_SRC

** Keyboard Layout
I use two keyboard layouts: =qwerty=  and =йцукен=, therefore I need a way
to switch between those without loosing  ability to use such chords as
=C-x=  which will  become  a =C-ч=  if  I select  Cyrillic  layout in  the
OS. Luckily for  me, Emacs provides a method to  switch layouts within
Emacs with =C-\=, so all common shortcuts will still work fine.

#+BEGIN_SRC emacs-lisp
  (setq default-input-method 'russian-computer)
#+END_SRC

I'm  not   using  =russian-jcuken=   here  because  it   represents  the
"typewriter" layout with number-line inverted,  so to access numbers I
need to use Shift key. =russian-computer= doesn't have this problem.

** Trailing Whitespaces
I don't  want my files to  contain trailing whitespaces, so  this hook
will get rid of those automatically for me.

#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** Universal =C-g=
One thing  that bothered  me is  that =C-g= is  universal way  to cancel
things in Emacs, gut you have to  be in exact window to cancel action.
This  function  intelligently tries  to  cancel  regardless of  active
window:

#+BEGIN_SRC emacs-lisp
  ;; suppress byte-compiler warnings
  (declare-function minibuffer-keyboard-quit "delsel" (&optional ARGS))

  (defun aorst/escape ()
    "Quit in current context.

  When there is an active minibuffer and we are not inside it close
  it.  When we are inside the minibuffer use the regular
  `minibuffer-keyboard-quit' which quits any active region before
  exiting.  When there is no minibuffer `keyboard-quit' unless we
  are defining or executing a macro."
    (interactive)
    (cond ((active-minibuffer-window)
           (if (minibufferp)
               (minibuffer-keyboard-quit)
             (abort-recursive-edit)))
          ((bound-and-true-p iedit-mode)
           (iedit-quit))
          (t
           ;; ignore top level quits for macros
           (unless (or defining-kbd-macro executing-kbd-macro)
             (keyboard-quit)))))
  (global-set-key [remap keyboard-quit] #'aorst/escape)
#+END_SRC

** Command Error Function
When using some commands that provide  prompt, like pushing to git, or
=eval-expression=,  there's  annoying message  =text  is  read only=  when
deleting past first symbol. Let's disable it:

#+BEGIN_SRC emacs-lisp
  (defun aorst/command-error-function (data context caller)
    "Ignore the `text-read-only', `end-of-buffer', and `beginning-of-buffer' signals.
  Pass the rest DATA CONTEXT CALLER to the default handler."
    (when (not (memq (car data) '(text-read-only
                                  end-of-buffer
                                  beginning-of-buffer)))
      (command-error-default-function data context caller)))

  (setq command-error-function #'aorst/command-error-function)
#+END_SRC

** UTF8
Let's use =UTF8= if we can:

#+BEGIN_SRC emacs-lisp
  (prefer-coding-system 'utf-8)
  (when (display-graphic-p)
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+END_SRC

* User Interface

** Splash and Default Major Mode
Emacs displays splash screen once started  with no files. I don't need
it, and  I would like to  start with =*scratch*= buffer  instead. Also I
would  like =*scratch*=  buffer  to be  an Org  buffer  with no  initial
message:

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t
        initial-major-mode 'fundamental-mode
        initial-scratch-message "")
#+END_SRC

** Menus and Tooltips
I don't need  all these tooltips, menus and  scrollbars. Emacs enables
all of those by default, so let's disable them as early as possible:

#+BEGIN_SRC emacs-lisp
  (tooltip-mode -1)
  (menu-bar-mode -1)
  (fset 'menu-bar-open nil)

  (when window-system
    (scroll-bar-mode -1)
    (tool-bar-mode -1))
#+END_SRC

** Cursor Type
Also let's use bar cursor when in window system, which is visible only
in active window:

#+BEGIN_SRC emacs-lisp
  (when window-system
    (setq-default cursor-type 'bar
                  cursor-in-non-selected-windows nil))
#+END_SRC

** Frame Name and Size
Emacs uses weird method of naming a window, I'd like to see a file I'm
currently working  on in the task  bar in case my  Emacs was minimized
for some reason.

#+BEGIN_SRC emacs-lisp
  (setq-default frame-title-format '("%b — Emacs"))
#+END_SRC

Also,  why initial  frame size  is so  small? When  I launch  Emacs in
terminal it occupies  whole window.  When I launch  it under graphical
environment it defaults to really  small window, which is smaller than
my   terminal.   My   window  manager   doesn't  adjust   window  size
automatically so let's just set little bit bigger initial size:

#+BEGIN_SRC emacs-lisp
  (when window-system
    (set-frame-size (selected-frame) 190 52))
#+END_SRC

With this size I'm  able to fire up Emacs and get  enough space to fit
two vertically aligned windows and a file explorer together.

** Font
I like this  Adobe Source Code Pro  font. Even if I use  Hack in every
other editor, for some reason I find this font just right for Emacs.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil :font "Source Code Pro-10")
#+END_SRC

** Modeline
I  don't  find displaying  position  in  modeline really  great  idea,
because I need to move my eyes too much on big screen just to see what
line number I'm currently on.

#+BEGIN_SRC emacs-lisp
  (setq column-number-mode nil
        line-number-mode nil
        size-indication-mode nil
        mode-line-position nil
        mode-line-in-non-selected-windows nil)
#+END_SRC

* Packages
This section lists package configurations managed by =use-package=.

** Package
To obtain  plugins we need  =package= package. Although this  is builtin
and convenient,  it's also  slow and messy.  Instead of  using =package=
directly we will use =use-package= to manage package configurations.

Melpa is a  package repository, that I use to  get packages. Since all
packages that  I need can  be obtained  from there, I  didn't bothered
with different methods of installation.

#+BEGIN_SRC emacs-lisp
  (defvar package-archives)
  (setq package-archives
        '(("gnu" . "https://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")))
#+END_SRC

There's recent bug with downloading from elpa. This line fixes it:

#+BEGIN_SRC emacs-lisp
  (when (version= emacs-version "26.2")
    (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3"))
  (package-initialize)
#+END_SRC

** Use Package
I use =use-package= to install, load  and configure my packages.  I find
this way very consistent and easy  to understand and maintain.  What I
like  about it  is that  it automatically  installs packages  on Emacs
startup. But unfortunately it can't be installed by itself, so we need
a way  to install  Use Package  in case  I load  this config  on fresh
system.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
#+END_SRC

And =require= the package itself:

#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (require 'use-package)
    (setq use-package-always-ensure t))
#+END_SRC

** Modes
In Emacs  world Modes  are the  main thing. I'm  using Org  Mode quite
heavily right now, as well as  a lot of other modes. Configurations of
these modes are stored here.

*** Org Mode
Org  Mode is  a great  mode for  taking notes,  managing to-do  lists,
writing books, literate programming, and  many other things. I primary
use it for taking notes on different programming languages, and manage
my Emacs configuration with it.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure nil
    :defines default-justification
    :hook ((org-mode . flyspell-mode)
           (org-mode . auto-fill-mode)
           (after-save . aorst/org-tangle-on-config-save)
           (org-babel-after-execute . aorst/org-update-inline-images)
           (org-mode . aorst/org-init-setup)
           (ediff-prepare-buffer . outline-show-all)
           ((org-capture-mode org-src-mode) . aorst/discard-history))
    :bind (:map org-mode-map
                ([backtab] . nil)
                ([S-iso-lefttab] . nil)
                ([C-tab] . org-shifttab)
                ("C-c l" . org-store-link))
    :config
    (use-package ox-latex
      :ensure nil)
    (setq org-startup-with-inline-images t
          org-startup-folded 'content
          org-hide-emphasis-markers t
          org-adapt-indentation nil
          org-hide-leading-stars t
          org-highlight-latex-and-related '(latex)
          revert-without-query '(".*\.pdf")
          org-preview-latex-default-process 'dvisvgm
          org-src-fontify-natively t
          org-preview-latex-image-directory ".ltximg/"
          org-latex-listings 'minted
          org-latex-pdf-process '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
                                  "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
                                  "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")
          org-confirm-babel-evaluate nil
          org-imenu-depth 8
          org-agenda-files (file-truename "~/Documents/Agendas/"))
    (defun aorst/org-tangle-on-config-save ()
      "Tangle source code blocks when configuration file is saved."
      (when (string= buffer-file-name (file-truename "~/.emacs.d/config.org"))
        (org-babel-tangle)))
    (defun aorst/org-update-inline-images ()
      "Update inline images in Org-mode."
      (when org-inline-image-overlays
        (org-redisplay-inline-images)))
    (defun aorst/org-init-setup ()
      "Set buffer local values."
      (setq default-justification 'full))
    (defun aorst/discard-history ()
      "Discard undo history of org src and capture blocks."
      (setq buffer-undo-list nil)
      (set-buffer-modified-p nil))
    (defvar minted-cache-dir
      (file-name-as-directory
       (expand-file-name ".minted/\\jombname"
                         temporary-file-directory)))
    (add-to-list 'org-latex-packages-alist
                 `(,(concat "cachedir=" minted-cache-dir)
                   "minted" nil))
    (add-to-list 'org-latex-logfiles-extensions "tex")
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((gnuplot . t)
       (scheme . t)))
    (add-to-list 'org-latex-classes
                 '("article"
                   "\\documentclass{article}"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))
#+END_SRC

*** Doc View Mode
Default resolution is too low:

#+BEGIN_SRC emacs-lisp
  (use-package doc-view
    :ensure nil
    :config (setq-default doc-view-resolution 192))
#+END_SRC

*** Display Line Numbers Mode
This mode provides line numbers on  the left side of the window, which
doesn't lag. I don't like that it changes width, so let's change it:

#+BEGIN_SRC emacs-lisp
  (use-package display-line-numbers
    :ensure nil
    :config
    (setq display-line-numbers-grow-only t
          display-line-numbers-width-start t))
#+END_SRC

*** Prog Mode
This isn't really a configuration of  Prog Mode itself, but some hooks
that change how  programming related modes behave. One  feature that I
think is really important, especially  when working with lisp code, is
ability  to see  matching bracket  when cursor  stands near  the other
bracket. So I enable it for every programming language.

#+BEGIN_SRC emacs-lisp
    (use-package prog-mode
      :ensure nil
      :hook ((prog-mode . show-paren-mode)
             (prog-mode . display-line-numbers-mode)))
#+END_SRC

*** CC Mode
These settings are for editing C source files.

#+BEGIN_SRC emacs-lisp
  (use-package cc-mode
    :ensure nil
    :config (defun aorst/cc-mode-setup ()
              (setq c-basic-offset 4
                    c-default-style "linux"
                    indent-tabs-mode t
                    tab-width 4))
    :hook ((c-mode-common . aorst/cc-mode-setup)
           (c-mode-common . electric-pair-local-mode)))
#+END_SRC

*** Markdown Mode
Sometimes I need to edit Markdown documents, so this package is handy.
For markdown  mode I would like  to have automatic spell  checking and
filling. Basically  the same setup  as for Org  Mode.  And one  of the
features of Org mode is ability to edit source code blocks in separate
window  with  appropriate  major  mode.  This  can  be  achieved  with
=edit-indirect= package.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :config
    (use-package edit-indirect)
    (defvar markdown-command "multimarkdown")
    (defun aorst/markdown-setup ()
      "Set buffer local variables."
      (setq fill-column 80
            default-justification 'left))
    :hook ((markdown-mode . flyspell-mode)
           (markdown-mode . auto-fill-mode)
           (markdown-mode . aorst/markdown-setup)))
#+END_SRC

*** Rust Mode
I'd like to  have Rust syntax highlighting and  some basic facilities,
since I'm  planning to write my  exercises in org mode.   Since I make
notes in Org-mode, and  I started to use it for Rust  too, I need some
settings for Rust mode.

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :commands (rust-format-buffer)
    :hook (rust-mode . electric-pair-local-mode)
    :bind (:map rust-mode-map
                ("C-c C-f" . rust-format-buffer)))
#+END_SRC

This also means  that I could use something  to automatically complete
Rust  language facilities.   Rust ecosystem  provides two  options for
that:  [[https://github.com/racer-rust/emacs-racer][Racer]], and  [[https://github.com/rust-lang/rls][RLS]].   I'm planning  to use  Racer  when RLS  isn't
possible to use, like in Org Mode.

#+BEGIN_SRC emacs-lisp
  (when (executable-find "racer")
    (use-package racer
      :hook (racer-mode . eldoc-mode)
      :config (defun org-babel-edit-prep:rust (&optional _babel-info)
                "Run racer mode for Org Babel."
                (racer-mode 1))))
#+END_SRC

There's also a package for [[https://github.com/kwrooijen/cargo.el][Cargo]] integration:

#+BEGIN_SRC emacs-lisp
  (when (executable-find "cargo")
    (use-package cargo
      :hook (rust-mode . cargo-minor-mode)))
#+END_SRC

*** TOML Mode
=toml-mode= helps  with highlighting of  TOML files, which Rust  uses to
configure project.

#+BEGIN_SRC emacs-lisp
  (use-package toml-mode)
#+END_SRC

*** Racket Mode
Racket is nice LISP/Scheme language that I might to get into.

#+BEGIN_SRC emacs-lisp
  (use-package racket-mode
    :mode ("\\.rkt\\'" . racket-mode)
    :hook (racket-repl-mode . electric-pair-local-mode)
    :bind (:map racket-mode-map
                ("C-c C-d" . racket-run-with-debugging))
    :config (when (fboundp 'doom-color)
              (progn
                (set-face-attribute 'racket-debug-break-face nil :background (doom-color 'red) :foreground (doom-color 'base0))
                (set-face-attribute 'racket-debug-result-face nil :foreground (doom-color 'grey) :box nil)
                (set-face-attribute 'racket-debug-locals-face nil :foreground (doom-color 'grey) :box nil)
                (set-face-attribute 'racket-selfeval-face nil :foreground (doom-color 'fg)))))
#+END_SRC

*** Cmake Mode
A mode for editing cmake files.

#+BEGIN_SRC emacs-lisp
  (use-package cmake-mode)
#+END_SRC

*** Help Mode
I want help  window to be selected automatically, so  I could close it
with =q= after I've finished reading.

#+BEGIN_SRC emacs-lisp
  (use-package help
    :ensure nil
    :config (setq help-window-select t))
#+END_SRC

** User Interface Packages
All user interface related settings are presented in this section. I'm
big fan of  DOOM themes, and modeline,  so I'll refer to  them quite a
lot here.

*** All The Icons
This  package provides  nice icons  for Emacs  via custom  fonts. Just
don't forget to use =M-x all-the-icons-install-fonts RET= after install.

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)
#+END_SRC

I don't use  this package directly yet, but some  other packages, like
DOOM Modeline or Treemacs.

*** DOOM Themes
This theme collection  was developed for [[https://github.com/hlissner/doom-emacs][DOOM Emacs]], and  I find these
themes actually great  on its own. This package  contains nice variant
of Atom-like One theme which I like,  but it is also an amazingly well
put package, which defines colors for pretty much everything in Emacs.
It also features Treemacs configuration, which  is nice, but I want to
change a little bit of it.

#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :commands (doom-themes-org-config)
    :config
    (doom-themes-org-config)
    (setq doom-themes-enable-bold t
          doom-themes-enable-italic t)
    :init (load-theme 'doom-one t))
#+END_SRC

*** Frame
Emacs uses  white titlebar, but  since I'm  using dark color  scheme I
want title bar  to be dark as  well. It is quite  difficult to achieve
this in GNOME  Shell, but I found  this code [[https://nicolas.petton.fr/blog/emacs-dark-window-decoration.html][on the internet]].  So if I
use =window-system=  I want this  function to run  during initialization
process, and when new frame is created.

#+BEGIN_SRC emacs-lisp
  (when window-system
    (use-package frame
      :ensure nil
      :config
      (add-to-list 'after-make-frame-functions #'aorst/set-frame-dark)
      (setq window-divider-default-right-width 1)
      (window-divider-mode 1)
      :init
      (defun aorst/set-frame-dark (&optional frame)
        "Set FRAME titlebar colorscheme to dark variant."
        (with-selected-frame (or frame (selected-frame))
          (call-process-shell-command
           (format "xprop -f _GTK_THEME_VARIANT 8u -set _GTK_THEME_VARIANT \"dark\" -name \"%s\""
                   (frame-parameter frame 'name)))))
      (aorst/set-frame-dark)))
#+END_SRC

*** Fringe
If only  certain buffers  could +be so  grossly incandescent+  *have damn
fringes!* With  Solaire Mode  Emacs becomes way  more like  true editor
with actual  graphical interface,  but these  fringes drive  me crazy.
That's why  I wrote  a function =aorst/real-buffer-setup=,  that enables
fringes only  in buffers that  are affected  by Solaire Mode.   I want
fringes to appear only in certain buffers where I really need them, so
let's disable  it entirely  on startup  and set  them with  some hooks
later.  But this  adds another problem.  Emacs displays =$=  sign at the
end of the window if line is  being truncated. Damn, why it is so hard
to  make   it  work   how  I   want..   And   you  can't   simply  set
=standard-display-table= slot to empty space,  because it isn't ready on
Emacs init.

#+BEGIN_SRC emacs-lisp
  (use-package fringe
    :ensure nil
    :hook ((window-configuration-change
            org-capture-mode
            org-src-mode
            ediff-prepare-buffer) . aorst/real-buffer-setup)
    :config
    (defun aorst/real-buffer-p ()
      "Determines whether buffer is real."
      (or (and (not (minibufferp))
               (buffer-file-name))
          (or (string-equal "*scratch*" (buffer-name))
              (string-match-p ".~.*~" (buffer-name)))))
    (defun aorst/real-buffer-setup (&rest _)
      "Wrapper around `set-window-fringes' function."
      (when (aorst/real-buffer-p)
        (set-window-fringes nil 8 8 nil)
        (when (and (fboundp 'doom-color)
                   window-system)
          (set-face-attribute 'line-number-current-line nil
                              :background (doom-color 'bg)))
        (setq-local scroll-margin 3)))
    :init
    (when window-system
      (fringe-mode 0)
      (or standard-display-table
          (setq standard-display-table (make-display-table)))
      (set-display-table-slot standard-display-table 0 ?\ )))
#+END_SRC

*** Solaire Mode
This  package helps  distinguish  buffers that  have  file opened  and
buffers that  are for utilities  like file  browser. Also it  has cool
name! =\[T]/=

I really want  Solaire to treat =*scratch*= buffer as  real.  For that I
need to define my  own function that will decide if  buffer is real or
not. Now we can set up  Solaire Mode and assign =aorst/real-buffer-p= to
=solaire-mode-real-buffer-fn=.

#+BEGIN_SRC emacs-lisp
  (use-package solaire-mode
    :commands (solaire-global-mode
               solaire-mode-swap-bg
               turn-on-solaire-mode
               solaire-mode-in-minibuffer
               solaire-mode-reset)
    :hook (((after-revert
             change-major-mode
             org-capture-mode
             org-src-mode) . turn-on-solaire-mode)
           (snippet-mode . solaire-mode))
    :config
    (setq solaire-mode-real-buffer-fn #'aorst/real-buffer-p)
    (solaire-mode-swap-bg)
    (cond ((not (boundp 'after-focus-change-function))
           (add-hook 'focus-in-hook  #'solaire-mode-reset))
          (t
           (add-function :after after-focus-change-function #'solaire-mode-reset)))
    :init (solaire-global-mode +1))
#+END_SRC

*** DOOM Modeline
I've tried bunch of different modelines:

- [[https://github.com/TheBB/spaceline][Spaceline]]
  Great modeline, but  I was experiencing slowdowns  in Emacs startup,
  and I like my Emacs to start fast.
- [[https://github.com/dbordak/telephone-line][Telephone Line]]
  Another good modeline, but I was lazy to configure it.
- [[https://github.com/milkypostman/powerline][Powerline]]
  This was first what I tried because I was using something similar in
  Vim. I don't remember why I dropped it.
- [[https://github.com/tarsius/moody][Moody]]
  Really lightweight  configuration for  default modeline,  which I've
  used for quite a some time.

They're all  great, but  I experienced some  troubles with  DOOM Theme
that I use, so  I've decided to try out DOOM  Modeline.  And turns out
it's great!

#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
    :commands (doom-modeline-mode
               doom-modeline-set-selected-window
               doom-modeline-lsp-icon)
    :functions (doom-color)
    :config
    (dolist (face '(doom-modeline-buffer-modified
                    doom-modeline-buffer-minor-mode
                    doom-modeline-project-parent-dir
                    doom-modeline-project-dir
                    doom-modeline-project-root-dir
                    doom-modeline-highlight
                    doom-modeline-debug
                    doom-modeline-info
                    doom-modeline-warning
                    doom-modeline-urgent
                    doom-modeline-unread-number
                    doom-modeline-buffer-path
                    doom-modeline-bar
                    doom-modeline-panel
                    doom-modeline-buffer-major-mode
                    doom-modeline-buffer-file
                    doom-modeline-lsp-success
                    doom-modeline-lsp-warning
                    doom-modeline-lsp-error))
      (set-face-attribute face nil :foreground (doom-color 'fg) :weight 'normal))
    (set-face-attribute 'doom-modeline-buffer-file nil :weight 'semi-bold)
    (set-face-attribute 'doom-modeline-buffer-major-mode nil :weight 'semi-bold)
    (set-face-attribute 'doom-modeline-panel nil :background (doom-color 'bg-alt))
    (set-face-attribute 'doom-modeline-bar nil :background (doom-color 'bg-alt))
    (setq doom-modeline-bar-width 3
          doom-modeline-major-mode-color-icon nil
          doom-modeline-buffer-file-name-style 'file-name
          doom-modeline-minor-modes t
          find-file-visit-truename t)
    :init (doom-modeline-mode 1))
#+END_SRC

I guess that this is all for DOOM  packages for now, but I have to say
that I really  appreciate *[[https://github.com/hlissner][@hlissner]]* work. These  packages already make
Emacs look outstanding.

*** Treemacs
To make Emacs look more like  a traditional modern text editor we need
a file explorer.  Emacs has  builtin package for this, named =speedbar=,
but It uses external frame and has  so many features that I don't know
if I really need. With this package, and its supplement packages I can
have a consistent  filetree inside my Emacs frame. Which  is good. But
there's more:  DOOM Themes support  this package as well,  which means
that Treemacs will look just as great as DOOM themed Emacs!

#+BEGIN_SRC emacs-lisp
  (when window-system
    (use-package treemacs
      :commands (treemacs
                 treemacs-follow-mode
                 treemacs-filewatch-mode
                 treemacs-fringe-indicator-mode
                 treemacs--expand-root-node
                 treemacs--maybe-recenter
                 treemacs-TAB-action
                 treemacs-load-theme
                 treemacs-toggle-fixed-width)
      :functions (aorst/treemacs-expand-all-projects
                  aorst/treemacs-variable-pitch-labels
                  aorst/tremacs-init-setup
                  aorst/treemacs-setup
                  aorst/treemacs-setup-fringes
                  doom-color
                  all-the-icons-octicon)
      :bind (("<f7>" . treemacs)
             ("<f8>" . treemacs-select-window)
             :map treemacs-mode-map
             ([C-tab] . aorst/treemacs-expand-all-projects))
      :hook ((after-init . aorst/treemacs-init-setup)
             (treemacs-mode . aorst/treemacs-setup)
             (treemacs-switch-workspace . aorst/treemacs-expand-all-projects)
             (treemacs-mode . aorst/treemacs-setup-title))
      :config
      (use-package treemacs-magit)
      (set-face-attribute 'treemacs-root-face nil
                          :foreground (doom-color 'fg)
                          :height 1.0
                          :weight 'normal)
      (treemacs-create-theme "Atom"
        :config
        (progn
          (treemacs-create-icon
           :icon (format " %s\t"
                         (all-the-icons-octicon
                          "repo"
                          :v-adjust -0.1
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (root))
          (treemacs-create-icon
           :icon (format "%s\t%s\t"
                         (all-the-icons-octicon
                          "chevron-down"
                          :height 0.75
                          :v-adjust 0.1
                          :face '(:inherit font-lock-doc-face :slant normal))
                         (all-the-icons-octicon
                          "file-directory"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (dir-open))
          (treemacs-create-icon
           :icon (format "%s\t%s\t"
                         (all-the-icons-octicon
                          "chevron-right"
                          :height 0.75
                          :v-adjust 0.1
                          :face '(:inherit font-lock-doc-face :slant normal))
                         (all-the-icons-octicon
                          "file-directory"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (dir-closed))
          (treemacs-create-icon
           :icon (format "%s\t%s\t"
                         (all-the-icons-octicon
                          "chevron-down"
                          :height 0.75
                          :v-adjust 0.1
                          :face '(:inherit font-lock-doc-face :slant normal))
                         (all-the-icons-octicon
                          "package"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (tag-open))
          (treemacs-create-icon
           :icon (format "%s\t%s\t"
                         (all-the-icons-octicon
                          "chevron-right"
                          :height 0.75
                          :v-adjust 0.1
                          :face '(:inherit font-lock-doc-face :slant normal))
                         (all-the-icons-octicon
                          "package"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (tag-closed))
          (treemacs-create-icon
           :icon (format "%s\t"
                         (all-the-icons-octicon
                          "tag"
                          :height 0.9
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (tag-leaf))
          (treemacs-create-icon
           :icon (format "%s\t"
                         (all-the-icons-octicon
                          "flame"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (error))
          (treemacs-create-icon
           :icon (format "%s\t"
                         (all-the-icons-octicon
                          "stop"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (warning))
          (treemacs-create-icon
           :icon (format "%s\t"
                         (all-the-icons-octicon
                          "info"
                          :height 0.75
                          :v-adjust 0.1
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (info))
          (treemacs-create-icon
           :icon (format "  %s\t"
                         (all-the-icons-octicon
                          "file-media"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("png" "jpg" "jpeg" "gif" "ico" "tif" "tiff" "svg" "bmp"
                        "psd" "ai" "eps" "indd" "mov" "avi" "mp4" "webm" "mkv"
                        "wav" "mp3" "ogg" "midi"))
          (treemacs-create-icon
           :icon (format "  %s\t"
                         (all-the-icons-octicon
                          "file-code"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("yml" "yaml" "sh" "zsh" "fish" "c" "h" "cpp" "cxx" "hpp"
                        "tpp" "cc" "hh" "hs" "lhs" "cabal" "py" "pyc" "rs" "el"
                        "elc" "clj" "cljs" "cljc" "ts" "tsx" "vue" "css" "html"
                        "htm" "dart" "java" "kt" "scala" "sbt" "go" "js" "jsx"
                        "hy" "json" "jl" "ex" "exs" "eex" "ml" "mli" "pp" "dockerfile"
                        "vagrantfile" "j2" "jinja2" "tex" "racket" "rkt" "rktl" "rktd"
                        "scrbl" "scribble" "plt" "makefile" "elm" "xml" "xsl" "rb"
                        "scss" "lua" "lisp" "scm" "sql" "toml" "nim" "pl" "pm" "perl"
                        "vimrc" "tridactylrc" "vimperatorrc" "ideavimrc" "vrapperrc"
                        "cask" "r" "re" "rei" "bashrc" "zshrc" "inputrc" "editorconfig"
                        "gitconfig"))
          (treemacs-create-icon
           :icon (format "  %s\t"
                         (all-the-icons-octicon
                          "book"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("lrf" "lrx" "cbr" "cbz" "cb7" "cbt" "cba" "chm" "djvu"
                        "doc" "docx" "pdb" "pdb" "fb2" "xeb" "ceb" "inf" "azw"
                        "azw3" "kf8" "kfx" "lit" "prc" "mobi" "pkg" "opf" "txt"
                        "pdb" "ps" "rtf" "pdg" "xml" "tr2" "tr3" "oxps" "xps"))
          (treemacs-create-icon
           :icon (format "  %s\t" (all-the-icons-octicon
                                   "file-text"
                                   :v-adjust 0
                                   :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("md" "markdown" "rst" "log" "org" "txt"
                        "CONTRIBUTE" "LICENSE" "README" "CHANGELOG"))
          (treemacs-create-icon
           :icon (format "  %s\t" (all-the-icons-octicon
                                   "file-binary"
                                   :v-adjust 0
                                   :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("exe" "dll" "obj" "so" "o" "out"))
          (treemacs-create-icon
           :icon (format "  %s\t" (all-the-icons-octicon
                                   "file-pdf"
                                   :v-adjust 0
                                   :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("pdf"))
          (treemacs-create-icon
           :icon (format "  %s\t" (all-the-icons-octicon
                                   "file-zip"
                                   :v-adjust 0
                                   :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("zip" "7z" "tar" "gz" "rar" "tgz"))
          (treemacs-create-icon
           :icon (format "  %s\t" (all-the-icons-octicon
                                   "file-text"
                                   :v-adjust 0
                                   :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (fallback))))
      (defun aorst/treemacs-expand-all-projects (&optional _)
        "Expand all projects."
        (interactive)
        (save-excursion
          (treemacs--forget-last-highlight)
          (dolist (project (treemacs-workspace->projects (treemacs-current-workspace)))
            (-when-let (pos (treemacs-project->position project))
              (when (eq 'root-node-closed (treemacs-button-get pos :state))
                (goto-char pos)
                (treemacs--expand-root-node pos)))))
        (treemacs--maybe-recenter 'on-distance))
      (defun aorst/treemacs-variable-pitch-labels (&rest _)
        (dolist (face '(treemacs-root-face
                        treemacs-git-unmodified-face
                        treemacs-git-modified-face
                        treemacs-git-renamed-face
                        treemacs-git-ignored-face
                        treemacs-git-untracked-face
                        treemacs-git-added-face
                        treemacs-git-conflict-face
                        treemacs-directory-face
                        treemacs-directory-collapsed-face
                        treemacs-file-face
                        treemacs-tags-face))
          (let ((faces (face-attribute face :inherit nil)))
            (set-face-attribute
             face nil :inherit
             `(variable-pitch ,@(delq 'unspecified (if (listp faces) faces (list faces))))))))
      (defun aorst/treemacs-init-setup ()
        "Set treemacs theme, open treemacs, and expand all projects."
        (treemacs-load-theme "Atom")
        (treemacs)
        (aorst/treemacs-expand-all-projects))
      (defun aorst/treemacs-setup ()
        "Set treemacs buffer common settings."
        (setq tab-width 1
              mode-line-format nil
              line-spacing 5)
        (set-window-fringes nil 0 0 nil)
        (aorst/treemacs-variable-pitch-labels))
      (defun aorst/treemacs-setup-fringes ()
        "Set treemacs buffer fringes."
        (set-window-fringes nil 0 0 nil)
        (aorst/treemacs-variable-pitch-labels))
      (advice-add #'treemacs-select-window :after #'aorst/treemacs-setup-fringes)
      (defun aorst/treemacs-ignore (file _)
        (or (s-ends-with? ".elc" file)
            (s-ends-with? ".o" file)
            (s-ends-with? ".a" file)
            (string= file ".svn")))
      (add-to-list 'treemacs-ignored-file-predicates #'aorst/treemacs-ignore)
      (defun aorst/treemacs-setup-title ()
        (let ((format '((:eval (concat
                                (make-string
                                 (let ((width (window-width)))
                                   (- (/ (if (= (% width 2) 0) width (1+ width)) 2) 5))
                                 ?\ )
                                "Treemacs")))))
          (if (version<= emacs-version "27")
              (setq header-line-format format)
            (setq tab-line-format format)))
        (let ((bg (face-attribute 'default :background))
              (fg (face-attribute 'default :foreground))
              (face (if (version<= emacs-version "27")
                        'header-line
                      'tab-line)))
          (face-remap-add-relative face
                                   :box (list :line-width 7 :color bg)
                                   :background bg :foreground fg))))
    (setq treemacs-width 27
          treemacs-is-never-other-window t
          treemacs-space-between-root-nodes nil)
    (treemacs-follow-mode t)
    (treemacs-filewatch-mode t)
    (treemacs-fringe-indicator-mode nil))
#+END_SRC

Before using Treemacs I was a  happy user of another filetree package:
[[https://github.com/jaypei/emacs-neotree][Neotree]]. Unfortunately, last  commit to this package dates  to Nov 21,
2018, and since then there were no maintenance, and I was experiencing
a bug which made me move to Treemacs.

*** Eyebrowse
This  package imitates  virtual workspaces,  or virtual  frames inside
single Emacs  frame. This  is really  useful, when  you have  bunch of
windows, and you  want to open new  set but don't want  to loose other
window configurations. It works much like Vim tabs, or Tmux windows.

#+BEGIN_SRC emacs-lisp
  (use-package eyebrowse
    :commands eyebrowse-mode
    :init (eyebrowse-mode t))
#+END_SRC

*** Minions
This  package  implements   a  menu  that  lists   all  enabled  minor
modes. Emacs mode  line can become pretty long, so  this can be handy,
and perhaps I don't need to use =:diminish= everywhere anymore.

#+BEGIN_SRC emacs-lisp
  (use-package minions
    :commands minions-mode
    :init (minions-mode 1))
#+END_SRC

*** Uniquify
This package makes files with  identical names more distinguishable by
adding directory name in the buffer name.

#+BEGIN_SRC emacs-lisp
  (use-package uniquify
    :ensure nil
    :config (setq uniquify-buffer-name-style 'forward))
#+END_SRC

*** Tabline
Starting  with Emacs  27  native tab  support is  present.  I want  to
customize tab appearance to match my theme.

#+BEGIN_SRC emacs-lisp
  (unless (version< emacs-version "27")
    (use-package tab-line
      :ensure nil
      :hook ((ediff-mode . aorst/disable-tab-line)
             (after-init . global-tab-line-mode))
      :config
      (defun aorst/disable-tab-line ()
        (setq tab-line-format nil))
      (defun tab-line-close-tab (&optional e)
        "Close the selected tab.
  If tab is presented in another window, close the tab by using `bury-buffer` function.
  If tab is uniq to all existing windows, kill the buffer with `kill-buffer` function.
  Lastly, if no tabs left in the window, it is deleted with `delete-window` function."
        (interactive "e")
        (let* ((posnp (event-start e))
               (window (posn-window posnp))
               (buffer (get-pos-property 1 'tab (car (posn-string posnp)))))
          (with-selected-window window
            (let ((tab-list (tab-line-tabs))
                  (buffer-list (flatten-list
                                (seq-reduce (lambda (list window)
                                              (select-window window t)
                                              (cons (tab-line-tabs) list))
                                            (window-list) nil))))
              (select-window window)
              (if (> (seq-count (lambda (b) (eq b buffer)) buffer-list) 1)
                  (progn
                    (if (eq buffer (current-buffer))
                        (bury-buffer)
                      (set-window-prev-buffers window (assq-delete-all buffer (window-prev-buffers)))
                      (set-window-next-buffers window (delq buffer (window-next-buffers))))
                    (unless (cdr tab-list)
                      (ignore-errors (delete-window window))))
                (and (kill-buffer buffer)
                     (unless (cdr tab-list)
                       (ignore-errors (delete-window window)))))))
          (force-mode-line-update)))
      (setq tab-line-new-tab-choice nil
            tab-line-close-button-show nil)
      (let ((bg (if (facep 'solaire-default-face)
                    (face-attribute 'solaire-default-face :background)
                  (face-attribute 'default :background)))
            (fg (face-attribute 'default :foreground))
            (base (face-attribute 'mode-line :background))
            (box-width 7))
        (set-face-attribute 'tab-line nil :background base :foreground nil)
        (set-face-attribute 'tab-line-tab nil :foreground fg :background bg :box (list :line-width box-width :color bg) :weight 'bold)
        (set-face-attribute 'tab-line-tab-inactive nil :foreground fg :background base :box (list :line-width box-width :color base) :weight 'normal))))
#+END_SRC

** Tools
Additional  packages  that  change  how Emacs  works,  providing  more
comfortable user experience.

*** ANSI Term
I'm using  it more  and more,  so I've  decided that  I should  have a
proper  shortcut  for  it.   =aorst/ansi-term-toggle=  function  toggles
bottom split  with =ansi-term= inside  it.  /Ctrl+`/ seems  great shortcut
for this.   Also, when I  exit terminal, I'd  like to kill  its window
automatically.

#+BEGIN_SRC emacs-lisp
  (use-package term
    :ensure nil
    :bind (("C-`" . aorst/ansi-term-toggle)
           ("C-t" . aorst/ansi-term-focus))
    :config
    (defun aorst/ansi-term-toggle (&optional arg)
      "Toggle `ansi-term' window on and off with the same command."
      (interactive "P")
      (let* ((bufname "*ansi-term*")
             (window (get-buffer-window bufname))
             (shell (cond ((executable-find "zsh") "zsh")
                          ((executable-find "bash") "bash")
                          (t "sh"))))
        (if window
            (ignore-errors (delete-window window))
          (let* ((win-side (if (symbolp arg)
                               (cons (split-window-below) 'bot)
                             (cons (split-window-right) 'right)))
                 (window (car win-side))
                 (side (cdr win-side)))
            (select-window window)
            (cond ((get-buffer bufname)
                   (switch-to-buffer bufname))
                  (t (ansi-term shell)
                     (rename-buffer bufname)))
            (set-window-dedicated-p window t)
            (set-window-parameter window 'no-delete-other-windows t)
            (set-window-parameter window 'window-side side)
            (set-window-parameter window 'no-other-window t)))))
    (defun aorst/ansi-term-focus (&optional arg)
      "Focus `ansi-term` or open one if there's none."
      (interactive "P")
      (let ((window (get-buffer-window "*ansi-term*")))
        (if window
            (select-window window)
          (aorst/ansi-term-toggle arg))))
    (defun aorst/autokill-when-no-processes (&rest _)
      "Kill buffer and its window when there's no processes left."
      (when (null (get-buffer-process (current-buffer)))
        (kill-buffer (current-buffer))))
    (advice-add 'term-handle-exit :after 'aorst/autokill-when-no-processes))
#+END_SRC

*** EditorConfig
=.editorconfig=  file  provides a  nice  way  to synchronize  my  editor
configurations between projects and different editors.

#+BEGIN_SRC emacs-lisp
  (use-package editorconfig
    :commands editorconfig-mode
    :config (editorconfig-mode 1))
#+END_SRC

*** Flymake Mode
This mode allows checking syntax in  the buffer.  I was using [[https://www.flycheck.org/en/latest/][Flycheck]]
package  before,  but  I  don't   see  major  advantages  of  Flycheck
supporting 50  languages versus  4 in Flymake  [[https://www.flycheck.org/en/latest/user/flycheck-versus-flymake.html#supported-languages][(1)]], because  I'm using
language server protocol that integrates with Flymake, so as long as I
have  server for  a  language, I  have support  for  this language  in
Flymake.

Also let's  use right  fringe for indication  of errors  and warnings,
since it's never used, and left fringe is occupied by diff status.

#+BEGIN_SRC emacs-lisp
  (use-package flymake
    :ensure nil
    :config (setq flymake-fringe-indicator-position 'right-fringe))
#+END_SRC

*** Hydra
This is something like ability to create mappings that sit in it's own
mode, like different user modes in Kakoune. It allows me to press some
shortcut  and be  locked  in a  mode-like state  where  keys that  are
related  to  this  prefix  shortcut  are behaving  in  terms  of  this
shortcut.

This  package will  be used  in many  other package  configurations to
provide sane keybindings.

#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :commands (hydra-default-pre
               hydra-keyboard-quit
               hydra--call-interactively-remap-maybe
               hydra-show-hint
               hydra-set-transient-map)
    :bind (("<f5>" . hydra-zoom/body))
    :config (defhydra hydra-zoom (:hint nil)
              "Scale text"
              ("+" text-scale-increase "in")
              ("-" text-scale-decrease "out")
              ("0" (text-scale-set 0) "reset")))
#+END_SRC

*** Geiser
Since I mostly use Emacs for studying LISP, and I'm reading SICP which
uses Scheme as main LISP flavor for explanations and exercises, I need
a tool  to run Scheme,  and Geiser seems  like the most  viable option
here, since it also provides completion for it.

#+BEGIN_SRC emacs-lisp
  (use-package geiser
    :hook (scheme-mode . geiser-mode)
    :config (setq geiser-active-implementations '(guile)
                  geiser-default-implementation 'guile))
#+END_SRC

*** Parinfer
Now that's a quality package. It makes writing LISP so easy, that I've
never thought it could be.

#+BEGIN_SRC emacs-lisp
  (use-package parinfer
    :commands (parinfer-mode
               parinfer-toggle-mode)
    :hook ((clojure-mode
            emacs-lisp-mode
            common-lisp-mode
            scheme-mode
            lisp-mode
            racket-mode) . parinfer-mode)
    :bind (:map parinfer-mode-map
                ("C-," . parinfer-toggle-mode))
    :config (setq parinfer-extensions
                  '(defaults
                     pretty-parens
                     smart-tab
                     smart-yank)))
#+END_SRC

Big thanks to [[https://github.com/shaunlebron][@shaunlebron]] for creating original [[https://github.com/shaunlebron/parinfer][Parinfer]].

*** Ivy and Counsel
Ivy  is a  narrowing  framework  like Helm,  but  much  lighter in  my
experience.  It  integrates with  Counsel that handles  minibuffer, so
let's install  it too.  I'm  using [[https://github.com/sharkdp/fd][fd]] as  a great replacement  for GNU
Find. It's fast and it takes =.gitignore= into account.  Let's assign it
to =find-program=.   /I guess there will  be no problems/ /if  a well known
tool  is replaced  by something/  /that  is completely  different, am  I
right?/ Well I hope  that it is used by =grep.el= only  which I don't use
anyways.   Counsel  has  nice   =counsel-file-fump=  command  that  uses
=find-program= variable, so it will be more performant with =fd=.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :commands ivy-mode
    :bind (("C-x C-b" . ivy-switch-buffer)
           ("C-x b" . ivy-switch-buffer))
    :config
    (use-package counsel
      :commands (counsel-M-x
                 counsel-find-file
                 counsel-file-jump
                 counsel-recentf
                 counsel-rg
                 counsel-describe-function
                 counsel-describe-variable
                 counsel-find-library)
      :config
      (when (executable-find "fd")
        (define-advice counsel-file-jump (:around (foo &optional initial-input initial-directory))
          (let ((find-program "fd")
                (counsel-file-jump-args (split-string "-L --type f --hidden")))
            (funcall foo))))
      (when (executable-find "rg")
        (setq counsel-rg-base-command
              "rg -S --no-heading --hidden --line-number --color never %s .")
        (setenv "FZF_DEFAULT_COMMAND"
                "rg --files --hidden --follow --no-ignore --no-messages --glob '!.git/*' --glob '!.svn/*'"))
      :bind (("M-x" . counsel-M-x)
             ("C-x C-f" . counsel-find-file)
             ("C-x f" . counsel-file-jump)
             ("C-x C-r" . counsel-recentf)
             ("C-h f" . counsel-describe-function)
             ("C-h v" . counsel-describe-variable)
             ("C-h l" . counsel-find-library)))
    (setq ivy-re-builders-alist '((t . ivy--regex-fuzzy))
          ivy-count-format ""
          ivy-display-style nil
          ivy-minibuffer-faces nil
          ivy-use-virtual-buffers t
          enable-recursive-minibuffers t)
    :init (ivy-mode 1))
#+END_SRC

*** Company
Complete anything framework. Nothing much to say. Does it's job.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :commands global-company-mode
    :bind (:map company-active-map
                ("TAB" . company-complete-common-or-cycle)
                ("<tab>" . company-complete-common-or-cycle)
                ("<S-Tab>" . company-select-previous)
                ("<backtab>" . company-select-previous))
    :hook (after-init . global-company-mode)
    :config
    (setq company-require-match 'never
          company-minimum-prefix-length 3
          company-tooltip-align-annotations t
          company-frontends '(company-pseudo-tooltip-unless-just-one-frontend
                              company-preview-frontend
                              company-echo-metadata-frontend)
          company-backends '(company-capf company-files)))
#+END_SRC

This package also requires these extra dependencies:

- =company-flx= - provides fuzzy matching algorithms for company.

  #+BEGIN_SRC emacs-lisp
    (use-package company-flx
      :after company
      :config
      (company-flx-mode +1))
  #+END_SRC

- =company-quickhelp=  -  provides  documentation  popup  for  completed
  items.

  #+BEGIN_SRC emacs-lisp
    (use-package company-quickhelp
      :after company
      :config (company-quickhelp-mode))
  #+END_SRC

*** Undo Tree
This is more familiar  undo mode. It adds =C-/= mapping  to undo and =C-?=
mapping to redo.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :commands global-undo-tree-mode
    :init (global-undo-tree-mode 1))
#+END_SRC

*** Yasnippet
Another very handy package, that helps insert templates of code. Now I
really need to write some snippets to use. Also has nice collection as
a separate package

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :commands yas-reload-all
    :hook ((rust-mode
            c-mode-common
            racket-mode). yas-minor-mode)
    :config
    (use-package yasnippet-snippets)
    (yas-reload-all))
#+END_SRC

*** Magit
Emacs interface to Git.  I've heard that it has many nice features, so
I want to try it out.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind (("<f12>" . magit-status))
    :config (setq magit-ediff-dwim-show-on-hunks t))
#+END_SRC

*** Ediff
This is a built  in mode for diffing files in  Emacs. Previously I was
using  [[https://github.com/justbur/emacs-vdiff][Vdiff]] but  I have  to say  that I've  used it  so rarely,  so I
decided to avoid extra dependency and configure Ediff.

#+BEGIN_SRC emacs-lisp
  (use-package ediff
    :ensure nil
    :config
    (advice-add 'ediff-window-display-p :override #'ignore)
    (setq ediff-split-window-function 'split-window-horizontally))
#+END_SRC

*** Multiple Cursors
This  package provides  multiple cursors  functionality to  Emacs.  It
isn't much like Kakoune's multiple selections, but anything will do. I
guess I'll figure out best mappings over time.

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :commands (mc/cycle-backward
               mc/cycle-forward)
    :bind (("S-<mouse-1>" . mc/add-cursor-on-click)
           ("C-c m" . hydra-mc/body))
    :config
    (use-package mc-extras)
    (defhydra hydra-mc (:hint nil :color pink)
      "
  ^Select^                ^Discard^                    ^Move^
  ^──────^────────────────^───────^────────────────────^────^────────────
  _M-s_: split lines      _M-SPC_: discard current     _&_: align
  _s_:   select regexp    _b_:     discard blank lines _(_: cycle backward
  _n_:   select next      _d_:     remove duplicated   _)_: cycle forward
  _p_:   select previous  _q_:     exit                ^ ^
  _C_:   select next line"
      ("M-s" mc/edit-ends-of-lines)
      ("s" mc/mark-all-in-region-regexp)
      ("n" mc/mark-next-like-this-word)
      ("p" mc/mark-previous-like-this-word)
      ("&" mc/vertical-align-with-space)
      ("(" mc/cycle-backward)
      (")" mc/cycle-forward)
      ("M-SPC" mc/remove-current-cursor)
      ("b" mc/remove-cursors-on-blank-lines)
      ("d" mc/remove-duplicated-cursors)
      ("C" mc/mark-next-lines)
      ("q" mc/remove-duplicated-cursors :exit t)))
#+END_SRC

*** Expand Region
This package allows to expand  or reduce region selection semantically
in most languages that I work with inside Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :commands (er/expand-region
               er/mark-paragraph
               er/mark-inside-pairs
               er/mark-outside-pairs
               er/mark-inside-quotes
               er/mark-outside-quotes
               er/contract-region)
    :bind (("C-c e" . hydra-er/body))
    :config (defhydra hydra-er (:hint nil)
              "
  ^Expand^           ^Mark^
  ^──────^───────────^────^─────────────────
  _e_: expand region _(_: inside pairs
  _-_: reduce region _)_: around pairs
  ^ ^                _q_: inside quotes
  ^ ^                _Q_: around quotes
  ^ ^                _p_: paragraph"
              ("e" er/expand-region :color pink)
              ("-" er/contract-region :color pink)
              ("p" er/mark-paragraph)
              ("(" er/mark-inside-pairs)
              (")" er/mark-outside-pairs)
              ("q" er/mark-inside-quotes)
              ("Q" er/mark-outside-quotes)))
#+END_SRC

*** Phi Search
This search mode is compatible with multiple cursors.

#+BEGIN_SRC emacs-lisp
  (use-package phi-search
    :bind (("C-s" . phi-search)
           ("C-r" . phi-search-backward))
    :config
    (set-face-attribute 'phi-search-selection-face nil :inherit 'isearch)
    (set-face-attribute 'phi-search-match-face nil :inherit 'region))
#+END_SRC

*** Eglot
Emacs polyglot. LSP client.

 #+BEGIN_SRC emacs-lisp
   (when (or (executable-find "clangd")
             (executable-find "rls"))
     (use-package eglot
       :hook (((c-mode c++-mode rust-mode) . eglot-ensure))
       :config
       (add-to-list 'eglot-server-programs '((c-mode c++-mode) "clangd"))
       (add-to-list 'eglot-ignored-server-capabilites :documentHighlightProvider)))
#+END_SRC

There's still one  problem though. [[Eglot]] use =project.el=  to detect the
root of current  project to run server in. Which  results in the roots
of the  project is found not  exactly where the project  root actually
is, e.g. when multiple projects are stored in single repository.

*** Project
In  order to  migrate  the problem  with  [[Eglot]] I've  used  to have  a
function wrapper over projectile, described in this [[https://github.com/joaotavora/eglot/issues/129#issuecomment-444130367][issue comment]]. But
I do not want to use projectile for that, since Emacs already features
=project.el= and Eglot uses it.  So first we need a list of project root
markers,  that   will  hold   file  names  which   we  will   look  up
recursively. we need  a function that will test  current directory for
several conditions,  like does it have  any of project markers,  is it
root directory, and  if everything fails, it will go  up one directory
and repeat.

#+BEGIN_SRC emacs-lisp
  (use-package project
    :ensure nil
    :bind (("C-c p f" . project-find-file)
           ("C-c p r" . project-find-regexp))
    :config
    (defvar project-root-markers '("Cargo.toml" "compile_commands.json" "compile_flags.txt")
      "Files or directories that indicate the root of a project.")
    (defun aorst/project-find-root (path)
      "Tail-recursive search in PATH for root markers."
      (let* ((this-dir (file-name-as-directory (file-truename path)))
             (parent-dir (expand-file-name (concat this-dir "../")))
             (system-root-dir (expand-file-name "/")))
        (cond
         ((aorst/project-root-p this-dir) (cons 'transient this-dir))
         ((equal system-root-dir this-dir) nil)
         (t (aorst/project-find-root parent-dir)))))
    (defun aorst/project-root-p (path)
      "Check if current PATH has any of project root markers."
      (let ((results (mapcar (lambda (marker)
                               (file-exists-p (concat path marker)))
                             project-root-markers)))
        (eval `(or ,@ results))))
    (add-to-list 'project-find-functions #'aorst/project-find-root))
#+END_SRC

*** Clang Format
A package to format C code with Clang Format.

#+BEGIN_SRC emacs-lisp
  (use-package clang-format
    :after cc-mode
    :bind (:map c-mode-base-map
                ("C-c C-f" . clang-format-buffer)
                ("C-c C-S-f" . clang-format-region)))
#+END_SRC

*** GCMH
The Garbage Collector Magic Hack.  Enforce a sneaky Garbage Collection
strategy to minimize GC interference with the activity.

#+BEGIN_SRC emacs-lisp
  (use-package gcmh
    :commands gcmh-mode
    :init (gcmh-mode 1))
#+END_SRC

*** VLF
This package  makes it easier to  view large files in  Emacs. It opens
files in chunks, but still allows to search through file with

#+BEGIN_SRC emacs-lisp
  (use-package vlf-setup
    :ensure vlf
    :config (setq vlf-application 'dont-ask))
#+END_SRC

*** Imenu List
Package  somewhat  similar  to  [[https://github.com/vim-scripts/taglist.vim][Taglist]] plugin  in  Vim  or  Kakoune's
[[https://github.com/andreyorst/tagbar.kak][tagbar.kak]].  Uses  =imenu= to  get information,  and since  many plugins
provide =imenu=  data it's  quite useful. I'm  using =advice-add=  here to
disable  modeline  in  =*imenu-list*=   buffer,  also  locking  it  size
preventing it from  changing when I close or resize  other windows. If
we call  =aorst/imenu-list-setup= with =:after= advice,  the modeline will
disappear in  another window. With =:after-while=  lambda evaluated only
when =imenu-list= was toggled to be shown.

#+BEGIN_SRC emacs-lisp
  (use-package imenu-list
    :defines imenu-list-idle-update-delay-time
    :bind (("<f9>" . imenu-list-smart-toggle)
           ("<f10>". imenu-list-show))
    :config
    (defun aorst/imenu-list-setup ()
      "Setings for imenu-list"
      (setq window-size-fixed 'width
            mode-line-format nil)
      (set-window-parameter (get-buffer-window (current-buffer)) 'no-other-window t))
    (advice-add 'imenu-list-smart-toggle :after-while #'aorst/imenu-list-setup)
    (setq imenu-list-idle-update-delay-time 0.1
          imenu-list-size 27
          imenu-list-focus-after-activation t))
#+END_SRC

*** Dumb Jump
This package adds ability to jump to the definition for languages that
aren't  likely supported  by any  of my  tools, by  using simple  text
search and patterns.  It supports more than 40  languages, which makes
it great candidate for a /Just Works/ solution for jumping.

#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :bind (("M-g o" . dumb-jump-go-other-window)
           ("M-g j" . dumb-jump-go))
    :config
    (setq dumb-jump-selector 'ivy)
    (when (executable-find "rg")
      (setq dumb-jump-force-searcher 'rg)))
#+END_SRC

*** Iedit Mode
Sometimes  Multiple Cursors  are  slow and  sluggish, especially  when
there's a lot of them. In this case I'm going to use =iedit= mode.

#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :bind ("C-q" . aorst/iedit-current-or-expand)
    :config
    (setq iedit-toggle-key-default "")
    (defun aorst/iedit-current-or-expand (&optional arg)
      "Select only current occurrence with `iedit-mode'.  Expand to
  next occurrence if `iedit-mode' is already active."
      (interactive "P")
      (if (bound-and-true-p iedit-mode)
          (if (symbolp arg)
              (iedit-expand-down-to-occurrence)
            (iedit-expand-up-to-occurrence))
        (iedit-mode 1))))
#+END_SRC

*** Server
I'm using  =server-start= command not because  I do not want  to load my
Emacs every time, but because I  want to have single instance of Emacs
running at a time, so all files that I open from GUI will be opened in
existing Emacs. If no Emacs exist, it should start one, start a server
and open a file.

#+BEGIN_SRC emacs-lisp
  (use-package server
    :ensure nil
    :config
    (unless (server-running-p)
      (server-start)))
#+END_SRC

To fully achieve this behavior one needs a =.desktop= file to exist that
will decide which kind of Emacs to call: =emacs= or =emacsclient=:

#+BEGIN_SRC conf-xdefaults :tangle ~/.local/share/applications/emacs.desktop :mkdirp yes
  [Desktop Entry]
  Name=Emacs
  GenericName=Text Editor
  Comment=Edit text
  MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
  Exec=sh -c "emacsclient -a emacs -n \"\$@\" || emacs" dummy %F
  Icon=emacs
  Type=Application
  Terminal=false
  Categories=Development;TextEditor;Utility;
  StartupWMClass=Emacs
#+END_SRC

This code above automatically creates user local =emacs.desktop= file in
=~/.local/share/applications= that will:

- call =emacs= if no arguments provided, or
- call =emacsclient  -a emacs= with  arguments. =emacsclient= will  try to
  connect to  a server,  and if  there's none, it  will fire  up =emacs=
  which will create server, and opening new files will be done in this
  instance of =emacs=.

*** Eldoc Box
This nice  package displays eldoc in  child frame that can  hover near
the cursor. It is really good for modes that support eldoc and removes
distraction  that happen  every  time when  your  buffer size  changes
because eldoc message appeared at the bottom. This package is affected
by [[https://gitlab.gnome.org/GNOME/mutter/issues/840][this bug]] in Gnome Shell.

#+BEGIN_SRC emacs-lisp
  (use-package eldoc-box
    :hook ((eldoc-mode . eldoc-box-hover-at-point-mode))
    :config
    (setq eldoc-box-max-pixel-width 1920
          eldoc-box-max-pixel-height 1080)
    (let ((color (if (fboundp 'doom-color)
                     (doom-color 'base0)
                   "#000000")))
      (set-face-attribute 'eldoc-box-border nil :background color)))
#+END_SRC

* Postscript
This Emacs Configuration features  various cool E-Lisp hacks somewhere
that I've  found over the  Internet, and I  try to keep  references to
original places, so reader could refer to those, because I alter these
pieces of code for my personal needs and thus it may not be compatible
with  other people  tastes,  and  because I  want  to credit  original
author.

If you  find any issue with  my config feel  free to [[https://github.com/andreyorst/dotfiles/issues/new][file an  issue]] or
contact me via email: [[mailto:andreyorst@gmail.com][andreyorst@gmail.com]].

And as a final step of a proper init file:

#+BEGIN_SRC emacs-lisp
  (provide 'init)
  ;;; init.el ends here
#+END_SRC

Thanks for reading!
