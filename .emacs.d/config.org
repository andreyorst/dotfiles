#+TITLE: Emacs configuration with Org Mode
[[https://user-images.githubusercontent.com/19470159/49866750-b2129580-fe19-11e8-9121-45c7c99850bb.png]]

This is  my Emacs configuration  file written as Org  document.  The
purpose of  this file is  to learn basics of  Org Mode and  Emacs in
general. I try to keep my configuration simple and fast and I mostly
use Emacs  as environment  for studying  LISP, currently  Scheme, so
this configuration is pretty much about it.  I'm not elisp guru yet,
so I  don't think that this  document can be really  interesting for
anyone.

I tend to split my configurations of Editors to sections.  The basic
sections are:

1. Common settings - configuration of basic editor facilities.
2. Custom commands - which stores my custom commands that I use.
3. Plugins - the set of used plugins and it's configurations.
4. Language  specific  settings  - everything  that  needed  to  feel
   comfortable while working with some language.

Since  Emacs  configuration and  Emacs  in  general is  more  complex,
compared  to  configurations of  [[https://github.com/andreyorst/dotfiles/tree/master/.config/nvim][Vim]]  or  [[https://github.com/andreyorst/dotfiles/tree/master/.config/kak][Kakoune]]  there may  be  more
sections, or  some may be missing  completely. I can't figure  out the
best way of splitting entire configuration  with Org mode so this list
may update or  disappear if I'll realize that this  isn't necessary to
have those sections.

Now to the configuration itself.

* Common settings
This section is all about basic configurations of builtin features.

** Startup
I like to  keep my starting process straightforward, so  I tend to
disable  startup screen  and  start with  lisp interaction  buffer
instead.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
#+END_SRC

I also would like  to start Emacs in Org mode  by default, so lets
=require= the  =org-mode= and  change the  default major  mode for
Emacs startup.

#+BEGIN_SRC emacs-lisp
  (require 'org)
  (setq initial-major-mode 'org-mode)
#+END_SRC

And since scratch buffer is  no longer in =lisp-interaction= mode,
it's better to change its  message to something more /appropriate/
(nothing).

#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message "")
#+END_SRC

Also I'd like to start in Org mode when file has no extension.

#+BEGIN_SRC emacs-lisp
  (setq-default major-mode 'org-mode)
#+END_SRC

** User Interface
These are  some defaults  for user interface.  I don't  like those
bars, buttons, tooltips, scrollbars, etc.

#+BEGIN_SRC emacs-lisp
  (ignore-errors
    (menu-bar-mode -1)
    (scroll-bar-mode -1)
    (tool-bar-mode -1)
    (tooltip-mode -1)
    (fset 'menu-bar-open nil))
#+END_SRC

I'm  using =ignore-errors=  here because  I use  both GUI  and TUI
versions  of Emacs,  and since  TUI version  doesn't have  some of
those features the startup process will fail.

Emacs uses weird method of naming a window, I'd like to see a file
I'm currently  working on  in the  task bar in  case my  Emacs was
minimized for some reason.

#+BEGIN_SRC emacs-lisp
  (setq-default frame-title-format '("%b â€” Emacs"))
#+END_SRC

** Font
I like  this Adobe  Source Code Pro  font. Even if  I use  Hack in
every other  editor, for some reason  I find this font  just right
for Emacs.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil :font "Source Code Pro-10")
#+END_SRC

** Common Behaviors
I don't  like how Emacs  handles scrolling,  and that it  uses tab
characters by  default.  I  need tab characters  only when  I work
with C  code and Makefile rules.   And Just because I  can, enable
bar cursor. It's not Kakoune, there's no need for big rectangle to
be honest.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil
                scroll-step 1
                scroll-conservatively 10000
                auto-window-vscroll nil
                scroll-margin 3
                cursor-type 'bar)
#+END_SRC

** Line Numbers
For some  reason Emacs has  long history  of being not  capable to
display line  numbers properly,  but now  native line  numbers are
shipped with  Emacs starting with  version 26.  However  even this
implementation is slow on large files in my experience, but I need
them, and therefore I'm enabling them in all programming modes.

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+END_SRC

** Matching Parentheses
One  feature that  I think  is really  important, especially  when
working  with lisp  code, is  ability to  see matching  paren when
cursor  stands near  the other  paren. So  I enable  it for  every
language.

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'show-paren-mode)
#+END_SRC

** Fixing Dumb Emacs Stuff
This is just some fixes of things I found kind of strange.

*** Bell
I'm not trying to insult on anyone, but usage of the bell is just
insane. It's  not 1980's, computers  have their own  speakers and
rich displays, why would anyone want to use builtin speaker?  Why
everyone should know when I'm mistaken? Disable bell.

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

*** Custom
I don't  like custom, and especially  would like to stop  it from
interfering  to  my  configuration  files, so  lets  move  it  to
separate file.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file :noerror)
#+END_SRC

*** Backups
I don't know  who decided that having backups all  over the place
is good idea, but I don't think alike.

#+BEGIN_SRC emacs-lisp
  (setq backup-by-copying t
        create-lockfiles nil
        backup-directory-alist '(("." . "~/.cache/emacs-backups"))
        auto-save-file-name-transforms '((".*" "~/.cache/emacs-backups" t)))
#+END_SRC

*** Shorter confirmation dialogues
For some reason in some situations Emacs asks for typing =yes= or
=no= explicitly,  instead of  accepting =y= or  =n=. This  can be
fixed with this.

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Trailing Whitespaces
I don't  want my  files to contain  trailing whitespaces,  so this
hook will get rid of those automatically for me.

#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** MELPA
Melpa is a  package repository, that I use to  get packages. Since
all packages  that I  need can  be obtained  from there,  I didn't
bothered with different methods of installation.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (setq package-enable-at-startup nil)
  (add-to-list 'package-archives
               '("melpa" . "https://melpa.org/packages/") t)
#+END_SRC

Note for Windows users: change =https= to =http=
*** Package initialization
This basic  piece of code  is used to  update package list  if there's
none.

#+BEGIN_SRC emacs-lisp
  (package-initialize)
  (when (not package-archive-contents)
    (package-refresh-contents))
#+END_SRC

* Functions
This section should contain functions that I've wrote for personal
use here and there. I'm not elisp expert, so code may be not the
best quality. If you feel that this code should be improved you can
open issue and blame on me all you want.

** =ensure-installed=
To ensure  that some essential  packages are installed  I've wrote
this small lisp function that checks  if package exists and if not
downloads it from Melpa.

#+BEGIN_SRC emacs-lisp
  (defun ensure-installed (package)
    "Ensure that PACKAGE is installed."
    (when (not (package-installed-p package))
      (package-install package)))
#+END_SRC

** =autokill-when-no-processes=
This function should be used as advice to any exit handle function

#+BEGIN_SRC emacs-lisp
  (defun autokill-when-no-processes (&rest args)
    "Kill buffer and its window automatically when there's no processes left."
    (when (null (get-buffer-process (current-buffer)))
        (kill-buffer (current-buffer))
        (delete-window)))
#+END_SRC

Let's define  some advices with  it. First, term buffer  should be
killed when I exit terminal:

#+BEGIN_SRC emacs-lisp
  (advice-add 'term-handle-exit :after #'autokill-when-no-processes)
#+END_SRC

I'd also would like to do this for [[Geiser]]:

#+BEGIN_SRC emacs-lisp
  (advice-add 'geiser-repl-exit :after #'autokill-when-no-processes)
#+END_SRC

** =update-inline-images=
This function is supposed to automatically update inline images in
org buffers, when for some reason image was changed.

#+BEGIN_SRC emacs-lisp
  (defun update-inline-images ()
    "Update inline images in Org-mode."
    (when org-inline-image-overlays
      (org-redisplay-inline-images)))
#+END_SRC

* Packages
Now that's  where fun  starts. I  try to  keep my  Emacs configuration
simple,  and  fast but  I  still  think  that  I need  some  essential
packages.

** Use Package
I use package, named =use-package=  to install, load and configure
my  packages.  I  find  this  way  very  consistent  and  easy  to
understand  and  maintain.    Since  =use-package=  can't  install
itself,  let's use  =ensure-installed= function  for it.  The only
thing I miss is updating those  packages, but I think I'll come up
with something someday.

#+BEGIN_SRC emacs-lisp
  (ensure-installed 'use-package)
  (require 'use-package)
  (setq use-package-always-ensure t)
#+END_SRC

** Spacemacs theme
I really  like this theme.   It's something like Atom's  One Dark,
but little more purple. Anyway it's awesome, and colors are really
nice.

#+BEGIN_SRC emacs-lisp
  (use-package spacemacs-common
      :ensure spacemacs-theme
      :config (load-theme 'spacemacs-dark t))
#+END_SRC

Also let's disable fringe background color and line numbers color,
if theme changes it.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'fringe nil :background nil)
  (set-face-attribute 'line-number nil :background nil)
#+END_SRC

** Diminish
Emacs, please stop  cluttering my modeline with all  those modes I
already know about.  Since =eldoc-mode= is builtin, I've put it to
=diminish= configuration.

#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :diminish eldoc-mode)
#+END_SRC

** Markdown
Who needs  markdown when  you have  Org?  Well,  I need.  Kinda. I
still do most of writing with it. Shame on me.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :init (defvar markdown-command "multimarkdown"))
#+END_SRC

But I hope, that Org-mode will replace it eventually.

** Geiser
Since I mostly  use Emacs for studying LISP, and  I'm reading SICP
which  uses  Scheme  as  main LISP  flavor  for  explanations  and
exercises, I need a tool to  run Scheme, and Geiser seems like the
most viable option here, since it also provides completion for it.

#+BEGIN_SRC emacs-lisp
  (use-package geiser
    :init
    (defvar geiser-active-implementations '(mit)))
#+END_SRC

** Parinfer
Now that's a quality package. It  makes writing LISP so easy, that
I've never thought it could be.

There's a lot  of configuration here, but it was  taken as is from
Parinfer Mode repository.

#+BEGIN_SRC emacs-lisp
  (use-package parinfer
    :bind
    (("C-," . parinfer-toggle-mode))
    :init
    (progn
      (setq parinfer-extensions
            '(defaults
               pretty-parens
               smart-tab
               smart-yank))
      (add-hook 'clojure-mode-hook #'parinfer-mode)
      (add-hook 'emacs-lisp-mode-hook #'parinfer-mode)
      (add-hook 'common-lisp-mode-hook #'parinfer-mode)
      (add-hook 'scheme-mode-hook #'parinfer-mode)
      (add-hook 'lisp-mode-hook #'parinfer-mode)))
#+END_SRC

** Flx
This package provides some kind of fuzzy matching for Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package flx)
#+END_SRC

** Ivy
Ivy is  a narrowing framework  like Helm,  but much lighter  in my
experience.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :init
    (setq ivy-use-virtual-buffers t
          enable-recursive-minibuffers t)
    :bind (("C-s" . swiper)
           ("C-c C-r" . ivy-resume)
           ("<f6>" . ivy-resume)
           ("M-x" . counsel-M-x)
           ("C-x C-f" . counsel-find-file)
           ("C-x C-b" . ivy-switch-buffer)
           ("C-x b" . ivy-switch-buffer)
           ("C-h f" . counsel-describe-function)
           ("C-h v" . counsel-describe-variable)
           ("C-h l" . counsel-find-library))
    :diminish ivy-mode
    :config
    (setq ivy-re-builders-alist '((t . ivy--regex-fuzzy))
          ivy-count-format ""
          ivy-display-style nil
          ivy-minibuffer-faces nil)
    (ivy-mode 1)
    (define-key minibuffer-local-map (kbd "C-r") 'counsel-minibuffer-history))
#+END_SRC

It integrates with Counsel that handles minibuffer and swiper that
handles searching in the file, so let's install those too.

#+BEGIN_SRC emacs-lisp
  (use-package counsel)
  (use-package swiper)
#+END_SRC

** Flycheck
A really nice  linting package that helps me track  errors in most
of languages.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck)
#+END_SRC

** Company
Complete anything framework. Nothing much to say. Does it's job.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :diminish company-mode
    :init
    (setq company-require-match 'never
          company-minimum-prefix-length 2
          company-frontends
          '(company-pseudo-tooltip-unless-just-one-frontend
            company-preview-frontend
            company-echo-metadata-frontend))
    :config
    (setq company-backends (remove 'company-clang company-backends)
          company-backends (remove 'company-xcode company-backends)
          company-backends (remove 'company-cmake company-backends)
          company-backends (remove 'company-gtags company-backends))
    (add-hook 'after-init-hook 'global-company-mode)
    (define-key company-active-map (kbd "TAB") 'company-complete-common-or-cycle)
    (define-key company-active-map (kbd "<tab>") 'company-complete-common-or-cycle)
    (define-key company-active-map (kbd "S-TAB") 'company-select-previous)
    (define-key company-active-map (kbd "<backtab>") 'company-select-previous))
#+END_SRC

*** Company flx
This   actually  makes   company  behave   as  fuzzy   completion
framework. It's kind of slow though.

#+BEGIN_SRC emacs-lisp
  (use-package company-flx
    :init
    (add-hook 'company-mode-hook (lambda ()
                                   (add-to-list 'company-backends 'company-capf)))
    :config
    (company-flx-mode +1))
#+END_SRC

*** Company lsp
To make compay understand completions from language servers we need this backend.

#+BEGIN_SRC emacs-lisp
  (use-package company-lsp)
#+END_SRC

** Undo Tree
This is more  familiar undo mode. It adds C-/  mapping to undo and
C-?  mapping to redo.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :diminish undo-tree-mode
    :config
    (global-undo-tree-mode 1))
#+END_SRC

** Yasnippet
Another  very  handy  package,  that  helps  insert  templates  of
code. Now I really need to write some snippets to use...

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :diminish yas-minor-mode
    :config
    (add-hook 'prog-mode-hook 'yas-minor-mode))
#+END_SRC

Since  we need  snippets in  all programming  modes, and  I didn't
found a proper way to load them without extra snippets package, to
load my own snippets lets use this hook.

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'yas-reload-all)
#+END_SRC

** Projectile
Since emacs  is stupid,  it changes  working directory  to current
file location. So  I need a whole plugin to  workaround this silly
issue.

However this plugin is quite useful with Git repositories.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :init
    (projectile-mode +1)
    :bind
    (("C-c p" . projectile-command-map)))
#+END_SRC

*** Counsel projectile
It makes using projectile easier by allowing fuzzy matching.

#+BEGIN_SRC emacs-lisp
  (use-package counsel-projectile)
#+END_SRC

** GNU Plot
This is a package needed  for making plots with gnuplot.  Required
by Org mode.

#+BEGIN_SRC emacs-lisp
  (use-package gnuplot)
#+END_SRC

** Rust
I'd  like  to  have  Rust   syntax  highlighting  and  some  basic
facilities, since I'm planning to write my exercises in org mode.

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode)
#+END_SRC

** TOML
=toml-mode= helps  with highlighting of TOML files,  which Rust uses
to configure project.

#+BEGIN_SRC emacs-lisp
  (use-package toml-mode)
#+END_SRC

** LSP Mode
To provide nice IDE-like features, I like to use language servers,
that can be handled with language server protocol mode for Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :commands lsp
    :config
    (setq lsp-highlight-symbol-at-point nil))
#+END_SRC

LSP can provide lots of information  to observe, so it's useful to
be able to view it. Luckily there's a package for it.

#+BEGIN_SRC emacs-lisp
  (use-package lsp-ui :commands lsp-ui-mode)
#+END_SRC

This mode also can be used with company, so lets install a backend
for it.

#+BEGIN_SRC emacs-lisp
  (use-package company-lsp :commands company-lsp)
#+END_SRC

*** cquery
=cquery= is a  language server for C/C++ code.  It interacts with
[[lsp-mode]].

#+BEGIN_SRC emacs-lisp
  (use-package cquery
    :after lsp-mode
    :config
    (setq cquery-executable "/usr/bin/cquery"
          cquery-cache-dir "~/.cache/cquery"
          cquery-sem-highlight-method 'font-lock
          cquery-extra-args '("--log-file=/tmp/cq.log")))
#+END_SRC

** Clang Format
I use clang-format tool to format my C/C++ code.

#+BEGIN_SRC emacs-lisp
  (use-package clang-format)
#+END_SRC

** EditorConfig
Speaking of  formatting, =.editorconfig= file  provides a nice  way to
synchronize my editor configurations between projects.

#+BEGIN_SRC emacs-lisp
  (use-package editorconfig
    :diminish editorconfig-mode
    :config
    (editorconfig-mode 1))
#+END_SRC

** Magit
Magit is a  Emacs interface to Git.  I've heard that it  has many nice
features, so I want to try it out.

#+BEGIN_SRC emacs-lisp
  (use-package magit)
#+END_SRC

** Ediff
Ediff is part of Emacs, so I just want to configure it to my liking.

#+BEGIN_SRC emacs-lisp
  (setq ediff-split-window-function 'split-window-horizontally)
#+END_SRC

* Modes
This section will contain some  settings for various modes that are
not handled within package configurations.

** Org Mode
For Org Mode I need spell checking to be default, and yasnippet so
I could expand some useful things like =SRC= blocks.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook (lambda()
                             (org-indent-mode)
                             (flyspell-mode)
                             (yas-minor-mode)
                             (yas-reload-all)
                             (setq default-justification 'full
                                   org-startup-with-inline-images t
                                   org-startup-folded 'content)
                             (auto-fill-mode)))
#+END_SRC

Latex  preview feature  is really  awesome,  but I  don't want  my
images stored in plain sight. At least use hidden folder.

#+BEGIN_SRC emacs-lisp
  (setq org-latex-preview-ltxpng-directory ".ltximg/")
#+END_SRC

To highlight code blocks when  exporting to LaTeX we need =minted=
package   installed  system-wide   and  this   code  (taken   from
[[https://emacs.stackexchange.com/questions/20839/exporting-code-blocks-to-pdf-via-latex/20841#20841][emacs.stackexchange.com]]):

#+BEGIN_SRC emacs-lisp
  (require 'ox-latex)
  (setq org-latex-listings 'minted)
  (add-to-list 'org-latex-packages-alist '("" "minted" nil))
#+END_SRC

This will  make =pdflatex=  use these  escape sequence  for proper
colors.

#+BEGIN_SRC emacs-lisp
  (setq org-latex-pdf-process
        '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

I think I also need this, but I'm not sure:

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC

Since Org-mode allows inline images, we need a way to update them,
if image changes  for some reason. We will use  hook after loading
Org-mode.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-babel-after-execute-hook 'update-inline-images)
#+END_SRC

This will  come in handy  when using Org  with GNU Plot.  Lets add
support for it to Org-mode.

#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((gnuplot . t)))
#+END_SRC

To  prevent Emacs  from constantly  asking  if I  want to  execute
source code, lets set =org-confirm-babel-evaluate= to =nil=

#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

To export Org to Markdown, we need this:

#+BEGIN_SRC emacs-lisp
  (require 'ox-md nil t)
#+END_SRC

** C/Cpp Mode
I don't think that I'm gonna  use Emacs for C/C++ development, but
sometimes  I'm just  in the  mood of  opening some  sources inside
Emacs. For  such reasons I  just want  to have sane  defaults that
match my workflow.

#+BEGIN_SRC emacs-lisp
  (add-hook 'c-mode-common-hook
            '(lambda()
               (setq indent-tabs-mode t
                     c-basic-offset 4
                     tab-width 4)
               (lsp)))
#+END_SRC

** Rust
Since I make notes in Org-mode, and  I started to use it for Rust too,
I need some settings for Rust mode.

#+BEGIN_SRC emacs-lisp
  (add-hook 'rust-mode-hook
            '(lambda()
               (lsp)
               (eldoc-mode)
               (setq company-tooltip-align-annotations t)))
#+END_SRC

** Markdown
For markdown  mode I would like  to have automatic spell  checking and
filling. Basically the same setup as for Org Mode.

#+BEGIN_SRC emacs-lisp
  (add-hook 'markdown-mode-hook
            '(lambda()
               (flyspell-mode)
               (setq fill-column 80
                     default-justification 'full)
               (auto-fill-mode)))

#+END_SRC
