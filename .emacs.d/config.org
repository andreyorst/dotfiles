#+title: Emacs configuration with Org Mode
#+setupfile: ~/.dotfiles/.org-defaults.org

[[file:.sceenshot.png]]

This  is my  Emacs configuration  file written  as Org  document.  The
purpose of  this file  is to  learn basics  of Org  Mode and  Emacs in
general. I try  to keep my configuration simple and  fast and I mostly
use Emacs as environment for  studying LISP, currently Scheme, so this
configuration is pretty  much about it.  I'm not Emacs  Lisp guru yet,
so I  don't think  that this  document can  be really  interesting for
anyone.

I tend to split my configurations of Editors to sections.  The basic
sections are:

1. *[[*Common  settings][Common settings]]* -  configuration of basic editor  facilities.
2. Custom commands  - which stores my custom commands  that I use. But
   since  in Emacs  everything is  a function,  the section  is called
   *[[*Functions][Functions]]*.
3. Language  specific  settings  - everything  that  needed  to  feel
   comfortable while  working with  some language.  In case  of Emacs,
   this section would be called *[[*Modes][Modes]]*.
4. Plugins - or  *[[*Packages][Packages]]* to be precise, is the  set of used plugins
   and it's configurations.

Since  Emacs  configuration and  Emacs  in  general is  more  complex,
compared to  [[https://github.com/andreyorst/dotfiles/tree/master/.config/nvim][Vim]], [[https://github.com/andreyorst/dotfiles/tree/master/.config/kak][Kakoune]],  and other editors,  there may  actually be
more sections, or  some may be missing completely. I  can't figure out
the best way  of splitting entire configuration with Org  mode so this
list may update or disappear if I'll realize that this isn't necessary
to have those sections.

Now on to the configuration itself.

* Common settings
This   section  is   all   about  basic   configurations  of   builtin
features. Emacs provides a lot of settings  on it's own, but I want to
stay  as  close   as  possible  to  the  defaults,   except  for  some
things. That's also answers why I don't  use Evil mode. If I wanted to
use Vim, I'd just used Vim.

** Startup
I  like to  keep my  starting process  straightforward, so  I tend  to
disable startup screen and start with the =*scratch*= buffer instead.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
#+END_SRC

I also would like  to start Emacs in Org mode  by default, so lets
=require= the  =org-mode= and  change the  default major  mode for
Emacs startup.

#+BEGIN_SRC emacs-lisp
  (require 'org)
  (setq initial-major-mode 'org-mode)
#+END_SRC

And since scratch buffer is  no longer in =lisp-interaction= mode,
it's better to change its  message to something more /appropriate/
(nothing).

#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message "")
#+END_SRC

Also I'd like to start in Org mode when file has no extension.

#+BEGIN_SRC emacs-lisp
  (setq-default major-mode 'org-mode)
#+END_SRC

** User Interface
These are  some defaults  for user interface.  I don't  like those
bars, buttons, tooltips, scrollbars, etc.

#+BEGIN_SRC emacs-lisp
  (ignore-errors
    (menu-bar-mode -1)
    (scroll-bar-mode -1)
    (tool-bar-mode -1)
    (tooltip-mode -1)
    (fset 'menu-bar-open nil))
#+END_SRC

I'm  using =ignore-errors=  here because  I use  both GUI  and TUI
versions  of Emacs,  and since  TUI version  doesn't have  some of
those features the startup process will fail.

Emacs uses weird method of naming a window, I'd like to see a file
I'm currently  working on  in the  task bar in  case my  Emacs was
minimized for some reason.

#+BEGIN_SRC emacs-lisp
  (setq-default frame-title-format '("%b — Emacs"))
#+END_SRC

** Font
I like  this Adobe  Source Code Pro  font. Even if  I use  Hack in
every other  editor, for some reason  I find this font  just right
for Emacs.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil :font "Source Code Pro-10")
#+END_SRC

** Common Behaviors
I don't  like how Emacs  handles scrolling,  and that it  uses tab
characters by  default.  I  need tab characters  only when  I work
with C  code and Makefile rules.   And Just because I  can, enable
bar cursor. It's not Kakoune, there's no need for big rectangle to
be honest.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil
                scroll-step 1
                scroll-conservatively 10000
                auto-window-vscroll nil
                scroll-margin 3
                cursor-type 'bar)
#+END_SRC

** Input Languages
I use two keyboard layouts: =qwerty=  and =йцукен=, therefore I need a
way to switch between those without loosing ability to use such chords
as =C-x= which will become a =C-ч=  if I select Cyrillic layout in the
OS. Luckily for  me, Emacs provides a method to  switch layouts within
Emacs with =C-\=, so all common shortcuts will still work fine.

#+BEGIN_SRC emacs-lisp
  (setq default-input-method 'russian-computer)
#+END_SRC

I'm  not  using  =russian-jcuken=   here  because  it  represents  the
"typewriter" layout with number-line inverted,  so to access numbers I
need to use Shift key. =russian-computer= doesn't have this problem.

** Line Numbers
For some  reason Emacs has  long history  of being not  capable to
display line  numbers properly,  but now  native line  numbers are
shipped with  Emacs starting with  version 26.  However  even this
implementation is slow on large files in my experience, but I need
them, and therefore I'm enabling them in all programming modes.

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+END_SRC

** Matching Parentheses
One feature that I think  is really important, especially when working
with lisp code, is ability to  see matching bracket when cursor stands
near the other bracket. So I enable it for every programming language.

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'show-paren-mode)
#+END_SRC

** Fixing Dumb Emacs Stuff
This is just some fixes of things I found kind of strange.

*** Bell
I'm not trying to insult on anyone, but usage of the bell is just
insane. It's  not 1980's, computers  have their own  speakers and
rich displays, why would anyone want to use builtin speaker?  Why
everyone should know when I'm mistaken? Disable bell.

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

*** Custom
I don't  like custom, and especially  would like to stop  it from
interfering  to  my  configuration  files, so  lets  move  it  to
separate file.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file :noerror)
#+END_SRC

*** Backups
I don't know  who decided that having backups all  over the place
is good idea, but I don't think alike.

#+BEGIN_SRC emacs-lisp
  (setq backup-by-copying t
        create-lockfiles nil
        backup-directory-alist '(("." . "~/.cache/emacs-backups"))
        auto-save-file-name-transforms '((".*" "~/.cache/emacs-backups" t)))
#+END_SRC

*** Shorter confirmation dialogues
For some reason in some situations Emacs asks for typing =yes= or
=no= explicitly,  instead of  accepting =y= or  =n=. This  can be
fixed with this.

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Trailing Whitespaces
I don't  want my  files to contain  trailing whitespaces,  so this
hook will get rid of those automatically for me.

#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** MELPA
Melpa is a  package repository, that I use to  get packages. Since
all packages  that I  need can  be obtained  from there,  I didn't
bothered with different methods of installation.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (setq package-enable-at-startup nil)
  (add-to-list 'package-archives
               '("melpa" . "https://melpa.org/packages/") t)
#+END_SRC

Note for Windows users: change =https= to =http=
*** Package initialization
This basic  piece of code  is used to  update package list  if there's
none.

#+BEGIN_SRC emacs-lisp
  (package-initialize)
  (when (not package-archive-contents)
    (package-refresh-contents))
#+END_SRC

* Functions
This section should contain functions that I've wrote for personal
use here and there. I'm not elisp expert, so code may be not the
best quality. If you feel that this code should be improved you can
open issue and blame on me all you want.

** =ensure-installed=
To ensure  that some essential  packages are installed  I've wrote
this small lisp function that checks  if package exists and if not
downloads it from Melpa.

#+BEGIN_SRC emacs-lisp
  (defun ensure-installed (package)
    "Ensure that PACKAGE is installed."
    (when (not (package-installed-p package))
      (package-install package)))
#+END_SRC

** =autokill-when-no-processes=
This function should be used as advice to any exit handle function

#+BEGIN_SRC emacs-lisp
  (defun autokill-when-no-processes (&rest args)
    "Kill buffer and its window automatically when there's no processes left."
    (when (null (get-buffer-process (current-buffer)))
        (kill-buffer (current-buffer))
        (delete-window)))
#+END_SRC

Let's define  some advices with  it. First, term buffer  should be
killed when I exit terminal:

#+BEGIN_SRC emacs-lisp
  (advice-add 'term-handle-exit :after #'autokill-when-no-processes)
#+END_SRC

I'd also would like to do this for [[Geiser]]:

#+BEGIN_SRC emacs-lisp
  (advice-add 'geiser-repl-exit :after #'autokill-when-no-processes)
#+END_SRC

** =update-inline-images=
This function is supposed to automatically update inline images in
org buffers, when for some reason image was changed.

#+BEGIN_SRC emacs-lisp
  (defun update-inline-images ()
    "Update inline images in Org-mode."
    (when org-inline-image-overlays
      (org-redisplay-inline-images)))
#+END_SRC

** =move-line-up=
This function moves current line  down. This is pretty common function
for most of editors, and sometimes I want to move lines around so this
will come in handy.

#+BEGIN_SRC emacs-lisp
  (defun move-line-up ()
    "Move up the current line."
    (interactive)
    (transpose-lines 1)
    (forward-line -2)
    (indent-according-to-mode))
#+END_SRC

Let's bind it to =C-s-up= or /Ctrl/ + /Super/ + /Up/.

#+BEGIN_SRC emacs-lisp
  (global-set-key [C-s-up] 'move-line-up)
  #+END_SRC

** =move-line-down=
The same as above but moves line down.

#+BEGIN_SRC emacs-lisp
  (defun move-line-down ()
    "Move down the current line."
    (interactive)
    (forward-line 1)
    (transpose-lines 1)
    (forward-line -1)
    (indent-according-to-mode))
#+END_SRC

Let's bind it to =C-s-down= or /Ctrl/ + /Super/ + /Down/.

#+BEGIN_SRC emacs-lisp
  (global-set-key [C-s-down] 'move-line-down)
  #+END_SRC

* Modes
This section will contain some  settings for various modes that are
not handled within package configurations.

** Org Mode
Org  Mode is  a great  mode for  taking notes,  managing to-do  lists,
writing books, literate programming, and  many other things. I primary
use it for taking notes on different programming languages, and manage
my Emacs configuration with it.

*** Startup Settings
For Org  Mode I  need spell  checking to be  enabled by  default. Also
Org-mode plays nicely with justification, so I'll set it to =full=, as
I think that it is the most appropriate format for text. Org files are
capable of displaying images, so let's enable them by default. There's
also a  nice mode  called =org-indent-mode= that  makes easier  to see
different sub-trees.  Speaking  of sub-trees, =org-startup-folded= can
be  set to  ='content=,  so every  document will  look  like table  of
contents by default. Last but not least, let's enable =auto-fill-mode=
for  org mode,  so all  text will  be folded  and re-filled  after its
length reaches the =fill-column= value.
document

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook (lambda()
                             (flyspell-mode)
                             (setq default-justification 'full
                                   org-startup-with-inline-images t
                                   org-startup-folded 'content
                                   revert-without-query '(".*\.pdf"))
                             (org-indent-mode)
                             (auto-fill-mode)))
#+END_SRC

This will fontify code inside =SRC_BLOCK= sections:

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC

*** Inline Images
Since Org-mode allows inline images, we need a way to update them,
if  image  changes  for  some  reason.   We  will  use  hook  to  call
[[*=update-inline-images=][=update-inline-images=]] function after executing code with babel.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-babel-after-execute-hook 'update-inline-images)
#+END_SRC

**** Inline LaTeX Preview
Latex preview  feature is  really awesome, but  I don't  want produced
images to be stored in plain sight. At least use hidden folder.

#+BEGIN_SRC emacs-lisp
  (setq org-latex-preview-ltxpng-directory ".ltximg/")
#+END_SRC

*** Org Mappings
I  don't   like  that   my  =S-tab=   mapping  for   Company  triggers
=org-shifftab= function, so I'll remap it to use =C-tab= instead.

#+BEGIN_SRC emacs-lisp
  (define-key org-mode-map [backtab] nil)
  (define-key org-mode-map [S-iso-lefttab] nil)
  (define-key org-mode-map [C-tab] nil)
  (define-key org-mode-map [C-tab] 'org-shifttab)
#+END_SRC

*** Syntax Highlighting in Exported PDFs
To highlight code blocks when  exporting to LaTeX we need =minted=
package   installed  system-wide   and  this   code  (taken   from
[[https://emacs.stackexchange.com/questions/20839/exporting-code-blocks-to-pdf-via-latex/20841#20841][emacs.stackexchange.com]]):

#+BEGIN_SRC emacs-lisp
  (require 'ox-latex)
  (setq org-latex-listings 'minted)
#+END_SRC

Minted creates annoying  directories named =_minted-documentname=, and
I don't  want them to be  in plain sight.  So this code here  will put
those directories to temporary folder on my system.

#+BEGIN_SRC emacs-lisp
  (defvar minted-cache-dir
    (file-name-as-directory
     (expand-file-name ".minted/\\jombname"
                       temporary-file-directory)))

  (add-to-list 'org-latex-packages-alist
               `(,(concat "cachedir=" minted-cache-dir)
                 "minted" nil))
#+END_SRC

Now we need to tell =pdflatex= to use these escape sequence for proper
colors. This part is worth checking  for a more proper way of handling
highlighting, because right  now code blocks written  in language that
=minted= doesn't  support will not be  exported to PDF at  all.  But I
don't know how to fix this.

#+BEGIN_SRC emacs-lisp
  (setq org-latex-pdf-process
        '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

*** Cleanup After Export
Since I'm exporting my notes to PDF as final file format, I don't need
intermediary =.tex=  file to stay.  Let's assume that these  files are
log files, so Org mode will remove those after exporting is finished.

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'org
    '(add-to-list 'org-latex-logfiles-extensions "tex"))
#+END_SRC

This will get rid of =.tex= files.

*** Executable Languages
A nice feature of Org-mode over Markdown is that we can execute source
code  blocks with  a keybinding  and see  results inside  the document
itself.  Let's  define what languages  can be executed with  =C-c C-c=
shortcut from org mode:

#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((gnuplot . t)
     (scheme . t)))
#+END_SRC

And  to prevent  Emacs from  constantly asking  if I  want to  execute
source code, lets set =org-confirm-babel-evaluate= to =nil=

#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

*** Paragraphs
I would like to use the same level headings after certain part, so all
my   deeply   nested   notes   contained   right   section   separator
headings. This is a hacky way but it works:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-latex-classes
               '("article"
                 "\\documentclass{article}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
#+END_SRC

*** Markdown Export
I don't  think that I gonna  use this much,  but just in case  if I'll
ever decide to export Org to Markdown, I'll need this:

#+BEGIN_SRC emacs-lisp
  (require 'ox-md nil t)
#+END_SRC

** Flyspell Mode
It's annoying that if I save  word to my personal dictionary, all other
misspelled  words  are no  longer  highlighted,  and  I need  to  call
=flyspell-buffer= again and again. Let's get rid of this.

#+BEGIN_SRC emacs-lisp
  (defun flyspell-buffer-after-pdict-save (&rest _)
    (flyspell-buffer))

  (advice-add 'ispell-pdict-save :after #'flyspell-buffer-after-pdict-save)
#+END_SRC

I've found  this trick [[https://www.reddit.com/r/emacs/comments/4oc7pg/spellcheck_flyspellmode_underlines_disappear_when/d5ptwql/][here]],  but I  don't really like  this solution,
since I don't  understand why I need to define  another function, that
just  calls =flyspell-buffer=  but  it works  fine.

** Doc View Mode
Default resolution is too low:

#+BEGIN_SRC emacs-lisp
  (setq doc-view-resolution 192)
#+END_SRC

* Packages
Now that's  where fun  starts. I  try to  keep my  Emacs configuration
simple,  and  fast but  I  still  think  that  I need  some  essential
packages.

** Use Package
I use package, named =use-package=  to install, load and configure
my  packages.  I  find  this  way  very  consistent  and  easy  to
understand  and  maintain.    Since  =use-package=  can't  install
itself,  let's use  =ensure-installed= function  for it.  The only
thing I miss is updating those  packages, but I think I'll come up
with something someday.

#+BEGIN_SRC emacs-lisp
  (ensure-installed 'use-package)
  (require 'use-package)
  (setq use-package-always-ensure t)
#+END_SRC

** Spacemacs theme
I really  like this theme.   It's something like Atom's  One Dark,
but little more purple. Anyway it's awesome, and colors are really
nice.

#+BEGIN_SRC emacs-lisp
  (use-package spacemacs-common
      :ensure spacemacs-theme
      :config (load-theme 'spacemacs-dark t))
#+END_SRC

Also let's disable fringe background color and line numbers color,
if theme changes it.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'fringe nil :background nil)
  (set-face-attribute 'line-number nil :background nil)
#+END_SRC

** Diminish
Emacs, please stop  cluttering my modeline with all  those modes I
already know about.  Since =eldoc-mode= is builtin, I've put it to
=diminish= configuration.

#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :diminish eldoc-mode)
#+END_SRC

** Markdown
Sometimes I need to edit Markdown documents, so this package is handy.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :init (defvar markdown-command "multimarkdown"))
#+END_SRC

For markdown  mode I would like  to have automatic spell  checking and
filling. Basically the same setup as for Org Mode.

#+BEGIN_SRC emacs-lisp
  (add-hook 'markdown-mode-hook
            '(lambda()
               (flyspell-mode)
               (setq fill-column 80
                     default-justification 'left)
               (auto-fill-mode)))

#+END_SRC

** Geiser
Since I mostly  use Emacs for studying LISP, and  I'm reading SICP
which  uses  Scheme  as  main LISP  flavor  for  explanations  and
exercises, I need a tool to  run Scheme, and Geiser seems like the
most viable option here, since it also provides completion for it.

#+BEGIN_SRC emacs-lisp
  (use-package geiser
    :config
    (add-hook 'scheme-mode-hook 'geiser-mode)
    :init
    (setq geiser-active-implementations '(guile)
          geiser-default-implementation 'guile))
#+END_SRC

** Parinfer
Now that's a quality package. It  makes writing LISP so easy, that
I've never thought it could be.

There's a lot  of configuration here, but it was  taken as is from
Parinfer Mode repository.

#+BEGIN_SRC emacs-lisp
  (use-package parinfer
    :bind
    (("C-," . parinfer-toggle-mode))
    :init
    (progn
      (setq parinfer-extensions
            '(defaults
               pretty-parens
               smart-tab
               smart-yank))
      (add-hook 'clojure-mode-hook #'parinfer-mode)
      (add-hook 'emacs-lisp-mode-hook #'parinfer-mode)
      (add-hook 'common-lisp-mode-hook #'parinfer-mode)
      (add-hook 'scheme-mode-hook #'parinfer-mode)
      (add-hook 'lisp-mode-hook #'parinfer-mode)))
#+END_SRC

** Flx
This package provides some kind of fuzzy matching for Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package flx)
#+END_SRC

** Ivy and Counsel
Ivy is  a narrowing framework  like Helm,  but much lighter  in my
experience.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :init
    (setq ivy-use-virtual-buffers t
          enable-recursive-minibuffers t)
    :bind (("C-c C-r" . ivy-resume)
           ("<f6>" . ivy-resume)
           ("C-x C-b" . ivy-switch-buffer)
           ("C-x b" . ivy-switch-buffer))
    :diminish ivy-mode
    :config
    (setq ivy-re-builders-alist '((t . ivy--regex-fuzzy))
          ivy-count-format ""
          ivy-display-style nil
          ivy-minibuffer-faces nil)
    (ivy-mode 1))
#+END_SRC

It integrates with  Counsel that handles minibuffer,  so let's install
it too.

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :bind (("M-x" . counsel-M-x)
           ("C-x C-f" . counsel-find-file)
           ("C-h f" . counsel-describe-function)
           ("C-h v" . counsel-describe-variable)
           ("C-h l" . counsel-find-library)))
#+END_SRC

** Flycheck
A really nice  linting package that helps me track  errors in most
of languages.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck)
#+END_SRC

** Company
Complete anything framework. Nothing much to say. Does it's job.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :diminish company-mode
    :bind (:map company-active-map
                ("TAB" . company-complete-common-or-cycle)
                ("<tab>" . company-complete-common-or-cycle)
                ("<S-Tab>" . company-select-previous)
                ("<backtab>" . company-select-previous))
    :init
    (add-hook 'after-init-hook 'global-company-mode)
    (setq company-require-match 'never
          company-minimum-prefix-length 3
          company-tooltip-align-annotations t
          company-frontends
          '(company-pseudo-tooltip-unless-just-one-frontend
            company-preview-frontend
            company-echo-metadata-frontend))
    :config
    (setq company-backends (remove 'company-clang company-backends)
          company-backends (remove 'company-xcode company-backends)
          company-backends (remove 'company-cmake company-backends)
          company-backends (remove 'company-gtags company-backends)))
#+END_SRC

** Undo Tree
This is more  familiar undo mode. It adds C-/  mapping to undo and
C-?  mapping to redo.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :diminish undo-tree-mode
    :config
    (global-undo-tree-mode 1))
#+END_SRC

** Yasnippet
Another  very  handy  package,  that  helps  insert  templates  of
code. Now I really need to write some snippets to use...

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :diminish yas-minor-mode)
#+END_SRC

** Projectile
Since Emacs  is stupid,  it changes  working directory  to current
file location. So  I need a whole plugin to  workaround this silly
issue.

However this plugin is quite useful with Git repositories.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :init
    (projectile-mode +1)
    :bind
    (("C-c p" . projectile-command-map)))
#+END_SRC

*** Counsel projectile
It makes using projectile easier by allowing fuzzy matching.

#+BEGIN_SRC emacs-lisp
  (use-package counsel-projectile)
#+END_SRC

** GNU Plot
This is a package needed  for making plots with gnuplot.  Required
by Org mode.

#+BEGIN_SRC emacs-lisp
  (use-package gnuplot)
#+END_SRC

** Rust
I'd  like  to  have  Rust   syntax  highlighting  and  some  basic
facilities, since I'm planning to write my exercises in org mode.

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode)
#+END_SRC

Since I make notes in Org-mode, and  I started to use it for Rust too,
I need some settings for Rust mode.

#+BEGIN_SRC emacs-lisp
  (add-hook 'rust-mode-hook
            '(lambda()
               (racer-mode)
               (yas-minor-mode)
               (electric-pair-mode)
               (eldoc-mode)
               (setq company-tooltip-align-annotations t)))
#+END_SRC

*** Racer
Racer is a Rust Auto-Complete-er.

#+BEGIN_SRC emacs-lisp
  (use-package racer)
#+END_SRC

** TOML
=toml-mode= helps  with highlighting of TOML files,  which Rust uses
to configure project.

#+BEGIN_SRC emacs-lisp
  (use-package toml-mode)
#+END_SRC

** EditorConfig
Speaking of  formatting, =.editorconfig= file  provides a nice  way to
synchronize my editor configurations between projects.

#+BEGIN_SRC emacs-lisp
  (use-package editorconfig
    :diminish editorconfig-mode
    :config
    (editorconfig-mode 1))
#+END_SRC

** Magit
Magit is a  Emacs interface to Git.  I've heard that it  has many nice
features, so I want to try it out.

#+BEGIN_SRC emacs-lisp
  (use-package magit)
#+END_SRC

** Vdiff
=vdiff=  is a  package, that  works similar  to Vimdiff.   Ediff isn't
really comfortable to use, and  vdiff also has integration with [[*Magit][Magit]],
so I gonna try it out.

#+BEGIN_SRC emacs-lisp
  (use-package vdiff
    :bind (:map vdiff-mode-map
                ("C-c" . vdiff-mode-prefix-map))
    :init (setq vdiff-lock-scrolling t
                vdiff-diff-algorithm 'diff
                vdiff-disable-folding nil
                vdiff-min-fold-size 4
                vdiff-subtraction-style 'full
                vdiff-subtraction-fill-char ?\ )
    :config
    (set-face-attribute 'vdiff-subtraction-face nil :background "#553333" :foreground "#cc99999")
    (set-face-attribute 'vdiff-addition-face nil :background "#335533" :foreground "#cceecc")
    (set-face-attribute 'vdiff-change-face nil :background "#293239" :foreground "#4f97d7"))
#+END_SRC

*** Vdiff Magit
=vdiff-magit= is a supplement  package, that provides integration with
[[*Magit][Magit]] package.

#+BEGIN_SRC emacs-lisp
  (use-package vdiff-magit
    :bind (:map magit-mode-map
                ("e" . 'vdiff-magit-dwim)
                ("E" . 'vdiff-magit))
    :init
    (setq vdiff-magit-stage-is-2way t)
    :config
    (transient-suffix-put 'magit-dispatch "e" :description "vdiff (dwim)")
    (transient-suffix-put 'magit-dispatch "e" :command 'vdiff-magit-dwim)
    (transient-suffix-put 'magit-dispatch "E" :description "vdiff")
    (transient-suffix-put 'magit-dispatch "E" :command 'vdiff-magit))
#+END_SRC

** Which Key
=which-key= is  a package that  can show all possible  completions for
keyboard shortcuts in a popup menu. I'm still learning Emacs, so let's
enable it by default.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish which-key-mode
    :config
    (which-key-mode))
#+END_SRC

** Multiple Cursors
This  package provides  multiple  cursors functionality  to Emacs.  It
isn't much like Kakoune's multiple selections, but anything will do. I
guess I'll figure out best mappings over time.

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :bind
    (("C-S-c C-S-c" . mc/edit-lines)
     ("C-S-c C-e" . mc/edit-ends-of-lines)
     ("C-S-c C-a" . mc/edit-beginnings-of-lines)
     ("C-S-<mouse-1>" . mc/add-cursor-on-click)

     ;; Mark additional regions matching current region
     ("C-s-e" . mc/mark-previous-like-this)
     ("C-s-d" . mc/mark-next-like-this)
     ("C-s-A" . mc/mark-more-like-this-extended)
     ("C-s-a" . mc/mark-all-in-region)

     ;; Symbol and word specific mark-more
     ("C-s-D" . mc/mark-next-word-like-this)
     ("C-s-E" . mc/mark-previous-word-like-this)
     ("C-s-w" . mc/mark-all-words-like-this)
     ("C-s-s" . mc/mark-next-symbol-like-this)
     ("C-s-q" . mc/mark-previous-symbol-like-this)
     ("M-s-S" . mc/mark-all-symbols-like-this)))
#+END_SRC

** Phi Search
This search mode is compatible with multiple cursors.

#+BEGIN_SRC emacs-lisp
  (use-package phi-search
    :bind (("C-s" . phi-search)
           ("C-r" . phi-search-backward)))
#+END_SRC

** Eyebrowse
This  package imitates  virtual workspaces,  or virtual  frames inside
single Emacs  frame. This  is really  useful, when  you have  bunch of
windows, and you  want to open new  set but don't want  to loose other
window configurations. It works much like Vim tabs, or Tmux windows.

#+BEGIN_SRC emacs-lisp
  (use-package eyebrowse
    :config
    (eyebrowse-mode t))
#+END_SRC
